import { Router } from 'express';
export const pipeline = Router();

// ---- Canonical contract the UI expects ----
// lanes: new | requiresdocs | inreview | withlender | accepted | declined
const CANON = ['new','requiresdocs','inreview','withlender','accepted','declined'] as const;
type CanonStatus = typeof CANON[number];

const STATUS_MAP: Record<string, CanonStatus> = {
  // new
  'new': 'new', 'open':'new', 'fresh':'new', 'created':'new',
  // requires docs
  'requires_docs': 'requiresdocs', 'requiresdocs':'requiresdocs', 'reqdocs':'requiresdocs', 'docs':'requiresdocs', 'needs_docs':'requiresdocs',
  // in review / underwriting
  'in_review':'inreview', 'inreview':'inreview', 'review':'inreview', 'uw':'inreview', 'underwriting':'inreview',
  // with lender / sent
  'with_lender':'withlender', 'withlender':'withlender', 'sent':'withlender', 'submitted':'withlender',
  // accepted / approved
  'accepted':'accepted', 'approved':'accepted', 'offer_accepted':'accepted', 'won':'accepted',
  // declined / rejected
  'declined':'declined', 'rejected':'declined', 'lost':'declined'
};

function toCanonStatus(raw: any): CanonStatus {
  const s = String(raw ?? '').trim().toLowerCase();
  return (STATUS_MAP[s] ?? 'new');
}

function toId(x: any): string {
  // normalize various id shapes to a stable string
  if (x == null) return '';
  if (typeof x === 'string') return x;
  if (typeof x === 'number') return String(x);
  if (typeof x === 'object') {
    // common legacy patterns: x.id, x._id
    if (x.id != null) return toId(x.id);
    if (x._id != null) return toId(x._id);
  }
  try { return JSON.stringify(x); } catch { return String(x); }
}

function toNum(x: any): number {
  const n = Number(String(x ?? '').replace(/[^0-9.-]/g,''));
  return Number.isFinite(n) ? n : 0;
}

// Single place that shapes cards to the UI contract
function shapeCard(raw: any) {
  return {
    id: toId(raw?.id ?? raw?._id ?? raw?.applicationId),
    businessName: raw?.businessName ?? raw?.name ?? raw?.company ?? 'Unknown Business',
    amount: toNum(raw?.amount ?? raw?.requestedAmount ?? raw?.fundingAmount),
    status: toCanonStatus(raw?.status ?? raw?.stage ?? raw?.pipeline_status),
    createdAt: raw?.createdAt ?? raw?.created_at ?? raw?.submittedAt ?? null,
    lastActivityAt: raw?.updatedAt ?? raw?.updated_at ?? raw?.lastActivityAt ?? null,
    contact: raw?.contact ?? null,
  };
}

// Utility: ensure array + filter usable cards
function normalizeCards(list: any[]): any[] {
  return (Array.isArray(list) ? list : []).map(shapeCard).filter(c => c.id && CANON.includes(c.status));
}

// Dev-only seed so UI stays testable when the repo is empty.
function maybeSeedDev(): any[] {
  if (String(process.env.PIPELINE_DEV_SEED||'').trim() !== '1') return [];
  const now = new Date().toISOString();
  return [
    { id:'dev-a1', businessName:'Acme Tools',   amount: 50000, status:'new',          createdAt: now },
    { id:'dev-b2', businessName:'North Bikes',  amount:120000, status:'requiresdocs', createdAt: now },
    { id:'dev-c3', businessName:'Pine Dental',  amount: 80000, status:'inreview',     createdAt: now },
    { id:'dev-d4', businessName:'Coast Foods',  amount: 95000, status:'withlender',   createdAt: now },
    { id:'dev-e5', businessName:'Zen Wellness', amount: 70000, status:'accepted',     createdAt: now },
    { id:'dev-f6', businessName:'Orbit Media',  amount: 45000, status:'declined',     createdAt: now },
  ].map(shapeCard);
}

// simple health
pipeline.get('/test', (_req, res) => res.json({ ok: true, message: 'pipeline working' }));

// quiet the console by stubbing metrics (UI treats as optional)
pipeline.get('/metrics', (_req, res) => {
  res.json({ ok:true, totals: { new:0, requiresdocs:0, inreview:0, withlender:0, accepted:0, declined:0 }});
});

pipeline.get('/board', async (_req, res) => {
  // Return canonical "lanes" (keep compatibility with legacy 'stages' if needed)
  const lanes = [
    { id: 'new',          name: 'New' },
    { id: 'requiresdocs', name: 'Requires Docs' },
    { id: 'inreview',     name: 'In Review' },
    { id: 'withlender',   name: 'With Lender' },
    { id: 'accepted',     name: 'Accepted' },
    { id: 'declined',     name: 'Declined' }
  ];
  res.setHeader('X-Diag-Handler', 'pipeline.board');
  res.json({ ok: true, lanes, totals: 0 });
});

pipeline.get('/cards', async (req, res) => {
  try {
    const seed = (req.query.seed ?? process.env.PIPELINE_DEV_SEED) ? true : false;
    const limit = Number(req.query.limit || 200);
    let cards: any[] = [];
    
    if (seed) {
      cards = [
        { id:'a1', businessName:'RU Sinews Inc',      status:'new',          amount:50000 },
        { id:'a2', businessName:'Boreal Automation',  status:'requiresdocs', amount:120000 },
        { id:'a3', businessName:'Black Label Elect.', status:'inreview',     amount:250000 },
        { id:'a4', businessName:'Westshore Metals',   status:'withlender',   amount:90000  },
        { id:'a5', businessName:'North Peak Foods',   status:'accepted',     amount:300000 },
        { id:'a6', businessName:'Harbor Retail',      status:'declined',     amount:45000  },
      ];
    } else {
      // Demo cards for immediate testing
      const demoCards = [
        { id: 'a1', businessName: 'RU Sinews Inc',        amount: 50000,  status: 'new' },
        { id: 'b2', businessName: 'Boreal Business Name', amount: 120000, status: 'requiresdocs' },
        { id: 'c3', businessName: 'Maple Automation',     amount: 76000,  status: 'inreview' },
      ];
      
      const source =
        (res.locals?.pipelineCards) ||
        (req.app?.locals?.pipelineCards) ||
        demoCards;
      cards = normalizeCards(source).slice(0, limit);

      // If still empty, try a fallback from recent applications (common in your codebase):
      if (cards.length === 0 && Array.isArray(req.app?.locals?.applications)) {
        const fallback = normalizeCards(req.app.locals.applications).slice(0, limit);
        if (fallback.length) cards = fallback;
      }

      // If still empty and dev seed enabled, provide seed so UI proves wiring.
      if (cards.length === 0) {
        const dev = maybeSeedDev().slice(0, limit);
        if (dev.length) cards = dev;
      }
    }
    
    res.setHeader('X-Diag-Handler', 'pipeline.cards');
    return res.json({ ok: true, cards, __diag: { note: cards.length ? 'ok' : 'empty' }});
  } catch (e:any) {
    res.status(500).json({ ok:false, error: String(e?.message||e) });
  }
});

pipeline.get('/cards/:id', async (req, res) => {
  const { id } = req.params;
  
  // Demo cards for lookup
  const demoCards = [
    { id: 'a1', businessName: 'RU Sinews Inc',        amount: 50000,  status: 'new' },
    { id: 'b2', businessName: 'Boreal Business Name', amount: 120000, status: 'requiresdocs' },
    { id: 'c3', businessName: 'Maple Automation',     amount: 76000,  status: 'inreview' },
  ];
  
  // Lookup in any of the loaded sources; shape to contract
  const sources: any[] = [
    res.locals?.pipelineCards,
    req.app?.locals?.pipelineCards,
    req.app?.locals?.applications,
    demoCards
  ].filter(Array.isArray) as any[];

  for (const src of sources) {
    const found = (src || []).find((r:any) => toId(r?.id ?? r?._id ?? r?.applicationId) === id);
    if (found) {
      const shaped = shapeCard(found);
      return res.json({ ok: true, ...shaped, timeline: found.timeline ?? [], ocrConflicts: found.ocrConflicts ?? [], lenderRecs: found.lenderRecs ?? [] });
    }
  }
  return res.status(404).json({ ok:false, error: 'Card not found', id });
});