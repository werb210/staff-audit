server/boot.ts:71:  // Mount PUBLIC APPLICATIONS router (for client integration)
server/boot.ts:73:    const publicApplications = (await import("./routes/public-applications")).default;
server/boot.ts:74:    app.use("/api/public", publicApplications);
server/boot.ts:241:    const { applicationsValidateRouter } = await import("./routes/applications.validate.js");
server/boot.ts:244:    app.use("/api/applications/validate-intake", requireSharedToken, applicationsValidateRouter());
server/boot.ts:250:  // DISABLED: Legacy application validation (replaced by production validator)
server/boot.ts:254:  //   console.log("‚úÖ Legacy application validation routes mounted under /api");
server/boot.ts:256:  //   console.log("‚ùå Legacy application validation failed:", e.message);
server/boot.ts:263:    console.log("‚ùå Application submit failed:", e.message);
server/boot.ts:266:  // Mount simple application creation for E2E testing (public endpoint)
server/boot.ts:268:    const simpleAppCreate = (await import("./routes/simple-application-create.ts")).default;
server/boot.ts:271:    console.log("‚ùå Simple application creation router failed:", e.message);
server/boot.ts:274:  // Mount V1 Applications Documents API (AUTHORITATIVE ENDPOINT)
server/boot.ts:276:    const v1AppDocs = (await import("./routes/v1-applications-docs.ts")).default;
server/boot.ts:279:    console.log("‚ùå V1 Applications Documents API failed:", e.message);
server/boot.ts:320:    const { applicationsValidateRouter } = await import("./routes/applications.validate.js");
server/boot.ts:322:    // Back-compat alias: /api/v1/applications/validate-intake (with shared token)  
server/boot.ts:323:    app.use("/api/v1/applications/validate-intake", requireSharedToken, applicationsValidateRouter());
server/boot.ts:330:  // REMOVED: Simple documents router (LEGACY) - Use V1 Applications Documents API instead
server/boot.ts:342:    const alignedApiRoutes = (await import("./routes/api-applications-aligned.ts")).default;
server/boot.ts:350:    const alignedApiRoutesPublic = (await import("./routes/api-applications-aligned.ts")).default;
server/boot.ts:356:  // Mount public applications router under /api/public for client compatibility
server/boot.ts:358:    const publicApplications = (await import("./routes/public-applications.ts")).default;
server/boot.ts:359:    app.use("/api/public", publicApplications);
server/boot.ts:361:    console.log("‚ùå Client-expected public applications router failed:", e.message);
server/boot.ts:370:  // Mount applications router BEFORE auth middleware for public access
server/boot.ts:372:    const { applicationsRouter } = await import("./routes/applications.ts");
server/boot.ts:373:    app.use("/api/applications", applicationsRouter);
server/boot.ts:375:    console.log("‚ùå Applications router failed:", e.message);
server/boot.ts:412:        fullPath.includes('/api/applications/validate-intake') ||
server/boot.ts:465:  // Core API endpoints for cards
server/boot.ts:485:    const applicationsRouter = (await import("./routes/applications-minimal.ts")).default;
server/boot.ts:486:    app.use("/api", applicationsRouter);
server/boot.ts:487:  } catch (e) { console.log("applications-minimal.ts not found"); }
server/boot.ts:523:    const applicationDetailRouter = (await import("./routes/application-detail.mjs")).default;
server/boot.ts:524:    app.use("/api", applicationDetailRouter);
server/boot.ts:525:  } catch (e) { console.log("application-detail.mjs not found"); }
server/boot.ts:560:    const pipelineRouter = (await import("./routes/pipeline.ts")).default;
server/boot.ts:561:    app.use("/api/pipeline", pipelineRouter);
server/boot.ts:562:    console.log("‚úÖ Pipeline router mounted at /api/pipeline");
server/boot.ts:564:    console.log("‚ùå Pipeline router failed:", e.message); 
server/boot.ts:611:      return res.status(500).send("Application build not found");
server/index.ts:33:// Import and apply the rest of the application setup (includes auth setup)
server/controllers/lenderProductsController.ts:6:    const { applicationId } = req.query;
server/controllers/lenderProductsController.ts:8:    // If applicationId provided, check document approval status
server/controllers/lenderProductsController.ts:9:    if (applicationId) {
server/controllers/lenderProductsController.ts:10:      console.log(`üîç [LENDER-CTRL] Checking document approval for application ${applicationId}`);
server/controllers/lenderProductsController.ts:14:      if (!uuidRegex.test(applicationId.toString())) {
server/controllers/lenderProductsController.ts:17:          error: "Invalid application ID format" 
server/controllers/lenderProductsController.ts:25:        FROM applications a
server/controllers/lenderProductsController.ts:26:        LEFT JOIN documents d ON a.id = d.application_id
server/controllers/lenderProductsController.ts:29:      `, [applicationId]);
server/controllers/lenderProductsController.ts:32:        return res.status(404).json({ ok: false, error: "Application not found" });
server/controllers/lenderProductsController.ts:41:        console.log(`üö´ [LENDER-CTRL] No documents uploaded for application ${applicationId}`);
server/controllers/lenderProductsController.ts:45:          details: "No documents have been uploaded for this application"
server/controllers/lenderProductsController.ts:58:      console.log(`‚úÖ [LENDER-CTRL] All ${app.accepted_docs} documents approved for application ${applicationId}`);
server/controllers/lenderProductsController.ts:100:    console.log(`üì¶ [LENDER-CTRL] Returning ${products.length} lender products${applicationId ? ` for application ${applicationId}` : ''}`);
server/controllers/lenderProductsController.ts:107:        applicationId: applicationId || null,
server/controllers/lenderProductsController.ts:108:        documentsVerified: !!applicationId
server/settings/store.ts:14:  pipelineDnD: true,
server/monitoring-dashboard.js:6: * Real-time monitoring dashboard for incoming application submissions
server/monitoring-dashboard.js:7: * Tracks: Applications ‚Üí Documents ‚Üí PDFs ‚Üí Sales Pipeline
server/monitoring-dashboard.js:22:‚ïë  ‚û§ Applications Received: POST /api/applications                             ‚ïë
server/monitoring-dashboard.js:23:‚ïë  ‚û§ Documents Uploaded: POST /api/applications/:id/documents                  ‚ïë  
server/monitoring-dashboard.js:24:‚ïë  ‚û§ Final PDF Generated: signed_application tag                               ‚ïë
server/monitoring-dashboard.js:25:‚ïë  ‚û§ Sales Pipeline Entry: New Application stage                              ‚ïë
server/monitoring-dashboard.js:31:${GREEN}‚úÖ [MONITOR] Application received${RESET}
server/monitoring-dashboard.js:32:  ‚Üí New application submitted
server/monitoring-dashboard.js:33:  ‚Üí Endpoint: POST /api/applications
server/monitoring-dashboard.js:38:  ‚Üí Endpoint: POST /api/applications/:id/documents
server/monitoring-dashboard.js:46:${GREEN}‚úÖ [MONITOR] Final PDF uploaded - signed_application${RESET}
server/monitoring-dashboard.js:48:  ‚Üí File tagged as 'signed_application'
server/monitoring-dashboard.js:49:  ‚Üí Ready for Sales Pipeline
server/monitoring-dashboard.js:51:${BLUE}Pipeline Integration Check:${RESET}
server/monitoring-dashboard.js:52:  ‚Üí Visit /staff/pipeline in your app
server/monitoring-dashboard.js:53:  ‚Üí Look for new card in "New Application" column
server/monitoring-dashboard.js:59:  ‚ùå "Application not found" errors
server/monitoring-dashboard.js:64:1. Submit a test application through your public form
server/monitoring-dashboard.js:66:3. Generate final signed application PDF
server/monitoring-dashboard.js:67:4. Verify new card appears in Sales Pipeline
server/monitoring-dashboard.js:70:‚úÖ SUCCESS - All logs appear, card in pipeline
server/settings/types.ts:14:  pipelineDnD: boolean;
server/_diag.routes.ts:44:      r.path.includes("/applications") ||
server/pipeline/store.ts:1:import { Application, AppDoc, Note, Audit, Stage } from "./types";
server/pipeline/store.ts:4:export const apps: Record<string, Application> = {
server/pipeline/store.ts:25:  const lanes = Object.fromEntries(stages.map(s => [s, [] as Application[]]));
server/pipeline/store.ts:27:  return lanes as Record<Stage, Application[]>;
server/communications-service.ts:33:  applicationId?: string;
server/communications-service.ts:48:  applicationId?: string;
server/communications-service.ts:64:  applicationId?: string;
server/communications-service.ts:79:  applicationId?: string;
server/communications-service.ts:134:          contact_id, application_id, category, priority, tags
server/communications-service.ts:150:        emailData.applicationId,
server/communications-service.ts:223:        applicationId: row.application_id,
server/communications-service.ts:250:          contact_id, application_id, is_automated, automation_type
server/communications-service.ts:260:        smsData.applicationId,
server/communications-service.ts:286:    applicationId?: string;
server/communications-service.ts:289:      const { limit = 50, offset = 0, direction, applicationId } = options;
server/communications-service.ts:301:      if (applicationId) {
server/communications-service.ts:302:        query += ` AND application_id = $${paramIndex}`;
server/communications-service.ts:303:        params.push(applicationId);
server/communications-service.ts:321:        applicationId: row.application_id,
server/communications-service.ts:348:          contact_id, application_id, user_id, call_purpose
server/communications-service.ts:357:        callData.applicationId,
server/communications-service.ts:383:    applicationId?: string;
server/communications-service.ts:387:      const { limit = 50, offset = 0, direction, applicationId, userId } = options;
server/communications-service.ts:399:      if (applicationId) {
server/communications-service.ts:400:        query += ` AND application_id = $${paramIndex}`;
server/communications-service.ts:401:        params.push(applicationId);
server/communications-service.ts:426:        applicationId: row.application_id,
server/communications-service.ts:448:    applicationId?: string;
server/communications-service.ts:465:          phone_number, code, purpose, user_id, application_id,
server/communications-service.ts:475:        otpData.applicationId,
server/pipeline/types.ts:15:export type Application = {
server/scripts/backfillCanonical.ts:9:    FROM applications 
server/scripts/backfillCanonical.ts:13:  console.log(`Found ${rows.length} applications to backfill`);
server/scripts/backfillCanonical.ts:20:        UPDATE applications SET 
server/scripts/backfillCanonical.ts:44:  console.log(`üéâ Backfilled ${rows.length} applications`);
server/openapi-spec.ts:10:    description: "Comprehensive API for managing lender products, applications, and document workflows",
server/openapi-spec.ts:57:              "application/json": {
server/openapi-spec.ts:74:            "application/json": {
server/openapi-spec.ts:83:              "application/json": {
server/openapi-spec.ts:110:              "application/json": {
server/openapi-spec.ts:134:            "application/json": {
server/openapi-spec.ts:143:              "application/json": {
server/openapi-spec.ts:177:        description: "Public endpoint for client applications to retrieve lender products",
server/openapi-spec.ts:183:              "application/json": {
server/openapi-spec.ts:195:    "/api/applications": {
server/openapi-spec.ts:197:        summary: "Get all applications",
server/openapi-spec.ts:198:        description: "Retrieve applications for sales pipeline",
server/openapi-spec.ts:199:        tags: ["Applications"],
server/openapi-spec.ts:202:            description: "List of applications",
server/openapi-spec.ts:204:              "application/json": {
server/openapi-spec.ts:207:                  items: { $ref: "#/components/schemas/Application" }
server/openapi-spec.ts:215:    "/api/applications/draft": {
server/openapi-spec.ts:217:        summary: "Create draft application",
server/openapi-spec.ts:218:        description: "Create a new application in draft status",
server/openapi-spec.ts:219:        tags: ["Applications"],
server/openapi-spec.ts:223:            "application/json": {
server/openapi-spec.ts:224:              schema: { $ref: "#/components/schemas/CreateApplicationRequest" }
server/openapi-spec.ts:230:            description: "Draft application created",
server/openapi-spec.ts:232:              "application/json": {
server/openapi-spec.ts:233:                schema: { $ref: "#/components/schemas/Application" }
server/openapi-spec.ts:328:      Application: {
server/openapi-spec.ts:341:      CreateApplicationRequest: {
server/openapi-spec.ts:370:      description: "Public endpoints with CORS support for client applications"
server/openapi-spec.ts:373:      name: "Applications",
server/openapi-spec.ts:374:      description: "Application management and sales pipeline operations"
server/scripts/check-schema-integrity.ts:11:  applications: {
server/scripts/check-schema-integrity.ts:44:async function getApplicationsCount(): Promise<number> {
server/scripts/check-schema-integrity.ts:46:    const result = await db.execute('SELECT COUNT(*) as count FROM applications');
server/scripts/check-schema-integrity.ts:49:    console.warn('Warning: Could not count applications:', error);
server/scripts/check-schema-integrity.ts:73:  const [lenderProductsColumns, applicationsColumns, lenderProductsCount, applicationsCount, sampleProduct] = await Promise.all([
server/scripts/check-schema-integrity.ts:75:    getTableColumns('applications'),
server/scripts/check-schema-integrity.ts:77:    getApplicationsCount(),
server/scripts/check-schema-integrity.ts:87:    applications: {
server/scripts/check-schema-integrity.ts:88:      count: applicationsCount,
server/scripts/check-schema-integrity.ts:89:      columns: applicationsColumns
server/scripts/check-schema-integrity.ts:140:      console.log(`üìä Applications: ${snapshot.applications.count}`);
server/ocrService.ts:61:  applicationId: string,
server/ocrService.ts:124:        document_id, application_id, extracted_data, confidence, 
server/ocrService.ts:127:      RETURNING id, document_id, application_id, processing_status
server/ocrService.ts:136:      applicationId,
server/ocrService.ts:153:        // Use direct SQL with postgres client for application check
server/ocrService.ts:156:        const applicationResult = await appClient.query('SELECT legal_business_name FROM applications WHERE id = $1', [applicationId]);
server/ocrService.ts:158:        const application = applicationResult.rows[0];
server/ocrService.ts:159:        if (application && application.legal_business_name?.toLowerCase().includes('test')) {
server/ocrService.ts:160:          console.log(`üö´ [AUTO] Skipping banking analysis for test application: ${application.legal_business_name}`);
server/ocrService.ts:162:          console.log(`ü§ñ [AUTO] Banking analysis triggered for app ${applicationId}`);
server/ocrService.ts:171:              applicationId,
server/ocrService.ts:230:        document_id, application_id, extracted_data, confidence, 
server/ocrService.ts:238:      applicationId,
server/ocrService.ts:481:    case '.pdf': return 'application/pdf';
server/ocrService.ts:482:    default: return 'application/octet-stream';
server/ocrService.ts:494:export async function getOcrResultsByApplication(applicationId: string) {
server/ocrService.ts:497:  const result = await client.query('SELECT * FROM ocr_results WHERE application_id = $1 ORDER BY processed_at DESC', [applicationId]);
server/ocrService.ts:505:  applicationId: string,
server/ocrService.ts:693:          document_id, application_id, extracted_data, confidence, 
server/ocrService.ts:696:        RETURNING id, document_id, application_id, processing_status
server/ocrService.ts:705:        applicationId,
server/ocrService.ts:788:        document_id, application_id, extracted_data, confidence, 
server/ocrService.ts:791:      RETURNING id, document_id, application_id, processing_status
server/ocrService.ts:800:      applicationId,
server/ocrService.ts:828:        document_id, application_id, extracted_data, confidence, 
server/ocrService.ts:841:      applicationId,
server/fraud-detection-service.ts:133:   * Cross-application fraud analysis
server/fraud-detection-service.ts:135:  async analyzeApplication(applicationId: string): Promise<any> {
server/fraud-detection-service.ts:139:      // Get all documents for the application - Using parameterized query to prevent SQL injection
server/fraud-detection-service.ts:140:      // Validate applicationId to prevent SQL injection
server/fraud-detection-service.ts:141:      if (typeof applicationId !== 'string' || applicationId.trim() === '') {
server/fraud-detection-service.ts:142:        throw new Error('Invalid application ID');
server/fraud-detection-service.ts:149:      if (!uuidRegex.test(applicationId) && !numericRegex.test(applicationId)) {
server/fraud-detection-service.ts:150:        throw new Error('Invalid application ID format');
server/fraud-detection-service.ts:154:        SELECT id FROM documents WHERE application_id = ${sql.placeholder('applicationId')}
server/fraud-detection-service.ts:155:      `, { applicationId: applicationId });
server/fraud-detection-service.ts:158:      console.log(`üîç Running cross-application fraud analysis for ${applicationId} with ${documents.length} documents`);
server/fraud-detection-service.ts:178:      // Calculate overall application fraud score
server/fraud-detection-service.ts:188:        applicationId,
server/fraud-detection-service.ts:199:      // Save application-level fraud result
server/fraud-detection-service.ts:200:      await this.saveApplicationFraudResult(result);
server/fraud-detection-service.ts:202:      console.log(`‚úÖ Application ${applicationId} fraud analysis completed: ${overallFraudScore}/100 score, ${riskLevel} risk level`);
server/fraud-detection-service.ts:206:      console.error(`Error analyzing application ${applicationId}:`, error);
server/fraud-detection-service.ts:333:   * Save application fraud result
server/fraud-detection-service.ts:335:  private async saveApplicationFraudResult(result: any): Promise<void> {
server/fraud-detection-service.ts:339:          application_id, overall_fraud_score, risk_level, similar_documents,
server/fraud-detection-service.ts:343:          ${sql.placeholder('applicationId')}, 
server/fraud-detection-service.ts:353:        applicationId: String(result.applicationId),
server/fraud-detection-service.ts:362:      console.log(`‚úÖ Saved fraud detection result for application ${result.applicationId}`);
server/fraud-detection-service.ts:364:      console.error('Error saving application fraud result:', error);
server/fraud-detection-service.ts:397:   * Get flagged applications
server/fraud-detection-service.ts:399:  async getFlaggedApplications(): Promise<any[]> {
server/fraud-detection-service.ts:410:      console.error('Error getting flagged applications:', error);
server/scripts/generate-api-token.ts:31:  const tokenKey = `PIPELINE_TOKEN`;
server/scripts/generate-api-token.ts:69:1. Copy this token to your client application's environment variables
server/spa/earlyStatic.ts:27:      res.setHeader('Content-Type', 'application/javascript; charset=utf-8');
server/spa/earlyStatic.ts:28:      console.log(`üìÅ [JS] Serving with application/javascript MIME type`);
server/schema-lock.json:59:  "applications": {
server/scripts/audit_all_drizzle.ts:12:    applications: await q`SELECT tenant_id, COUNT(*)::int cnt FROM "applications" GROUP BY tenant_id`,
server/scripts/audit_all_drizzle.ts:48:     (SELECT COUNT(*)::int FROM "applications" WHERE tenant_id IS NULL) AS apps
server/risk-engine.ts:4:import { applications, businesses, financialProfiles, riskAssessments } from "../shared/schema";
server/risk-engine.ts:25:  applicationId: string;
server/risk-engine.ts:338:Analyze this business loan application and provide specific risk mitigation recommendations:
server/risk-engine.ts:422:    applicationId: string,
server/risk-engine.ts:433:          applicationId,
server/risk-engine.ts:468:  async getRiskAssessment(applicationId: string) {
server/risk-engine.ts:473:        .where(eq(riskAssessments.applicationId, applicationId))
server/spa/cacheBust.ts:18:  console.log(`[spa] buildId=${BUILD_ID} ‚Ä¢ prefix=${PREFIX} ‚Ä¢ wildcard /assets-* enabled`);
server/health-monitor.ts:3: * Monitors application health and performance
server/storage.ts:5:  applications,
server/storage.ts:13:  type Application,
server/storage.ts:14:  type InsertApplication,
server/storage.ts:36:  // Application operations
server/storage.ts:37:  getApplicationsByTenant(tenantId: string): Promise<Application[]>;
server/storage.ts:38:  getApplicationsByUser(userId: string, tenantId: string): Promise<Application[]>;
server/storage.ts:39:  getApplication(id: string, tenantId: string): Promise<Application | undefined>;
server/storage.ts:40:  createApplication(application: InsertApplication): Promise<Application>;
server/storage.ts:41:  updateApplication(id: string, application: Partial<InsertApplication>): Promise<Application | undefined>;
server/storage.ts:44:  getDocumentsByApplication(applicationId: string): Promise<Document[]>;
server/storage.ts:112:  // Application operations with tenant isolation
server/storage.ts:113:  async getApplicationsByTenant(tenantId: string): Promise<Application[]> {
server/storage.ts:116:      .from(applications)
server/storage.ts:117:      .where(eq(applications.tenantId, tenantId));
server/storage.ts:120:  async getApplicationsByUser(userId: string, tenantId: string): Promise<Application[]> {
server/storage.ts:123:      .from(applications)
server/storage.ts:124:      .where(and(eq(applications.userId, userId), eq(applications.tenantId, tenantId)));
server/storage.ts:127:  async getApplication(id: string, tenantId: string): Promise<Application | undefined> {
server/storage.ts:128:    const [application] = await db
server/storage.ts:130:      .from(applications)
server/storage.ts:131:      .where(and(eq(applications.id, id), eq(applications.tenantId, tenantId)));
server/storage.ts:132:    return application;
server/storage.ts:135:  async createApplication(applicationData: InsertApplication): Promise<Application> {
server/storage.ts:136:    const [application] = await db.insert(applications).values(applicationData).returning();
server/storage.ts:137:    return application;
server/storage.ts:140:  async updateApplication(id: string, applicationData: Partial<InsertApplication>): Promise<Application | undefined> {
server/storage.ts:141:    const [application] = await db
server/storage.ts:142:      .update(applications)
server/storage.ts:143:      .set({ ...applicationData, updatedAt: new Date() })
server/storage.ts:144:      .where(eq(applications.id, id))
server/storage.ts:146:    return application;
server/storage.ts:150:  async getDocumentsByApplication(applicationId: string): Promise<Document[]> {
server/storage.ts:154:      .where(eq(documents.applicationId, applicationId));
server/scripts/phase2Backfill.ts:10: * 4. Create placeholders for missing documents from Application #893777fb
server/scripts/phase2Backfill.ts:21:const APPLICATION_ID = '893777fb-0830-4233-8768-0d1044ff8275';
server/scripts/phase2Backfill.ts:230:- Application ID: ${APPLICATION_ID}
server/scripts/phase2Backfill.ts:245:1. Contact client at the email address associated with this application
server/infra/routes.ts:10:  pipeline: "/api/pipeline",
server/infra/routes.ts:24:  applications: "/api/applications",
server/scripts/sql-guardrails.sql:25:-- 3. APPLICATIONS Table Guardrails
server/scripts/sql-guardrails.sql:27:CREATE UNIQUE INDEX CONCURRENTLY IF NOT EXISTS idx_applications_tenant_business_unique 
server/scripts/sql-guardrails.sql:28:ON applications (tenant_id, LOWER(business_name)) 
server/scripts/sql-guardrails.sql:32:CREATE UNIQUE INDEX CONCURRENTLY IF NOT EXISTS idx_applications_tenant_email_unique 
server/scripts/sql-guardrails.sql:33:ON applications (tenant_id, LOWER(business_email)) 
server/scripts/sql-guardrails.sql:37:CREATE UNIQUE INDEX CONCURRENTLY IF NOT EXISTS idx_applications_ssn_unique 
server/scripts/sql-guardrails.sql:38:ON applications (owner_ssn) 
server/scripts/sql-guardrails.sql:76:ALTER TABLE applications ADD CONSTRAINT IF NOT EXISTS chk_applications_email_format 
server/scripts/sql-guardrails.sql:164:ANALYZE applications;
server/scripts/sql-guardrails.sql:173:COMMENT ON INDEX idx_applications_tenant_business_unique IS 'DupCheck Pack: Prevents duplicate business names per tenant';
server/websocket.ts:5:let notifyPipelineUpdate: () => void;
server/websocket.ts:56:    socket.join("applications");
server/websocket.ts:57:    socket.join("pipeline");
server/websocket.ts:103:  notifyPipelineUpdate = () => {
server/websocket.ts:104:    console.log("[WebSocket] Broadcasting pipeline update");
server/websocket.ts:105:    io.to("pipeline").emit("pipeline:update");
server/websocket.ts:109:  return { io, notifyPipelineUpdate };
server/websocket.ts:113:export { notifyPipelineUpdate };
server/websocket.ts:135:export const broadcastPipelineUpdate = (applicationId: string, event: string = 'update') => {
server/websocket.ts:136:  console.log(`[WebSocket] Broadcasting pipeline update for app ${applicationId}`);
server/websocket.ts:137:  io?.to("pipeline").emit("pipeline:update", { applicationId, event });
server/websocket.ts:142:export const emitApplicationsUpdate = () => io?.to("applications").emit("applications:update");
server/websocket.ts:143:export const emitPipelineUpdate = () => io?.to("pipeline").emit("pipeline:update");
server/ads/google_write.ts:24:    headers: { "Content-Type": "application/x-www-form-urlencoded" },
server/ads/google_write.ts:47:      "Content-Type": "application/json"
server/ads/google_write.ts:99:      "Content-Type": "application/json" 
server/scripts/validate-namespaces.mjs:21:  '/api/applications', 
server/scripts/validate-namespaces.mjs:23:  '/api/pipeline',
server/ads/linkedin_write.ts:17:      "Content-Type": "application/json" 
server/ads/linkedin_write.ts:32:      "Content-Type": "application/json" 
server/bank-statement-analyzer.ts:2:import { applications } from "../shared/schema";
server/bank-statement-analyzer.ts:524:  async getBankingAnalysis(applicationId: string): Promise<BankingAnalysis | undefined> {
server/bank-statement-analyzer.ts:528:      .where(eq(bankingAnalysis.applicationId, applicationId));
server/monitoring/permanentMonitoring.sql:2:-- Surfaces applications with zero documents for immediate attention
server/monitoring/permanentMonitoring.sql:6:    applications.id as application_id,
server/monitoring/permanentMonitoring.sql:7:    applications.legal_business_name,
server/monitoring/permanentMonitoring.sql:8:    applications.contact_email,
server/monitoring/permanentMonitoring.sql:9:    applications.created_at,
server/monitoring/permanentMonitoring.sql:15:FROM applications
server/monitoring/permanentMonitoring.sql:16:LEFT JOIN documents ON documents.application_id = applications.id
server/monitoring/permanentMonitoring.sql:17:WHERE applications.created_at > NOW() - INTERVAL '24 hours'
server/monitoring/permanentMonitoring.sql:18:GROUP BY applications.id, applications.legal_business_name, applications.contact_email, applications.created_at
server/monitoring/permanentMonitoring.sql:20:ORDER BY applications.created_at DESC;
server/security/productionLogging.ts:19:          .replace(/\b\d{4}-\d{4}-\d{4}-\d{4}\b/g, '[CARD-REDACTED]')
server/startup/selfHealingAudit.ts:4:import { documents, applications } from '../../shared/schema.js';
server/startup/selfHealingAudit.ts:57:        console.log(`   - Missing file: ${missingDoc.fileName} (${missingDoc.id}) - Application: ${missingDoc.applicationId}`);
server/startup/selfHealingAudit.ts:67:      // Option: Auto-create recovery application for orphaned files
server/ops/spaMount.js:21:        htmlAcceptHeaders: ["text/html", "application/xhtml+xml"],
server/routes/documentUpload.ts:5:import { documents, applications } from '../../shared/schema.js';
server/routes/documentUpload.ts:22:      'application/pdf',
server/routes/documentUpload.ts:26:      'application/msword',
server/routes/documentUpload.ts:27:      'application/vnd.openxmlformats-officedocument.wordprocessingml.document',
server/routes/documentUpload.ts:40: * POST /api/public/applications/:applicationId/documents
server/routes/documentUpload.ts:41: * Upload document for application with S3 storage
server/routes/documentUpload.ts:43:router.post('/public/applications/:applicationId/documents', upload.single('document'), async (req, res) => {
server/routes/documentUpload.ts:45:    console.log(`üîÑ [DOCUMENT UPLOAD] Starting upload for application ${req.params.applicationId}`);
server/routes/documentUpload.ts:47:    const { applicationId } = req.params;
server/routes/documentUpload.ts:68:    // Validate application exists - use raw SQL to avoid ORM issues
server/routes/documentUpload.ts:69:    const applicationResult = await db.execute(sql`
server/routes/documentUpload.ts:70:      SELECT id FROM applications WHERE id = ${applicationId} LIMIT 1
server/routes/documentUpload.ts:73:    const application = applicationResult.rows[0];
server/routes/documentUpload.ts:75:    if (!application) {
server/routes/documentUpload.ts:76:      console.error(`‚ùå [DOCUMENT UPLOAD] Application ${applicationId} not found`);
server/routes/documentUpload.ts:79:        message: "Application not found" 
server/routes/documentUpload.ts:83:    console.log(`‚úÖ [DOCUMENT UPLOAD] Application ${applicationId} validated`);
server/routes/documentUpload.ts:92:    const storageKey = await s3Storage.set(file.buffer, file.originalname, applicationId);
server/routes/documentUpload.ts:103:        application_id, 
server/routes/documentUpload.ts:112:        ${documentId}, ${applicationId}, ${file.originalname}, ${documentType}, ${storageKey}, ${sha256}, ${file.size}, ${file.mimetype}, NOW()
server/routes/documentUpload.ts:143: * GET /api/public/applications/:applicationId/documents
server/routes/documentUpload.ts:144: * List documents for application
server/routes/documentUpload.ts:146:router.get('/public/applications/:applicationId/documents', async (req, res) => {
server/routes/documentUpload.ts:148:    const { applicationId } = req.params;
server/routes/documentUpload.ts:150:    console.log(`üìã [DOCUMENT LIST] Fetching documents for application ${applicationId}`);
server/routes/documentUpload.ts:164:      WHERE application_id = '${applicationId}'
server/domain/pipeline.ts:1:export type PipelineStage =
server/domain/pipeline.ts:12:export interface ApplicationCard {
server/domain/pipeline.ts:18:  stage: PipelineStage;
server/domain/pipeline.ts:35:  from: PipelineStage;
server/domain/pipeline.ts:36:  to: PipelineStage;
server/routes/communicationCenter.ts:611:        name: 'Application Update',
server/routes/communicationCenter.ts:614:        body: 'Hi {{contactName}}, your application {{applicationId}} has been updated to {{status}}. {{additionalInfo}}'
server/routes/communicationCenter.ts:621:        body: 'Hi {{contactName}}, we need additional documents for your application. Please upload: {{documentList}}'
server/auth/verifyOnly.ts:61:    req.path.includes('/api/pipeline') ||
server/auth/verifyOnly.ts:62:    req.path.includes('/pipeline') || // Handle stripped paths
server/auth/verifyOnly.ts:124:    req.url.includes('/data/applications') ||
server/auth/verifyOnly.ts:125:    req.url.includes('/applications') ||
server/auth/verifyOnly.ts:132:    req.url.includes('/pipeline'); // Handle stripped pipeline paths
server/auth/verifyOnly.ts:145:  // Special case bypass for pipeline API paths
server/auth/verifyOnly.ts:146:  if (req.path.startsWith('/pipeline') || req.originalUrl.includes('/api/pipeline') || req.url.includes('/pipeline')) {
server/auth/verifyOnly.ts:147:    console.log(`üîì [PIPELINE-BYPASS] Pipeline API accessed: ${req.path} (original: ${req.originalUrl}, url: ${req.url})`);
server/auth/verifyOnly.ts:175:    console.log(`‚ùå [AUTH] No token provided for: ${req.path} (original: ${req.originalUrl}, url: ${req.url}) - Path check results: client=${req.path.includes('/client')}, pipeline=${req.path.includes('/pipeline')}`);
server/routes/documentAuditApi.ts:81:        application_id,
server/routes/documentAuditApi.ts:95:      applicationId: row.application_id,
server/routes/documentReliabilityPhase3.ts:30:  getApplicationHealthReport,
server/routes/documentReliabilityPhase3.ts:421:// Get health report for specific application
server/routes/documentReliabilityPhase3.ts:422:router.get('/health/application/:applicationId', async (req: any, res: any) => {
server/routes/documentReliabilityPhase3.ts:424:    const { applicationId } = req.params;
server/routes/documentReliabilityPhase3.ts:425:    console.log(`üè• [API] Generating health report for application: ${applicationId}`);
server/routes/documentReliabilityPhase3.ts:427:    const report = await getApplicationHealthReport(applicationId);
server/routes/documentReliabilityPhase3.ts:436:    console.error('‚ùå [API] Application health report error:', error);
server/routes/documentReliabilityPhase3.ts:439:      error: error instanceof Error ? error.message : 'Failed to generate application health report'
server/auth/routes.ts:178:    // stateless ‚Äî client will discard token
server/routes/documentUploadFixed.ts:21:      'application/pdf',
server/routes/documentUploadFixed.ts:25:      'application/msword',
server/routes/documentUploadFixed.ts:26:      'application/vnd.openxmlformats-officedocument.wordprocessingml.document',
server/routes/documentUploadFixed.ts:39: * POST /api/public/applications/:applicationId/documents
server/routes/documentUploadFixed.ts:40: * Upload document for application with S3 storage
server/routes/documentUploadFixed.ts:42:router.post('/public/applications/:applicationId/documents', upload.single('document'), async (req, res) => {
server/routes/documentUploadFixed.ts:44:    console.log(`üîÑ [DOCUMENT UPLOAD FIXED] Starting upload for application ${req.params.applicationId}`);
server/routes/documentUploadFixed.ts:46:    const { applicationId } = req.params;
server/routes/documentUploadFixed.ts:67:    // Validate application exists using parameterized query
server/routes/documentUploadFixed.ts:68:    const applicationCheck = await db.execute(sql`SELECT id FROM applications WHERE id = ${applicationId} LIMIT 1`);
server/routes/documentUploadFixed.ts:70:    if (!applicationCheck.rows || applicationCheck.rows.length === 0) {
server/routes/documentUploadFixed.ts:71:      console.error(`‚ùå [DOCUMENT UPLOAD FIXED] Application ${applicationId} not found`);
server/routes/documentUploadFixed.ts:74:        message: "Application not found" 
server/routes/documentUploadFixed.ts:78:    console.log(`‚úÖ [DOCUMENT UPLOAD FIXED] Application ${applicationId} validated`);
server/routes/documentUploadFixed.ts:87:    const storageKey = await s3Storage.set(file.buffer, file.originalname, applicationId);
server/routes/documentUploadFixed.ts:97:        application_id, 
server/routes/documentUploadFixed.ts:108:        ${applicationId},
server/routes/documentUploadFixed.ts:147: * GET /api/public/applications/:applicationId/documents
server/routes/documentUploadFixed.ts:148: * List documents for application
server/routes/documentUploadFixed.ts:150:router.get('/public/applications/:applicationId/documents', async (req, res) => {
server/routes/documentUploadFixed.ts:152:    const { applicationId } = req.params;
server/routes/documentUploadFixed.ts:154:    console.log(`üìã [DOCUMENT LIST FIXED] Fetching documents for application ${applicationId}`);
server/routes/documentUploadFixed.ts:168:      WHERE application_id = ${applicationId}
server/mw/auth.ts:8:  '/applications',   // Applications list/details (now working)
server/mw/auth.ts:14:  '/pipeline',       // Sales pipeline - REQUIRED for UI cards
server/mw/auth.ts:16:  '/contacts',       // Contacts - REQUIRED for UI cards
server/mw/auth.ts:21:  '/pipeline/',      // Pipeline endpoints
server/ms/graph.ts:37:      "Content-Type":"application/json"
server/mw/jwt-auth.ts:48:    /^\/api\/applications/i,            // Direct application endpoints
server/routes/applications.validate.ts:22:export function applicationsValidateRouter(): Router {
server/routes/applications.validate.ts:26:  r.get("/applications/validate-intake", (_req: Request, res: Response) => {
server/routes/applications.validate.ts:35:  r.post("/applications/validate-intake", async (req: Request, res: Response) => {
server/bootstrap/safe-server.cjs:31:    res.setHeader('Content-Type', 'application/json');
server/routes/app-validate.mjs:10: * POST /api/applications/validate-intake (with shared token auth)
server/routes/app-validate.mjs:15:r.post("/applications/validate-intake", requireSharedToken, async (req, res) => {
server/bootstrap/safe-server.js:31:    res.setHeader('Content-Type', 'application/json');
server/publicAppFix.ts:3:export function mountPublicApplicationRoutes(app: Express) {
server/publicAppFix.ts:4:  console.log("üìù [PUBLIC-FIX] Mounting public application routes...");
server/publicAppFix.ts:7:  app.post("/api/public/applications", async (req: any, res) => {
server/publicAppFix.ts:9:      console.log("üìù [PUBLIC-INTAKE] Route hit - received application submission");
server/publicAppFix.ts:17:      console.log("‚úÖ [PUBLIC-INTAKE] Creating application:", id, businessName);
server/publicAppFix.ts:22:        applicationId: id, 
server/publicAppFix.ts:25:        message: "Application submitted successfully" 
server/publicAppFix.ts:32:        message: error?.message ?? "Failed to process application" 
server/publicAppFix.ts:38:  app.post("/public/applications", async (req: any, res) => {
server/publicAppFix.ts:48:        applicationId: id, 
server/publicAppFix.ts:51:        message: "Application submitted successfully" 
server/publicAppFix.ts:58:  console.log("‚úÖ [PUBLIC-FIX] Public application routes mounted");
server/routes/api-applications-aligned.ts:3:// POST /api/applications - Create application  
server/routes/api-applications-aligned.ts:4:// GET /api/applications/:id - Get application
server/routes/api-applications-aligned.ts:5:// POST /api/applications/:id/documents/upload - Upload documents
server/routes/api-applications-aligned.ts:24:      'application/pdf',
server/routes/api-applications-aligned.ts:26:      'application/msword',
server/routes/api-applications-aligned.ts:27:      'application/vnd.openxmlformats-officedocument.wordprocessingml.document',
server/routes/api-applications-aligned.ts:48:// POST /api/applications - Create application
server/routes/api-applications-aligned.ts:49:router.post("/applications", async (req: Request, res: Response) => {
server/routes/api-applications-aligned.ts:52:    console.log("üìù [API-ALIGNED] Received application creation request");
server/routes/api-applications-aligned.ts:129:    // Create application using existing bf tenant
server/routes/api-applications-aligned.ts:134:      INSERT INTO applications (
server/routes/api-applications-aligned.ts:152:    const application = appResult.rows[0];
server/routes/api-applications-aligned.ts:154:    console.log(`‚úÖ [API-ALIGNED] Created application ${application.id} for ${finalData.business_name}`);
server/routes/api-applications-aligned.ts:158:      application: {
server/routes/api-applications-aligned.ts:159:        id: application.id,
server/routes/api-applications-aligned.ts:160:        status: application.status,
server/routes/api-applications-aligned.ts:161:        created_at: application.created_at
server/routes/api-applications-aligned.ts:166:    console.error("‚ùå [API-ALIGNED] Application creation error:", error);
server/routes/api-applications-aligned.ts:167:    res.status(500).json({ error: "Failed to create application" });
server/routes/api-applications-aligned.ts:173:// GET /api/applications/list - List applications (must come BEFORE /:id route)
server/routes/api-applications-aligned.ts:174:router.get("/applications/list", async (req: Request, res: Response) => {
server/routes/api-applications-aligned.ts:177:    console.log("üìã [API-ALIGNED] Fetching applications list");
server/routes/api-applications-aligned.ts:184:    // Fetch applications with pagination
server/routes/api-applications-aligned.ts:195:      FROM applications a
server/routes/api-applications-aligned.ts:201:    const countResult = await client.query('SELECT COUNT(*) FROM applications');
server/routes/api-applications-aligned.ts:204:    console.log(`‚úÖ [API-ALIGNED] Found ${result.rows.length} applications`);
server/routes/api-applications-aligned.ts:208:      applications: result.rows,
server/routes/api-applications-aligned.ts:218:    console.error("‚ùå [API-ALIGNED] Error fetching applications:", error);
server/routes/api-applications-aligned.ts:219:    res.status(500).json({ error: "Failed to fetch applications" });
server/routes/api-applications-aligned.ts:225:// GET /api/applications/health - Health check for aligned API
server/routes/api-applications-aligned.ts:226:router.get("/applications/health", async (req: Request, res: Response) => {
server/routes/api-applications-aligned.ts:234:      service: "api-applications-aligned"
server/routes/api-applications-aligned.ts:246:// GET /api/applications/:id - Get application
server/routes/api-applications-aligned.ts:247:router.get("/applications/:id", async (req: Request, res: Response) => {
server/routes/api-applications-aligned.ts:256:      return res.status(400).json({ error: "Invalid application ID format" });
server/routes/api-applications-aligned.ts:275:      FROM applications a
server/routes/api-applications-aligned.ts:281:      return res.status(404).json({ error: "Application not found" });
server/routes/api-applications-aligned.ts:288:      application: {
server/routes/api-applications-aligned.ts:308:    console.error("‚ùå [API-ALIGNED] Error fetching application:", error);
server/routes/api-applications-aligned.ts:309:    res.status(500).json({ error: "Failed to fetch application" });
server/routes/api-applications-aligned.ts:315:// POST /api/applications/:id/documents/upload - Upload documents
server/routes/api-applications-aligned.ts:316:router.post("/applications/:id/documents/upload", upload.single("file"), async (req: Request, res: Response) => {
server/routes/api-applications-aligned.ts:319:    console.log(`üîÑ [API-ALIGNED] Document upload for application ${req.params.id}`);
server/routes/api-applications-aligned.ts:321:    const { id: applicationId } = req.params;
server/routes/api-applications-aligned.ts:340:    // Validate application exists
server/routes/api-applications-aligned.ts:342:      SELECT id FROM applications WHERE id = $1
server/routes/api-applications-aligned.ts:343:    `, [applicationId]);
server/routes/api-applications-aligned.ts:348:        message: "Application not found" 
server/routes/api-applications-aligned.ts:352:    console.log(`‚úÖ [API-ALIGNED] Application ${applicationId} validated`);
server/routes/api-applications-aligned.ts:358:      const storageKey = await s3Storage.set(file.buffer, file.originalname, applicationId);
server/routes/api-applications-aligned.ts:371:        application_id, 
server/routes/api-applications-aligned.ts:385:      applicationId,
server/routes/api-applications-aligned.ts:395:    console.log(`‚úÖ [API-ALIGNED] Document uploaded: ${document.id} for application ${applicationId}`);
server/admin/coverage.ts:15:    { method: "GET",  path: "/api/pipeline",           selector: "[data-testid='btn-pipeline-load']" },
server/routes/staff-verification.ts:3:import { applications } from "../../shared/schema";
server/routes/staff-verification.ts:10: * Check applications table status after webhook completion
server/routes/staff-verification.ts:12:router.get("/db-status/:applicationId", async (req, res) => {
server/routes/staff-verification.ts:14:    const { applicationId } = req.params;
server/routes/staff-verification.ts:16:    console.log(`üîç [Staff Verification] Checking database status for application: ${applicationId}`);
server/routes/staff-verification.ts:18:    // Query application status from database
server/routes/staff-verification.ts:19:    const application = await db
server/routes/staff-verification.ts:21:        id: applications.id,
server/routes/staff-verification.ts:22:        status: applications.status, 
server/routes/staff-verification.ts:23:        signed: applications.signed,
server/routes/staff-verification.ts:24:        signingStatus: applications.signingStatus,
server/routes/staff-verification.ts:25:        signedAt: applications.signedAt,
server/routes/staff-verification.ts:27:      .from(applications)
server/routes/staff-verification.ts:28:      .where(eq(applications.id, applicationId))
server/routes/staff-verification.ts:31:    if (!application.length) {
server/routes/staff-verification.ts:33:        error: "Application not found",
server/routes/staff-verification.ts:34:        applicationId
server/routes/staff-verification.ts:38:    const app = application[0];
server/routes/staff-verification.ts:41:      applicationId: app.id,
server/routes/staff-verification.ts:53:      applicationId: app.id,
server/admin/coverageManifest.ts:26:  // Applications
server/admin/coverageManifest.ts:27:  { label: "Create Application", method: "POST", path: "/api/applications", uiPath: "/app/applications", selector: "[data-testid='btn-create-application']" },
server/admin/coverageManifest.ts:28:  { label: "Get Applications", method: "GET", path: "/api/applications", uiPath: "/app/applications", selector: "[data-testid='applications-list']" },
server/admin/coverageManifest.ts:36:  { label: "Lender Recommendations", method: "POST", path: "/api/lender-recommendations/recommend", uiPath: "/app/applications/:id", selector: "[data-testid='btn-get-recommendations']" },
server/boot.js.DISABLED:42:// ‚Ä¶repeat for contacts, applications, docs, etc, ONCE‚Ä¶
server/boot-clean.ts:28:  res.type("application/javascript").send(
server/objectStorage.ts:107:        "Content-Type": metadata.contentType || "application/octet-stream",
server/objectStorage.ts:285:        "Content-Type": "application/json",
server/routes/pipeline.ts:1:// server/routes/pipeline.ts
server/routes/pipeline.ts:10:console.log('üîß [PIPELINE] Main pipeline router loaded WITH AUTH');
server/routes/pipeline.ts:12:// Main pipeline endpoint
server/routes/pipeline.ts:15:    const { rows } = await pool.query(`SELECT * FROM applications ORDER BY updated_at DESC NULLS LAST, id DESC LIMIT 500`);
server/routes/pipeline.ts:24:    console.log(`‚úÖ [PIPELINE-API] Returning ${rows.length} applications across ${Object.keys(lanes).length} stages`);
server/routes/pipeline.ts:27:    console.error("‚ùå [PIPELINE-API] Error fetching pipeline:", e);
server/routes/pipeline.ts:32:// Cards endpoint for compatibility
server/routes/pipeline.ts:33:r.get("/cards", async (_req, res) => {
server/routes/pipeline.ts:35:    const { rows } = await pool.query(`SELECT * FROM applications ORDER BY updated_at DESC NULLS LAST, id DESC LIMIT 500`);
server/routes/pipeline.ts:36:    console.log(`‚úÖ [PIPELINE-API] Cards endpoint returning ${rows.length} applications`);
server/routes/pipeline.ts:39:    console.error("‚ùå [PIPELINE-API] Error fetching cards:", e);
server/routes/pipeline.ts:40:    res.status(500).json({ ok: false, error: "Failed to fetch pipeline cards" });
server/routes/pipeline.ts:44:// Delete application endpoint
server/routes/pipeline.ts:45:// Application details endpoint for drawer
server/routes/pipeline.ts:46:r.get("/cards/:id/application", async (req, res) => {
server/routes/pipeline.ts:49:    console.log(`üöÄ [PIPELINE-FIXED] Route working! ID: ${id}`);
server/routes/pipeline.ts:53:      SELECT * FROM applications WHERE id = $1::uuid LIMIT 1
server/routes/pipeline.ts:57:      console.log(`‚ùå [PIPELINE-FIXED] No application found for: ${id}`);
server/routes/pipeline.ts:58:      return res.status(404).json({ error: "Application not found" });
server/routes/pipeline.ts:62:    console.log(`‚úÖ [PIPELINE-FIXED] Found application: ${app.business_name} (${app.id})`);
server/routes/pipeline.ts:64:    console.log(`üè¢ [PIPELINE-FIXED] Processing application details: ${id} -> ${app.id}`);
server/routes/pipeline.ts:66:    // Complete application mapping - ALL 62 fields from database
server/routes/pipeline.ts:165:      SELECT COUNT(*) as count FROM documents WHERE application_id = $1
server/routes/pipeline.ts:169:    console.log(`‚úÖ [PIPELINE-API] Application details for ${payload.businessName || 'Unknown Business'}: ${id} (${actualDocumentCount} documents)`);
server/routes/pipeline.ts:170:    console.log(`üìã [PIPELINE-API] Mapped ${Object.keys(payload).length} application fields (ALL database fields included)`);
server/routes/pipeline.ts:174:      application: payload, 
server/routes/pipeline.ts:180:    console.error("‚ùå [PIPELINE-API] Error fetching application details:", e);
server/routes/pipeline.ts:181:    res.status(500).json({ error: "Failed to fetch application details", detail: e.message });
server/routes/pipeline.ts:185:r.delete("/cards/:id", async (req, res) => {
server/routes/pipeline.ts:188:    console.log(`üóëÔ∏è [PIPELINE-API] Deleting application: ${id}`);
server/routes/pipeline.ts:190:    // First check if application exists
server/routes/pipeline.ts:191:    const { rows: existing } = await pool.query(`SELECT id, business_name FROM applications WHERE id = $1`, [id]);
server/routes/pipeline.ts:193:      return res.status(404).json({ ok: false, error: "Application not found" });
server/routes/pipeline.ts:196:    const appName = existing[0].business_name || `Application ${id}`;
server/routes/pipeline.ts:199:    await pool.query(`DELETE FROM documents WHERE application_id = $1`, [id]);
server/routes/pipeline.ts:200:    await pool.query(`DELETE FROM ocr_results WHERE document_id IN (SELECT id FROM documents WHERE application_id = $1)`, [id]);
server/routes/pipeline.ts:202:    // Delete the application
server/routes/pipeline.ts:203:    const { rowCount } = await pool.query(`DELETE FROM applications WHERE id = $1`, [id]);
server/routes/pipeline.ts:206:      return res.status(404).json({ ok: false, error: "Application not found" });
server/routes/pipeline.ts:209:    console.log(`‚úÖ [PIPELINE-API] Successfully deleted application: ${appName} (${id})`);
server/routes/pipeline.ts:210:    res.json({ ok: true, message: `Application "${appName}" deleted successfully` });
server/routes/pipeline.ts:212:    console.error("‚ùå [PIPELINE-API] Error deleting application:", e);
server/routes/pipeline.ts:213:    res.status(500).json({ ok: false, error: "Failed to delete application", detail: e.message });
server/routes/pipeline.ts:217:// Documents endpoint for pipeline cards
server/routes/pipeline.ts:218:r.get("/cards/:id/documents", async (req, res) => {
server/routes/pipeline.ts:221:    if (!app) return res.status(404).json({ error: "Application not found" });
server/routes/pipeline.ts:226:      WHERE application_id = $1
server/routes/pipeline.ts:230:    console.log(`‚úÖ [PIPELINE-API] Found ${rows.length} documents for application: ${req.params.id} -> ${app.id}`);
server/routes/pipeline.ts:233:    console.error("‚ùå [PIPELINE-API] Error fetching documents:", e);
server/routes/pipeline.ts:238:// Board endpoint for new PipelinePage format - defensively coded with comprehensive business name extraction
server/routes/pipeline.ts:257:          'Application ' || SUBSTRING(a.id::text FROM 1 FOR 8)
server/routes/pipeline.ts:264:      FROM applications a
server/routes/pipeline.ts:274:    console.log(`üîç [PIPELINE-BOARD] Processing ${rows.length} applications`);
server/routes/pipeline.ts:280:      // Map database status to pipeline lanes
server/routes/pipeline.ts:292:          company: r.company || `Application ${r.id.substring(0, 8)}`,
server/routes/pipeline.ts:303:    console.log(`‚úÖ [PIPELINE-BOARD] Lanes populated:`, lanes.map(l => `${l.name}: ${l.items.length}`).join(', '));
server/routes/pipeline.ts:308:    console.error('pipeline error:', e?.message);
server/routes/pipeline.ts:321:r.get('/cards/:id/docs', async (req, res) => {
server/routes/pipeline.ts:331:r.post('/cards/:id/docs/:docId/:action(approve|reject|delete)', async (_req,res)=>{
server/o365/email.service.ts:122:          ContentType: attachment.contentType || "application/octet-stream",
server/mappings/applicationFieldMap.ts:2: * Canonical application schema with precedence rules.
server/mappings/applicationFieldMap.ts:5:export type CanonicalApplication = {
server/mappings/applicationFieldMap.ts:56:export function mapToCanonical(payload: Record<string, any>): { canonical: CanonicalApplication, unmapped: string[], coverage: number } {
server/mappings/applicationFieldMap.ts:129:  const canonical: CanonicalApplication = {
server/routes/applications.ts:7:import { applicationsService } from "../services/applications";
server/routes/applications.ts:13:// GET /api/applications - List all applications (MUST BE FIRST)
server/routes/applications.ts:16:    console.log('üìã [APPLICATIONS-ROUTE] Listing applications');
server/routes/applications.ts:21:      applications: [],
server/routes/applications.ts:22:      message: "Applications list endpoint working - implementation available"
server/routes/applications.ts:25:    console.error('‚ùå [APPLICATIONS-ROUTE] Failed to list applications:', error);
server/routes/applications.ts:33:// GET /api/applications/health - Health check endpoint
server/routes/applications.ts:67:      'application/pdf',
server/routes/applications.ts:71:      'application/msword',
server/routes/applications.ts:72:      'application/vnd.openxmlformats-officedocument.wordprocessingml.document'
server/routes/applications.ts:83:// POST /api/applications - Create new application
server/routes/applications.ts:86:    monitor("Application creation started", { 
server/routes/applications.ts:91:    console.log('üìù [APPLICATIONS-ROUTE] Creating application with data:', {
server/routes/applications.ts:106:    // Create application using service
server/routes/applications.ts:107:    const result = await applicationsService.createApplication({
server/routes/applications.ts:114:    monitor("Application created successfully", result);
server/routes/applications.ts:122:    console.error('‚ùå [APPLICATIONS-ROUTE] Application creation failed:', error);
server/routes/applications.ts:124:    let errorMessage = "Failed to create application";
server/routes/applications.ts:137:    monitor("Application creation failed", { error: errorMessage });
server/routes/applications.ts:145:// POST /api/applications/:id/documents - Upload document
server/routes/applications.ts:148:    const applicationId = req.params.id;
server/routes/applications.ts:165:      applicationId,
server/routes/applications.ts:171:    console.log('üìé [APPLICATIONS-ROUTE] Uploading document:', {
server/routes/applications.ts:172:      applicationId,
server/routes/applications.ts:181:      applicationId,
server/routes/applications.ts:199:    console.error('‚ùå [APPLICATIONS-ROUTE] Document upload failed:', error);
server/routes/applications.ts:222:// POST /api/applications/:id/submit - Submit application
server/routes/applications.ts:225:    const applicationId = req.params.id;
server/routes/applications.ts:227:    monitor("Application submission started", { applicationId });
server/routes/applications.ts:229:    console.log('üì§ [APPLICATIONS-ROUTE] Submitting application:', applicationId);
server/routes/applications.ts:231:    // Submit application using service
server/routes/applications.ts:232:    const result = await applicationsService.submitApplication(applicationId);
server/routes/applications.ts:234:    monitor("Application submitted successfully", result);
server/routes/applications.ts:237:    this.triggerLenderMatching(applicationId).catch(error => {
server/routes/applications.ts:238:      console.error('‚ö†Ô∏è [APPLICATIONS-ROUTE] Lender matching failed:', error);
server/routes/applications.ts:247:    console.error('‚ùå [APPLICATIONS-ROUTE] Application submission failed:', error);
server/routes/applications.ts:249:    let errorMessage = "Failed to submit application";
server/routes/applications.ts:259:    monitor("Application submission failed", { error: errorMessage });
server/routes/applications.ts:269:// GET /api/applications/list - List applications endpoint (MUST come before /:id)
server/routes/applications.ts:272:    console.log('üìã [APPLICATIONS-LIST] Fetching applications list');
server/routes/applications.ts:274:    // Return proper applications list
server/routes/applications.ts:277:      applications: [],
server/routes/applications.ts:278:      message: "Applications list endpoint - implementation available"
server/routes/applications.ts:281:    console.error('‚ùå [APPLICATIONS-LIST] Failed to list applications:', error);
server/routes/applications.ts:289:// GET /api/applications/:id - Get application details  
server/routes/applications.ts:292:    const applicationId = req.params.id;
server/routes/applications.ts:294:    console.log('üìã [APPLICATIONS-ROUTE] Getting application:', applicationId);
server/routes/applications.ts:296:    const application = await applicationsService.getApplication(applicationId);
server/routes/applications.ts:297:    const documents = await documentsService.getDocuments(applicationId);
server/routes/applications.ts:301:      application,
server/routes/applications.ts:306:    console.error('‚ùå [APPLICATIONS-ROUTE] Failed to get application:', error);
server/routes/applications.ts:311:      error: error instanceof Error ? error.message : "Failed to get application" 
server/routes/applications.ts:318:  monitor("Legacy application received", { business: req.body.businessName || req.body.business_name });
server/routes/applications.ts:326:    monitor("Legacy application processed", result);
server/routes/applications.ts:334:    monitor("Legacy application submission failed", error);
server/routes/applications.ts:340:async function triggerLenderMatching(applicationId: string) {
server/routes/applications.ts:342:    console.log('üéØ [APPLICATIONS-ROUTE] Triggering lender matching for:', applicationId);
server/routes/applications.ts:344:    // Get application details
server/routes/applications.ts:345:    const application = await applicationsService.getApplication(applicationId);
server/routes/applications.ts:349:      ? await sendToLenderProd(application)
server/routes/applications.ts:350:      : await sendToLenderSandbox(application);
server/routes/applications.ts:352:    console.log('‚úÖ [APPLICATIONS-ROUTE] Lender matching completed:', result);
server/routes/applications.ts:356:    console.error('‚ùå [APPLICATIONS-ROUTE] Lender matching failed:', error);
server/routes/applications.ts:361:// Application validation endpoint - REQUIRED by client app
server/routes/applications.ts:364:    console.log('üìã [APPLICATIONS] Validating application data');
server/routes/applications.ts:365:    const applicationData = req.body;
server/routes/applications.ts:368:    const missing = requiredFields.filter(field => !applicationData[field]);
server/routes/applications.ts:380:      message: 'Application validation passed',
server/routes/applications.ts:381:      data: applicationData
server/routes/applications.ts:384:    console.error('üìã [APPLICATIONS] Validation error:', error);
server/routes/applications.ts:389:// Application submission endpoint - REQUIRED by client app  
server/routes/applications.ts:392:    console.log('üìã [APPLICATIONS] Submitting application');
server/routes/applications.ts:395:      message: 'Application submitted successfully',
server/routes/applications.ts:396:      application_id: `app_${Date.now()}`,
server/routes/applications.ts:400:    console.error('üìã [APPLICATIONS] Submission error:', error);
server/routes/applications.ts:406:export const applicationsRouter = router;
server/o365/graphClient.ts:109:    headers: { "Content-Type": "application/x-www-form-urlencoded" },
server/routes/google-ads.mjs:70:    headers:{ "Content-Type":"application/x-www-form-urlencoded" },
server/routes/google-ads.mjs:89:    headers:{ "Content-Type":"application/x-www-form-urlencoded" },
server/routes/google-ads.mjs:105:// Status (stops the 404 spam and powers the "Connect" card)
server/routes/google-ads.mjs:166:        "Content-Type":"application/json",
server/routes/google-ads.mjs:210:        "Content-Type":"application/json",
server/routes/google-ads.mjs:253:      headers:{ "Content-Type":"application/json", "Authorization":`Bearer ${OPENAI_API_KEY}` },
server/routes/google-ads.mjs:275:    headers:{ "Content-Type":"application/json", "Authorization":`Bearer ${OPENAI_API_KEY}` },
server/routes/google-ads.mjs:290:    headers:{ "Content-Type":"application/json", "Authorization":`Bearer ${OPENAI_API_KEY}` },
server/routes/autoRestore.ts:11:router.post('/restore-orphaned/:applicationId', async (req, res) => {
server/routes/autoRestore.ts:12:  const { applicationId } = req.params;
server/routes/autoRestore.ts:15:    console.log(`üîß [AUTO-RESTORE] Starting auto-restore for application: ${applicationId}`);
server/routes/autoRestore.ts:21:      WHERE application_id = ${applicationId} 
server/routes/autoRestore.ts:37:            eq(documents.application_id, applicationId),
server/routes/autoRestore.ts:99:(Application: ${applicationId}) Tj
server/routes/autoRestore.ts:142:            file_type: 'application/pdf',
server/routes/autoRecovery.ts:2:import { triggerAutoRecoveryFlow, getMissingDocumentsForApplication } from '../utils/autoRecoveryTrigger';
server/routes/autoRecovery.ts:4:import { validateRecoveredDocumentUI, validateApplicationDocumentsUI, validateAllRecoveredDocumentsUI } from '../utils/uiRecoveryValidator';
server/routes/autoRecovery.ts:27:        alert.applicationId,
server/routes/autoRecovery.ts:55:// AUTO-RECOVERY 1: Get missing documents for specific application
server/routes/autoRecovery.ts:56:router.get('/application/:id/missing', async (req, res) => {
server/routes/autoRecovery.ts:58:    const { id: applicationId } = req.params;
server/routes/autoRecovery.ts:59:    console.log(`üîç [AUTO-RECOVERY API] Getting missing documents for application: ${applicationId}`);
server/routes/autoRecovery.ts:61:    const missingDocs = await getMissingDocumentsForApplication(applicationId);
server/routes/autoRecovery.ts:66:      applicationId,
server/routes/autoRecovery.ts:72:    console.error('‚ùå [AUTO-RECOVERY API] Application scan failed:', error);
server/routes/autoRecovery.ts:75:      error: 'Failed to scan application documents',
server/routes/autoRecovery.ts:107:    const { documentId, fileName, applicationId, businessName, status, details } = req.body;
server/routes/autoRecovery.ts:115:        applicationId,
server/routes/autoRecovery.ts:126:        applicationId,
server/routes/autoRecovery.ts:133:        applicationId,
server/routes/autoRecovery.ts:181:// AUTO-RECOVERY 3: Validate UI for all documents in application
server/routes/autoRecovery.ts:182:router.get('/validate/application/:id', async (req, res) => {
server/routes/autoRecovery.ts:184:    const { id: applicationId } = req.params;
server/routes/autoRecovery.ts:185:    console.log(`üìã [AUTO-RECOVERY API] Validating UI for application: ${applicationId}`);
server/routes/autoRecovery.ts:187:    const status = await validateApplicationDocumentsUI(applicationId);
server/routes/autoRecovery.ts:192:      applicationId,
server/routes/autoRecovery.ts:197:    console.error('‚ùå [AUTO-RECOVERY API] Application validation failed:', error);
server/routes/autoRecovery.ts:200:      error: 'Failed to validate application documents',
server/routes/autoRecovery.ts:230:router.post('/run-complete-recovery/:applicationId', async (req, res) => {
server/routes/autoRecovery.ts:232:    const { applicationId } = req.params;
server/routes/autoRecovery.ts:233:    console.log(`üîÑ [AUTO-RECOVERY API] Running complete recovery workflow for: ${applicationId}`);
server/routes/autoRecovery.ts:236:    const missingDocs = await getMissingDocumentsForApplication(applicationId);
server/routes/autoRecovery.ts:243:        doc.applicationId,
server/routes/autoRecovery.ts:250:    const uiStatus = await validateApplicationDocumentsUI(applicationId);
server/routes/autoRecovery.ts:258:      applicationId,
server/routes/autoRecovery.ts:418:// AUTO-RECOVERY APPLICATION-LEVEL: Recover all documents for specific application
server/routes/autoRecovery.ts:419:router.post('/recover-application/:applicationId', async (req, res) => {
server/routes/autoRecovery.ts:421:    const { applicationId } = req.params;
server/routes/autoRecovery.ts:422:    console.log(`üîÑ [AUTO-RECOVERY API] Starting application-level recovery for: ${applicationId}`);
server/routes/autoRecovery.ts:424:    // Get all documents for this application
server/routes/autoRecovery.ts:425:    const docsQuery = 'SELECT id, file_name, application_id FROM documents WHERE application_id = $1';
server/routes/autoRecovery.ts:426:    const docsResult = await pool.query(docsQuery, [applicationId]);
server/routes/autoRecovery.ts:432:        error: 'No documents found for this application',
server/routes/autoRecovery.ts:433:        applicationId
server/routes/autoRecovery.ts:479:      automation: 'AUTO-RECOVERY APPLICATION-LEVEL',
server/routes/autoRecovery.ts:480:      message: `Application recovery completed: ${successCount} recovered, ${failureCount} failed`,
server/routes/autoRecovery.ts:481:      applicationRecovery: {
server/routes/autoRecovery.ts:482:        applicationId,
server/routes/autoRecovery.ts:492:    console.log(`üéØ [AUTO-RECOVERY APP] Application ${applicationId} complete: ${successRate}% success rate`);
server/routes/autoRecovery.ts:495:    console.error('‚ùå [AUTO-RECOVERY API] Application recovery failed:', error);
server/routes/autoRecovery.ts:498:      error: 'Failed to recover application documents',
server/routes/autoRecovery.ts:520:          applicationId: alert.applicationId,
server/routes/retention/index.ts:4:import { purgeContactData, purgeApplicationData } from "../../services/rtbf/purge";
server/routes/retention/index.ts:40:  const { scope, contact_id, application_id, reason, expires_at } = req.body || {};
server/routes/retention/index.ts:41:  if (!scope || (!contact_id && !application_id)) {
server/routes/retention/index.ts:46:    INSERT INTO legal_holds(scope, contact_id, application_id, reason, expires_at, created_by_user_id)
server/routes/retention/index.ts:47:    VALUES (${scope}, ${contact_id || null}, ${application_id || null}, ${reason || null}, 
server/routes/retention/index.ts:69:  const { scope, contact_id, application_id, reason } = req.body || {};
server/routes/retention/index.ts:70:  if (!scope || (!contact_id && !application_id)) {
server/routes/retention/index.ts:78:      AND (contact_id = ${contact_id || null} OR application_id = ${application_id || null})
server/routes/retention/index.ts:87:    INSERT INTO erasure_requests(scope, contact_id, application_id, reason, created_by_user_id)
server/routes/retention/index.ts:88:    VALUES (${scope}, ${contact_id || null}, ${application_id || null}, ${reason || null}, ${req.user?.id || null})
server/routes/retention/index.ts:127:      applications: 5,
server/routes/retention/index.ts:133:  } else if (request.scope === 'application') {
server/routes/retention/index.ts:134:    const appId = request.application_id;
server/routes/retention/index.ts:136:      application: 1,
server/routes/retention/index.ts:164:  res.setHeader('Content-Type', 'application/json');
server/routes/retention/index.ts:185:    } else if (request.scope === 'application') {
server/routes/retention/index.ts:186:      result = await purgeApplicationData(request.application_id);
server/routes/crm-dynamic.mjs:38:/** GET /api/pipeline-cards?limit=200&tenantId=... */
server/routes/crm-dynamic.mjs:39:router.get("/api/pipeline-cards", async (req, res) => {
server/routes/crm-dynamic.mjs:44:    // Candidate application table names
server/routes/crm-dynamic.mjs:46:      "applications","loan_applications","sales_applications","deals","crm_applications"
server/routes/crm-dynamic.mjs:55:    sel.push(cols.has("id") ? `${a}."id"::text AS application_id` : `md5(random()::text) AS application_id`);
server/routes/crm-dynamic.mjs:58:    sel.push(pick(cols, a, ["stage","pipeline_stage","status_stage"], "stage", "text"));
server/routes/crm-dynamic.mjs:59:    sel.push(pick(cols, a, ["status","application_status"], "status", "text"));
server/routes/crm-dynamic.mjs:94:    const cards = apps.map(a => {
server/routes/crm-dynamic.mjs:114:        application_id: a.application_id,
server/routes/crm-dynamic.mjs:131:    res.json(cards);
server/routes/crm-dynamic.mjs:134:    res.status(500).json({ error: "pipeline-cards failed", detail: String(e.message || e) });
server/routes/crm-dynamic.mjs:138:/** GET /api/contact-cards?limit=200&tenantId=... */
server/routes/crm-dynamic.mjs:139:router.get("/api/contact-cards", async (req, res) => {
server/routes/crm-dynamic.mjs:180:    // Try to count linked applications if both sides have a contact id
server/routes/crm-dynamic.mjs:182:      "applications","loan_applications","sales_applications","deals","crm_applications"
server/routes/crm-dynamic.mjs:207:      applications_count: appsByContact.get(String(c.contact_id)) || 0,
server/routes/crm-dynamic.mjs:213:    res.status(500).json({ error: "contact-cards failed", detail: String(e.message || e) });
server/routes/applicationReprocessing.ts:4:import { applications, documents } from '../../shared/schema';
server/routes/applicationReprocessing.ts:11:  applicationId: z.string().uuid(),
server/routes/applicationReprocessing.ts:17:// POST /api/application-reprocessing/request-resync
server/routes/applicationReprocessing.ts:20:    const { applicationId, reason, requestNotification, staffNotes } = reprocessingSchema.parse(req.body);
server/routes/applicationReprocessing.ts:22:    console.log(`üîÑ [REPROCESSING] Staff requesting form_data resync for ${applicationId}`);
server/routes/applicationReprocessing.ts:24:    // Validate application exists
server/routes/applicationReprocessing.ts:25:    const application = await db.select()
server/routes/applicationReprocessing.ts:26:      .from(applications)
server/routes/applicationReprocessing.ts:27:      .where(eq(applications.id, applicationId))
server/routes/applicationReprocessing.ts:30:    if (application.length === 0) {
server/routes/applicationReprocessing.ts:32:        error: 'Application not found',
server/routes/applicationReprocessing.ts:33:        applicationId
server/routes/applicationReprocessing.ts:37:    const app = application[0];
server/routes/applicationReprocessing.ts:39:    // Check if application actually needs reprocessing
server/routes/applicationReprocessing.ts:45:        error: 'Application already has complete form data',
server/routes/applicationReprocessing.ts:46:        applicationId,
server/routes/applicationReprocessing.ts:51:    // Update application with reprocessing request
server/routes/applicationReprocessing.ts:52:    await db.update(applications)
server/routes/applicationReprocessing.ts:57:      .where(eq(applications.id, applicationId));
server/routes/applicationReprocessing.ts:60:    console.log(`‚úÖ [REPROCESSING] Application ${applicationId} marked for reprocessing`);
server/routes/applicationReprocessing.ts:69:      .where(eq(documents.applicationId, applicationId));
server/routes/applicationReprocessing.ts:73:      applicationId,
server/routes/applicationReprocessing.ts:82:        message: 'Client will be notified to resubmit complete application data',
server/routes/applicationReprocessing.ts:89:      console.log(`üìß [NOTIFICATION] Would send resubmission request to client for ${applicationId}`);
server/routes/applicationReprocessing.ts:90:      console.log(`üì± [NOTIFICATION] SMS/Email: "Your application requires resubmission of complete form data"`);
server/routes/applicationReprocessing.ts:112:// GET /api/application-reprocessing/status/:applicationId
server/routes/applicationReprocessing.ts:113:router.get('/status/:applicationId', async (req, res) => {
server/routes/applicationReprocessing.ts:115:    const { applicationId } = req.params;
server/routes/applicationReprocessing.ts:117:    const application = await db.select()
server/routes/applicationReprocessing.ts:118:      .from(applications)
server/routes/applicationReprocessing.ts:119:      .where(eq(applications.id, applicationId))
server/routes/applicationReprocessing.ts:122:    if (application.length === 0) {
server/routes/applicationReprocessing.ts:124:        error: 'Application not found',
server/routes/applicationReprocessing.ts:125:        applicationId
server/routes/applicationReprocessing.ts:129:    const app = application[0];
server/routes/applicationReprocessing.ts:134:      applicationId,
server/routes/security/compliance.ts:185:    res.setHeader('Content-Type', 'application/zip');
server/routes/voice.token.ts:47:      outgoingApplicationSid: twimlAppSid,
server/lib/findApp.ts:11:    FROM c LEFT JOIN applications a
server/routes/lenderEngine/v11.ts:9:router.post("/run/:applicationId", async (req:any, res)=>{
server/routes/lenderEngine/v11.ts:11:  res.json(await runEngine11(req.params.applicationId, variant));
server/routes/lenderEngine/v11.ts:35:router.get("/trace/:applicationId/latest", async (req:any,res)=>{
server/routes/lenderEngine/v11.ts:38:    FROM decision_traces WHERE application_id=${req.params.applicationId}
server/routes/_int/schema-audit.ts:20:      res.type("application/json").send(report);
server/routes/chatRoutes-secure.ts:56:    const { userId, applicationId, context } = req.body;
server/routes/chatRoutes-secure.ts:420:    const { sessionId, userName, userEmail, message, escalationReason, applicationId } = req.body;
server/routes/chatRoutes-secure.ts:459:      applicationId: applicationId || null,
server/routes/chatRoutes-secure.ts:508:    const { sessionId, userName, userEmail, issueType, description, severity, applicationId } = req.body;
server/routes/chatRoutes-secure.ts:559:      applicationId: applicationId || null,
server/routes/chatRoutes-secure.ts:870:      applicationId: null,
server/routes/ocr/mapping.ts:82:/* Apply OCR mapping to update application data */
server/routes/ocr/mapping.ts:123:  // Update application with extracted data
server/routes/ocr/mapping.ts:135:    updateValues.push(document.application_id);
server/routes/ocr/mapping.ts:136:    const query = `UPDATE applications SET ${updateFields.join(', ')} WHERE id = $${updateValues.length}`;
server/routes/ocr/mapping.ts:155:    LEFT JOIN applications a ON a.id = d.application_id
server/routes/ocr/mapping.ts:162:/* Mock OCR mapping rule application */
server/routes/chatRoutes.ts:17:    const { userId, applicationId, context } = req.body;
server/routes/chatRoutes.ts:30:      applicationId: applicationId || null,
server/routes/chatRoutes.ts:279:    const { sessionId, userName, userEmail, message, escalationReason, applicationId } = req.body;
server/routes/chatRoutes.ts:298:      applicationId: applicationId || null,
server/routes/chatRoutes.ts:316:        applicationId,
server/routes/chatRoutes.ts:331:        applicationId,
server/routes/chatRoutes.ts:364:    const { sessionId, userName, userEmail, issueType, description, severity, applicationId } = req.body;
server/routes/chatRoutes.ts:384:      applicationId: applicationId || null,
server/routes/chatRoutes.ts:404:          applicationId,
server/routes/chatRoutes.ts:632:      applicationId: null,
server/routes/lender/public.ts:12:  const appId = req.lender.applicationId;
server/routes/lender/public.ts:13:  const app = (await db.execute(sql`SELECT id, product_category, stage, amount_requested FROM applications WHERE id=${appId} LIMIT 1`)).rows?.[0];
server/routes/lender/public.ts:14:  const docs = (await db.execute(sql`SELECT id, filename, category, created_at FROM documents WHERE application_id=${appId} ORDER BY created_at DESC`)).rows || [];
server/routes/lender/public.ts:16:  res.json({ application: app, documents: docs });
server/routes/lender/public.ts:22:  const { filename, contentType="application/octet-stream", category } = req.body || {};
server/routes/lender/public.ts:23:  const key = `lender/${req.lender.applicationId}/${Date.now()}_${String(filename||'file').replace(/\s+/g,'_')}`;
server/routes/lender/public.ts:29:    INSERT INTO documents(application_id, filename, s3_key, category, source, partner_id)
server/routes/lender/public.ts:30:    VALUES (${req.lender.applicationId}, ${filename}, ${key}, ${category||null}, 'lender', ${req.lender.partnerId})
server/routes/lender/public.ts:40:  const doc = (await db.execute(sql`SELECT id, filename, s3_key FROM documents WHERE id=${documentId} AND application_id=${req.lender.applicationId} LIMIT 1`)).rows?.[0];
server/routes/lender/public.ts:52:  const appId = req.lender.applicationId;
server/routes/lender/public.ts:53:  const r = await db.execute(sql`SELECT id, body, created_at, role FROM comm_messages WHERE application_id=${appId} AND channel='portal' ORDER BY created_at DESC LIMIT 100`);
server/routes/lender/public.ts:59:  const appId = req.lender.applicationId;
server/routes/lender/public.ts:61:    INSERT INTO comm_messages(application_id, partner_id, direction, channel, role, body, created_at)
server/lib/googleAds.ts:23:        'Content-Type': 'application/json',
server/routes/public-applications.ts:3:import { applicationsService } from "../services/applications";
server/routes/public-applications.ts:18:      'application/pdf',
server/routes/public-applications.ts:22:      'application/msword',
server/routes/public-applications.ts:23:      'application/vnd.openxmlformats-officedocument.wordprocessingml.document'
server/routes/public-applications.ts:34:// POST /public/applications - Create new application (for client integration)
server/routes/public-applications.ts:35:router.post("/applications", express.json(), async (req, res) => {
server/routes/public-applications.ts:38:      console.log('üìù [PUBLIC-APPLICATIONS] Raw request body:', req.body);
server/routes/public-applications.ts:39:      console.log('üìù [PUBLIC-APPLICATIONS] Headers:', req.headers);
server/routes/public-applications.ts:40:      console.log('üìù [PUBLIC-APPLICATIONS] Content-Type:', req.get('Content-Type'));
server/routes/public-applications.ts:81:    // Create application using existing service
server/routes/public-applications.ts:82:    const result = await applicationsService.createApplication({
server/routes/public-applications.ts:89:    console.log('‚úÖ [PUBLIC-APPLICATIONS] Application created successfully:', result.id);
server/routes/public-applications.ts:98:    console.error('‚ùå [PUBLIC-APPLICATIONS] Application creation failed:', error);
server/routes/public-applications.ts:100:    let errorMessage = "Failed to create application";
server/routes/public-applications.ts:120:// POST /public/applications/:id/documents - Upload document (for client integration)
server/routes/public-applications.ts:121:router.post("/applications/:id/documents", upload.single('document'), async (req, res) => {
server/routes/public-applications.ts:123:    const applicationId = req.params.id;
server/routes/public-applications.ts:139:    console.log('üìé [PUBLIC-APPLICATIONS] Uploading document:', {
server/routes/public-applications.ts:140:      applicationId,
server/routes/public-applications.ts:149:      applicationId,
server/routes/public-applications.ts:159:    console.log('‚úÖ [PUBLIC-APPLICATIONS] Document uploaded successfully:', result.document_id);
server/routes/public-applications.ts:169:    console.error('‚ùå [PUBLIC-APPLICATIONS] Document upload failed:', error);
server/routes/public-applications.ts:191:// GET /public/applications/:id/documents - List documents for application (for client integration)
server/routes/public-applications.ts:192:router.get("/applications/:id/documents", async (req, res) => {
server/routes/public-applications.ts:194:    const applicationId = req.params.id;
server/routes/public-applications.ts:196:    console.log('üìã [PUBLIC-APPLICATIONS] Listing documents for application:', applicationId);
server/routes/public-applications.ts:199:    const documents = await documentsService.getDocuments(applicationId);
server/routes/public-applications.ts:201:    console.log(`‚úÖ [PUBLIC-APPLICATIONS] Found ${documents.length} documents for application:`, applicationId);
server/routes/public-applications.ts:219:    console.error('‚ùå [PUBLIC-APPLICATIONS] Failed to list documents:', error);
server/routes/public-applications.ts:238:// GET /public/applications/:id/status - Get application status (for client integration)  
server/routes/public-applications.ts:239:router.get("/applications/:id/status", async (req, res) => {
server/routes/public-applications.ts:241:    const applicationId = req.params.id;
server/routes/public-applications.ts:243:    console.log('üîç [PUBLIC-APPLICATIONS] Getting status for application:', applicationId);
server/routes/public-applications.ts:245:    // Get application status using existing service
server/routes/public-applications.ts:246:    const application = await applicationsService.getApplication(applicationId);
server/routes/public-applications.ts:248:    console.log('‚úÖ [PUBLIC-APPLICATIONS] Retrieved application status:', application.status);
server/routes/public-applications.ts:252:      id: application.id,
server/routes/public-applications.ts:253:      status: application.status,
server/routes/public-applications.ts:254:      stage: application.stage,
server/routes/public-applications.ts:255:      created_at: application.created_at,
server/routes/public-applications.ts:256:      updated_at: application.updated_at,
server/routes/public-applications.ts:257:      business_name: application.business,
server/routes/public-applications.ts:258:      amount_requested: application.amount,
server/routes/public-applications.ts:260:        application_created: true,
server/routes/public-applications.ts:261:        documents_uploaded: application.status !== 'draft',
server/routes/public-applications.ts:262:        submitted: ['submitted', 'In Review', 'approved', 'rejected'].includes(application.status),
server/routes/public-applications.ts:263:        under_review: application.status === 'In Review',
server/routes/public-applications.ts:264:        decision_made: ['approved', 'rejected'].includes(application.status)
server/routes/public-applications.ts:269:    console.error('‚ùå [PUBLIC-APPLICATIONS] Failed to get application status:', error);
server/routes/public-applications.ts:271:    let errorMessage = "Failed to retrieve application status";
server/routes/public-applications.ts:288:// POST /public/applications/:id/submit - Submit application (for client integration)
server/routes/public-applications.ts:289:router.post("/applications/:id/submit", async (req, res) => {
server/routes/public-applications.ts:291:    const applicationId = req.params.id;
server/routes/public-applications.ts:293:    console.log('üì§ [PUBLIC-APPLICATIONS] Submitting application:', applicationId);
server/routes/public-applications.ts:295:    // Submit application using existing service
server/routes/public-applications.ts:296:    const result = await applicationsService.submitApplication(applicationId);
server/routes/public-applications.ts:298:    console.log('‚úÖ [PUBLIC-APPLICATIONS] Application submitted successfully:', result);
server/routes/public-applications.ts:307:    console.error('‚ùå [PUBLIC-APPLICATIONS] Application submission failed:', error);
server/routes/public-applications.ts:309:    let errorMessage = "Failed to submit application";
server/lib/s3PutPresign.ts:5:export async function presignUpload(key:string, contentType="application/octet-stream"){
server/routes/simple-application-create.ts:1:// Simple application creation endpoint for E2E verification
server/routes/simple-application-create.ts:13:// POST /public/applications - Create application for E2E testing
server/routes/simple-application-create.ts:14:router.post("/public/applications", async (req, res) => {
server/routes/simple-application-create.ts:19:    // Generate proper UUID for application
server/routes/simple-application-create.ts:23:      INSERT INTO applications (id, user_id, requested_amount, use_of_funds, status, submission_country, product_id, created_at, updated_at)
server/routes/simple-application-create.ts:39:      message: 'application created',
server/routes/simple-application-create.ts:48:    console.error("Application creation error:", e);
server/routes/search/global.ts:18:    applications: [],
server/routes/search/global.ts:27:    // Search Applications
server/routes/search/global.ts:28:    if (!filters?.types || filters.types.includes('applications')) {
server/routes/search/global.ts:32:               a.status, a.created_at, 'application' as type
server/routes/search/global.ts:33:        FROM applications a 
server/routes/search/global.ts:42:      results.applications = appResults.rows || [];
server/routes/search/global.ts:65:        SELECT d.id, d.filename, d.category, d.application_id, d.created_at,
server/routes/search/global.ts:68:        LEFT JOIN applications a ON a.id = d.application_id
server/routes/search/global.ts:94:          SELECT c.id, c.body, c.channel, c.created_at, c.application_id,
server/routes/search/global.ts:97:          LEFT JOIN applications a ON a.id = c.application_id
server/routes/search/global.ts:111:    results.total = results.applications.length + results.contacts.length + 
server/routes/search/global.ts:137:      FROM applications 
server/routes/search/global.ts:158:      FROM applications
server/routes/search/global.ts:193:    applications: [],
server/routes/search/global.ts:229:             a.business_phone as phone, a.status, a.created_at, 'application' as type
server/routes/search/global.ts:230:      FROM applications a 
server/routes/search/global.ts:239:    results.applications = appResults.rows || [];
server/routes/search/global.ts:240:    results.total = results.applications.length;
server/lib/aiProvider.ts:21:export async function cueCards(obj:any){
server/routes/simple-test.ts:15:// Application creation endpoint (public)
server/routes/simple-test.ts:16:router.post('/public-applications', async (req, res) => {
server/routes/simple-test.ts:18:    console.log('üìù [PUBLIC-APP] Creating application without auth required');
server/routes/simple-test.ts:29:    // Create a test application entry
server/routes/simple-test.ts:30:    const applicationData = {
server/routes/simple-test.ts:42:    console.log('‚úÖ [PUBLIC-APP] Application created:', applicationData.id);
server/routes/simple-test.ts:46:      application: applicationData,
server/routes/simple-test.ts:47:      message: 'Application created successfully without authentication'
server/routes/simple-test.ts:54:      error: 'Failed to create application',
server/lib/graph.ts:1:import { ConfidentialClientApplication, Configuration } from "@azure/msal-node";
server/lib/graph.ts:10:const cca = new ConfidentialClientApplication(cfg);
server/lib/graph.ts:12:// get app token (client credentials) for application permissions fallback
server/lib/graph.ts:21:  const headers = { "Content-Type":"application/json", "Authorization":`Bearer ${token}`, ...(init?.headers||{}) };
server/routes/applications-minimal.ts:7:  console.log('üéØ [APPLICATIONS] GET / route handler reached!');
server/routes/applications-minimal.ts:11:      applications: [],
server/routes/applications-minimal.ts:14:      message: 'Minimal applications endpoint working',
server/routes/applications-minimal.ts:23:      error: 'Failed to fetch applications',
server/routes/applications-minimal.ts:30:export const applicationsMinimalRouter = router;
server/lib/audit.ts:29:  applicationId: string,
server/lib/audit.ts:34:  await audit(rid, tenant, userId, "ai_action", "application", applicationId, {
server/routes/dashboard.ts:12:    applications: 0,
server/routes/client/docreq/index.ts:8:/* List tasks for contact (by application(s)) */
server/routes/client/docreq/index.ts:13:    SELECT r.*, a.id AS application_id
server/routes/client/docreq/index.ts:14:    FROM applications a
server/routes/client/docreq/index.ts:15:    JOIN doc_requests r ON r.application_id=a.id
server/routes/client/docreq/index.ts:25:  const { requestId, filename, contentType="application/octet-stream" } = req.body || {};
server/routes/client/docreq/index.ts:29:    SELECT r.id, r.application_id
server/routes/client/docreq/index.ts:31:    JOIN applications a ON a.id=r.application_id
server/routes/client/docreq/index.ts:36:  const key = `requests/${row.application_id}/${requestId}/${Date.now()}_${String(filename||'file').replace(/\s+/g,'_')}`;
server/routes/client/docreq/index.ts:47:    SELECT r.id, r.application_id FROM doc_requests r
server/routes/client/docreq/index.ts:48:    JOIN applications a ON a.id=r.application_id WHERE r.id=${requestId} AND a.contact_id=${contactId} LIMIT 1
server/routes/client/docreq/index.ts:53:    INSERT INTO documents(application_id, filename, s3_key, category, source)
server/routes/client/docreq/index.ts:54:    VALUES (${row.application_id}, ${filename}, ${s3_key}, 'request', 'client')
server/lib/validate.ts:5:export const AppIdSchema = z.object({ applicationId: z.string().min(1) });
server/lib/validate.ts:8:  applicationId: z.string().min(1),
server/lib/validate.ts:15:  applicationId: z.string().min(1),
server/lib/validate.ts:20:  applicationId: z.string().min(1), 
server/lib/validate.ts:25:  applicationId: z.string().min(1)
server/lib/validate.ts:29:  applicationId: z.string().min(1),
server/lib/aiObservability.ts:8:  applicationId?: string;
server/lib/aiObservability.ts:24:        action, user_id, tenant_id, application_id, contact_id,
server/lib/aiObservability.ts:29:        ${metrics.applicationId}, ${metrics.contactId}, ${metrics.requestId},
server/lib/aiObservability.ts:168:    applicationId?: string;
server/routes/v1-applications-docs.ts:1:// V1 API for application document uploads - AUTHORITATIVE ENDPOINT (PUBLIC ACCESS)
server/routes/v1-applications-docs.ts:27:// AUTHORITATIVE ENDPOINT: POST /api/v1/applications/:id/docs
server/routes/v1-applications-docs.ts:28:router.post("/api/v1/applications/:id/docs", upload.single("file"), async (req: Request, res: Response) => {
server/routes/v1-applications-docs.ts:30:    const applicationId = req.params.id;
server/routes/v1-applications-docs.ts:34:    console.log(`üìù [V1-DOCS] Document upload request for application ${applicationId}`);
server/routes/v1-applications-docs.ts:60:    const s3Key = `applications/${applicationId}/documents/${timestamp}/${documentId}-${file.originalname}`;
server/routes/v1-applications-docs.ts:73:        'application-id': applicationId,
server/routes/v1-applications-docs.ts:89:        id, application_id, document_type, file_name, file_path, 
server/routes/v1-applications-docs.ts:94:      documentId, applicationId, documentType, file.originalname, 
server/routes/v1-applications-docs.ts:104:        application_id: applicationId,
server/routes/v1-applications-docs.ts:124:// GET /api/v1/applications/:id/docs - List documents for application
server/routes/v1-applications-docs.ts:125:router.get("/api/v1/applications/:id/docs", async (req: Request, res: Response) => {
server/routes/v1-applications-docs.ts:127:    const applicationId = req.params.id;
server/routes/v1-applications-docs.ts:135:      WHERE application_id = $1 
server/routes/v1-applications-docs.ts:137:    `, [applicationId]);
server/routes/v1-applications-docs.ts:154:router.post("/api/v1/applications/:id/docs/presigned", async (req: Request, res: Response) => {
server/routes/v1-applications-docs.ts:156:    const applicationId = req.params.id;
server/routes/v1-applications-docs.ts:168:    const s3Key = `applications/${applicationId}/documents/${timestamp}/${documentId}-${fileName}`;
server/routes/v1-applications-docs.ts:175:        'application-id': applicationId,
server/routes/docreq/staff.ts:9:/* List requests for an application */
server/routes/docreq/staff.ts:10:router.get("/:applicationId", async (req:any, res)=>{
server/routes/docreq/staff.ts:11:  const appId = String(req.params.applicationId);
server/routes/docreq/staff.ts:12:  const r = await db.execute(sql`SELECT * FROM doc_requests WHERE application_id=${appId} ORDER BY created_at ASC`);
server/routes/docreq/staff.ts:18:  const { applicationId, items } = req.body || {}; // items: [{title, description, required, due_date}]
server/routes/docreq/staff.ts:22:      INSERT INTO doc_requests(application_id, title, description, required, due_date, created_by_user_id)
server/routes/docreq/staff.ts:23:      VALUES (${applicationId}, ${it.title}, ${it.description||null}, ${it.required ?? true}, ${it.due_date || null}, ${req.user?.id || null})
server/routes/docreq/staff.ts:52:  const { applicationId, requestId, filename, contentType="application/octet-stream" } = req.body || {};
server/routes/docreq/staff.ts:53:  const key = `requests/${applicationId}/${requestId}/${Date.now()}_${String(filename||'file').replace(/\s+/g,'_')}`;
server/routes/docreq/staff.ts:60:  const { applicationId, requestId, filename, s3_key, contentType } = req.body || {};
server/routes/docreq/staff.ts:63:    INSERT INTO documents(application_id, filename, s3_key, category, source)
server/routes/docreq/staff.ts:64:    VALUES (${applicationId}, ${filename}, ${s3_key}, 'request', 'staff')
server/lib/aiSecurity.ts:14:  // Credit card patterns (basic)
server/routes/src-api-mount.ts:11:    router.use("/public/client-api/applications", clientIntegrationRouter);
server/lib/aiQueue.ts:29:  applicationId?: string;
server/lib/aiQueue.ts:88:      application_id, contact_id, user_id, tenant_id
server/lib/aiQueue.ts:91:      ${data.applicationId}, ${data.contactId}, ${data.userId}, ${data.tenantId}
server/routes/client-integration-test.ts:26:// Simple application creation (fixed version)
server/routes/client-integration-test.ts:46:      INSERT INTO applications (
server/routes/client-integration-test.ts:90:      application: {
server/routes/client-integration-test.ts:101:    console.error("Application creation error:", e);
server/routes/client-integration-test.ts:103:      error: "Failed to create application",
server/routes/client-integration-test.ts:132:      applicationId: req.params.id,
server/routes/client-integration-test.ts:174:      applicationId: req.params.id,
server/routes/ops/overview.ts:15:        (SELECT count(*)::int FROM applications) AS applications,
server/routes/ops/overview.ts:23:    out.counts = { contacts: "‚Äî", applications: "‚Äî", documents: "‚Äî" };
server/lib/registerUse.ts:1:import type { Application, Router } from 'express';
server/lib/registerUse.ts:10:export function registerUse(app: Application, path: string, router: Router, label?: string) {
server/routes/support.js:32:        category: 'Application Status',
server/routes/support.js:33:        subject: 'Questions about my loan application status',
server/routes/support.js:34:        description: 'Hi, I submitted my equipment financing application 3 days ago and haven\'t heard back. Can someone please update me on the status?',
server/routes/support.js:48:        description: 'I\'m trying to complete my working capital application but I\'m not sure which bank statements you need. Can someone clarify?',
server/routes/support.js:135:        title: 'Application form not saving properly',
server/routes/support.js:153:        description: 'Customers are not receiving SMS notifications when their loan application status changes.',
server/routes/support.js:158:        steps: '1. Change application status to "Approved"\n2. SMS notification should be sent\n3. Customer does not receive SMS',
server/routes/documents.upload.ts:23:r.post("/api/applications/:id/documents/upload", requireStaff, upload.single("file"), async (req: Request, res: Response) => {
server/routes/documents.upload.ts:32:    // üîê optional: ensure user/session is authorized to upload to this application
server/routes/documents.upload.ts:36:    // const key = `applications/${appId}/${Date.now()}-${slug(f.originalname)}`;
server/routes/documents.upload.ts:40:    const key = `applications/${appId}/${Date.now()}-${slug(f.originalname)}`;
server/routes/documents.upload.ts:47:      `insert into documents (application_id, file_name, file_size, document_type, status, file_key, uploaded_by)
server/lib/s3.ts:9:export async function presignUpload(key: string, contentType="application/octet-stream", expires=900){
server/routes/publicApplicationsSimple.ts:70:  throw new Error("Invalid application payload - cannot create application with incomplete data");
server/routes/publicApplicationsSimple.ts:73:// Public application submission endpoint
server/routes/publicApplicationsSimple.ts:74:r.post("/applications", async (req, res) => {
server/routes/publicApplicationsSimple.ts:76:    console.log("üìù [PUBLIC-INTAKE] Received application submission");
server/routes/publicApplicationsSimple.ts:105:    console.log("‚úÖ [PUBLIC-INTAKE] Creating application:", businessName);
server/routes/publicApplicationsSimple.ts:107:    // Store in applications table with proper field mapping - let DB generate UUID
server/routes/publicApplicationsSimple.ts:111:        INSERT INTO applications (
server/routes/publicApplicationsSimple.ts:130:    console.log("üéâ [PUBLIC-INTAKE] Application created successfully:", created.id);
server/routes/publicApplicationsSimple.ts:135:      applicationId: created.id, // Return the UUID, not app_ prefix
server/routes/publicApplicationsSimple.ts:138:      message: "Application submitted successfully" 
server/routes/publicApplicationsSimple.ts:146:      message: error?.message ?? "Failed to process application" 
server/lib/zip.ts:6:  res.setHeader("Content-Type", "application/zip");
server/routes/automations/send.ts:23:    method:"POST", headers:{"Content-Type":"application/json"},
server/routes/drawerAPI.ts:7:// Application data for drawer - canonical fields
server/routes/drawerAPI.ts:8:router.get('/pipeline/cards/:id/application', bearerAuth, async (req, res) => {
server/routes/drawerAPI.ts:22:      FROM applications 
server/routes/drawerAPI.ts:27:      return res.status(404).json({ ok: false, error: 'Application not found' });
server/routes/drawerAPI.ts:33:    console.log(`üöÄ [PIPELINE-BOARD] Fetching comprehensive application details for: ${req.params.id}`);
server/routes/drawerAPI.ts:34:    console.log(`‚úÖ [PIPELINE-BOARD] Comprehensive data loaded: ${a.business_name} (${Object.keys(c).length} canonical fields)`);
server/routes/drawerAPI.ts:38:      application: {
server/routes/drawerAPI.ts:74:    console.error('Error fetching application:', error);
server/routes/drawerAPI.ts:75:    res.status(500).json({ ok: false, error: 'Failed to fetch application' });
server/routes/documentAPI.ts:7:// List documents for an application with view URLs
server/routes/documentAPI.ts:8:router.get('/applications/:id/documents', bearerAuth, async (req, res) => {
server/routes/documentAPI.ts:13:      WHERE application_id = $1 
server/routes/documentAPI.ts:32:// Upload/link document to application
server/routes/documentAPI.ts:33:router.post('/applications/:id/documents', bearerAuth, async (req, res) => {
server/routes/documentAPI.ts:43:      INSERT INTO documents (application_id, file_name, file_key, file_size, document_type, status, uploaded_by)
server/lib/approvals.ts:9:  applicationId?: string;
server/lib/approvals.ts:32:    applicationId: input.applicationId || null,
server/lib/approvals.ts:72:      applicationId: ar.applicationId,
server/routes/analytics/dashboard.ts:55:        avgDailyApplications: Math.round(avgDailyApps * 10) / 10,
server/routes/analytics/index.ts:32:        (SELECT COUNT(*) FROM applications a WHERE a.created_at BETWEEN $1::date AND $2::date + INTERVAL '1 day') AS apps_this_period,
server/routes/analytics/index.ts:33:        (SELECT COUNT(*) FROM applications WHERE stage='Requires Docs') AS requires_docs,
server/routes/analytics/index.ts:34:        (SELECT COUNT(*) FROM applications WHERE stage='In Review') AS in_review,
server/routes/analytics/index.ts:35:        (SELECT COUNT(*) FROM applications WHERE stage='Off to Lender') AS lenders,
server/routes/analytics/index.ts:36:        (SELECT COUNT(*) FROM applications WHERE stage='Accepted') AS sent,
server/routes/analytics/index.ts:37:        (SELECT COUNT(*) FROM applications WHERE stage='Accepted') AS funded_total
server/routes/analytics/index.ts:114:      FROM applications
server/routes/api/documents.ts:9:    if (!req.file || !req.body.application_id || !req.body.category) {
server/routes/api/documents.ts:16:      application_id: req.body.application_id,
server/routes/api/documents.ts:32:// GET documents for application with enhanced data
server/routes/api/documents.ts:228:// GET upload logs for application
server/routes/api/documents.ts:237:        applicationId: appId,
server/routes/api/documents.ts:245:        applicationId: appId,
server/routes/api/documents.ts:279:router.get('/:applicationId/download-zip', async (req, res) => {
server/routes/api/documents.ts:280:  const applicationId = req.params.applicationId;
server/routes/api/documents.ts:284:    res.setHeader('Content-Type', 'application/zip');
server/routes/api/documents.ts:285:    res.setHeader('Content-Disposition', `attachment; filename="Application-${applicationId}-Documents.zip"`);
server/routes/api/documents.ts:288:    res.send('Mock ZIP file content for application ' + applicationId);
server/routes/api/documents.ts:297:  const { fileName, base64, applicationId, documentType } = req.body;
server/routes/api/documents.ts:300:    if (!fileName || !base64 || !applicationId) {
server/routes/api/documents.ts:306:    console.log(`Base64 document uploaded: ${fileName} for application ${applicationId}`);
server/routes/api/documents.ts:318:    const { documentId, applicationId, documentType, requirements } = req.body;
server/routes/api/documents.ts:320:    console.log('üîç [DOCUMENT-VERIFICATION] Verifying document:', { documentId, applicationId, documentType });
server/routes/api/documents.ts:322:    if (!documentId && !applicationId) {
server/routes/api/documents.ts:325:        error: 'Either documentId or applicationId is required'
server/routes/api/documents.ts:332:      applicationId: applicationId || `app-${Date.now()}`,
server/routes/analytics/pdf.ts:22:        (SELECT COUNT(*) FROM applications a WHERE a.created_at BETWEEN $1::date AND $2::date + INTERVAL '1 day') AS apps_this_period,
server/routes/analytics/pdf.ts:23:        (SELECT COUNT(*) FROM applications WHERE stage='Requires Docs') AS requires_docs,
server/routes/analytics/pdf.ts:24:        (SELECT COUNT(*) FROM applications WHERE stage='In Review') AS in_review,
server/routes/analytics/pdf.ts:25:        (SELECT COUNT(*) FROM applications WHERE stage='Off to Lender') AS lenders,
server/routes/analytics/pdf.ts:26:        (SELECT COUNT(*) FROM applications WHERE stage='Accepted') AS sent,
server/routes/analytics/pdf.ts:27:        (SELECT COUNT(*) FROM applications WHERE stage='Accepted') AS funded_total
server/routes/analytics/pdf.ts:78:    res.setHeader('Content-Type', 'application/pdf');
server/routes/reports.ts:6:// Pipeline Activity Report
server/routes/reports.ts:7:router.get('/pipeline-activity', async (req, res) => {
server/routes/reports.ts:9:    console.log('üìä [REPORTS] Generating pipeline activity report');
server/routes/reports.ts:17:      conditions.push(gte(applications.createdAt, new Date(startDate as string)));
server/routes/reports.ts:20:      conditions.push(lte(applications.createdAt, new Date(endDate as string)));
server/routes/reports.ts:23:    // Applications by status
server/routes/reports.ts:24:    const applicationsByStatus = await db
server/routes/reports.ts:26:        status: applications.status,
server/routes/reports.ts:29:      .from(applications)
server/routes/reports.ts:31:      .groupBy(applications.status);
server/routes/reports.ts:33:    // Applications by date (last 30 days)
server/routes/reports.ts:34:    const applicationsByDate = await db
server/routes/reports.ts:36:        date: sql<string>`DATE(${applications.createdAt})`,
server/routes/reports.ts:39:      .from(applications)
server/routes/reports.ts:41:        gte(applications.createdAt, new Date(Date.now() - 30 * 24 * 60 * 60 * 1000))
server/routes/reports.ts:43:      .groupBy(sql`DATE(${applications.createdAt})`)
server/routes/reports.ts:44:      .orderBy(sql`DATE(${applications.createdAt})`);
server/routes/reports.ts:46:    // Applications by lead source
server/routes/reports.ts:47:    const applicationsBySource = await db
server/routes/reports.ts:49:        leadSource: applications.leadSource,
server/routes/reports.ts:52:      .from(applications)
server/routes/reports.ts:54:      .groupBy(applications.leadSource);
server/routes/reports.ts:56:    // Recent applications
server/routes/reports.ts:57:    const recentApplications = await db
server/routes/reports.ts:59:        id: applications.id,
server/routes/reports.ts:61:        status: applications.status,
server/routes/reports.ts:62:        loanAmount: applications.loanAmount,
server/routes/reports.ts:63:        createdAt: applications.createdAt
server/routes/reports.ts:65:      .from(applications)
server/routes/reports.ts:66:      .leftJoin(businesses, eq(applications.businessId, businesses.id))
server/routes/reports.ts:68:      .orderBy(desc(applications.createdAt))
server/routes/reports.ts:71:    console.log('‚úÖ [REPORTS] Pipeline activity report generated successfully');
server/routes/reports.ts:76:          totalApplications: applicationsByStatus.reduce((sum, item) => sum + item.count, 0),
server/routes/reports.ts:77:          byStatus: applicationsByStatus,
server/routes/reports.ts:78:          bySource: applicationsBySource
server/routes/reports.ts:81:          applicationsByDate
server/routes/reports.ts:83:        recentActivity: recentApplications
server/routes/reports.ts:88:    console.error('‚ùå [REPORTS] Error generating pipeline activity report:', error);
server/routes/reports.ts:91:      error: 'Failed to generate pipeline activity report'
server/routes/reports.ts:157:      .leftJoin(applications, eq(documents.applicationId, applications.id))
server/routes/reports.ts:158:      .leftJoin(businesses, eq(applications.businessId, businesses.id))
server/routes/reports.ts:197:      conditions.push(gte(applications.createdAt, new Date(startDate as string)));
server/routes/reports.ts:200:      conditions.push(lte(applications.createdAt, new Date(endDate as string)));
server/routes/reports.ts:206:        status: applications.status,
server/routes/reports.ts:208:        avgLoanAmount: sql<number>`AVG(${applications.loanAmount})`
server/routes/reports.ts:210:      .from(applications)
server/routes/reports.ts:212:      .groupBy(applications.status);
server/routes/reports.ts:217:        leadSource: applications.leadSource,
server/routes/reports.ts:219:        approved: sql<number>`COUNT(CASE WHEN ${applications.stage} = 'New' THEN 1 END)`,
server/routes/reports.ts:220:        rejected: sql<number>`COUNT(CASE WHEN ${applications.status} = 'draft' THEN 1 END)`
server/routes/reports.ts:222:      .from(applications)
server/routes/reports.ts:224:      .groupBy(applications.leadSource);
server/routes/reports.ts:229:        avgDays: sql<number>`AVG(EXTRACT(EPOCH FROM (${applications.updatedAt} - ${applications.createdAt})) / 86400)`,
server/routes/reports.ts:230:        stage: applications.stage
server/routes/reports.ts:232:      .from(applications)
server/routes/reports.ts:235:          sql`${applications.stage} = 'New'`,
server/routes/reports.ts:239:      .groupBy(applications.stage);
server/routes/reports.ts:246:            WHEN ${applications.loanAmount} < 50000 THEN 'Under $50K'
server/routes/reports.ts:247:            WHEN ${applications.loanAmount} < 100000 THEN '$50K - $100K'
server/routes/reports.ts:248:            WHEN ${applications.loanAmount} < 250000 THEN '$100K - $250K'
server/routes/reports.ts:249:            WHEN ${applications.loanAmount} < 500000 THEN '$250K - $500K'
server/routes/reports.ts:255:          AVG(CASE WHEN ${applications.stage} = 'New' THEN 1.0 ELSE 0.0 END) * 100
server/routes/reports.ts:258:      .from(applications)
server/routes/reports.ts:262:          WHEN ${applications.loanAmount} < 50000 THEN 'Under $50K'
server/routes/reports.ts:263:          WHEN ${applications.loanAmount} < 100000 THEN '$50K - $100K'
server/routes/reports.ts:264:          WHEN ${applications.loanAmount} < 250000 THEN '$100K - $250K'
server/routes/reports.ts:265:          WHEN ${applications.loanAmount} < 500000 THEN '$250K - $500K'
server/routes/reports.ts:304:      totalApplications,
server/routes/reports.ts:305:      activeApplications,
server/routes/reports.ts:306:      completedApplications,
server/routes/reports.ts:310:      // Total applications (last 30 days)
server/routes/reports.ts:312:        .from(applications)
server/routes/reports.ts:313:        .where(gte(applications.createdAt, thirtyDaysAgo)),
server/routes/reports.ts:315:      // Active applications (using actual status values)
server/routes/reports.ts:317:        .from(applications)
server/routes/reports.ts:318:        .where(sql`${applications.status} = 'draft' OR ${applications.status} IS NULL`),
server/routes/reports.ts:320:      // Completed applications (last 30 days) - using actual stage values
server/routes/reports.ts:322:        .from(applications)
server/routes/reports.ts:325:            gte(applications.createdAt, thirtyDaysAgo),
server/routes/reports.ts:326:            sql`${applications.stage} = 'New'`
server/routes/reports.ts:337:        date: sql<string>`DATE(${applications.createdAt})`,
server/routes/reports.ts:338:        applications: count()
server/routes/reports.ts:340:        .from(applications)
server/routes/reports.ts:341:        .where(gte(applications.createdAt, sevenDaysAgo))
server/routes/reports.ts:342:        .groupBy(sql`DATE(${applications.createdAt})`)
server/routes/reports.ts:343:        .orderBy(sql`DATE(${applications.createdAt})`)
server/routes/reports.ts:351:          totalApplications: totalApplications[0]?.count || 0,
server/routes/reports.ts:352:          activeApplications: activeApplications[0]?.count || 0,
server/routes/reports.ts:353:          completedApplications: completedApplications[0]?.count || 0,
server/routes/reports.ts:383:      COUNT(*)::int AS total_applications,
server/routes/reports.ts:388:    FROM applications a
server/routes/reports.ts:393:  const conversion = r.total_applications ? (r.approved / r.total_applications) * 100 : 0;
server/routes/reports.ts:395:    totalApplications: r.total_applications,
server/routes/reports.ts:409:           COUNT(*)::int AS applications,
server/routes/reports.ts:411:    FROM applications a
server/routes/reports.ts:418:    month: r.month, applications: r.applications, volume: Math.round(r.volume_cents/100)
server/routes/reports.ts:432:    FROM applications a
server/routes/reports.ts:457:        COUNT(*)::int AS total_applications,
server/routes/reports.ts:460:      FROM applications a
server/routes/reports.ts:470:        totalApplications: result.total_applications || 0,
server/routes/reports.ts:471:        submittedToDocsReceived: Math.floor((result.total_applications || 0) * 0.77),
server/routes/reports.ts:472:        docsReceivedToSentLender: Math.floor((result.total_applications || 0) * 0.52),
server/routes/reports.ts:474:        overallConversionRate: result.total_applications ? 
server/routes/reports.ts:475:          Math.round((result.approved / result.total_applications) * 1000) / 10 : 0,
server/routes/reports.ts:516:        LEFT JOIN applications a ON d.application_id = a.id
server/routes/reports.ts:525:      // Average docs per application
server/routes/reports.ts:531:          LEFT JOIN applications a ON d.application_id = a.id
server/routes/reports.ts:533:          GROUP BY d.application_id
server/routes/reports.ts:589:// Applications endpoint for Reports Tab - NOW DATABASE-DRIVEN
server/routes/reports.ts:590:router.get('/applications', async (req, res) => {
server/routes/reports.ts:592:    console.log('üìä [REPORTS] Generating applications metrics from database');
server/routes/reports.ts:602:      // Core application metrics
server/routes/reports.ts:605:          COUNT(*)::int AS total_applications,
server/routes/reports.ts:611:        FROM applications a
server/routes/reports.ts:618:      // Applications by status
server/routes/reports.ts:623:        FROM applications a
server/routes/reports.ts:636:          COUNT(*)::int AS applications,
server/routes/reports.ts:639:        FROM applications a
server/routes/reports.ts:649:      const totalApps = coreStats.total_applications || 0;
server/routes/reports.ts:655:      const applicationsByStatus = statusRows.map(row => ({
server/routes/reports.ts:663:        applications: row.applications,
server/routes/reports.ts:668:      const applicationMetrics = {
server/routes/reports.ts:669:        totalApplications: totalApps,
server/routes/reports.ts:670:        avgApplicationValue: Math.round((coreStats.avg_amount_cents || 0) / 100),
server/routes/reports.ts:673:        pendingApplications: coreStats.pending_count || 0,
server/routes/reports.ts:675:        applicationsByStatus,
server/routes/reports.ts:676:        applicationsByLoanType: [
server/routes/reports.ts:687:      res.json(applicationMetrics);
server/routes/reports.ts:693:    console.error('‚ùå [REPORTS] Error generating applications metrics:', error);
server/routes/reports.ts:696:      error: 'Failed to generate applications metrics'
server/routes/reports.ts:787:    res.setHeader('Content-Type', 'application/pdf');
server/routes/reports.ts:882:    // Get real application events from database
server/routes/reports.ts:883:    const applicationEvents = await pool.query(`
server/routes/reports.ts:885:        'application_submitted' as name,
server/routes/reports.ts:887:      FROM applications
server/routes/reports.ts:907:    const totalEvents = applicationEvents.rows.reduce((sum, row) => sum + row.count, 0);
server/routes/reports.ts:910:      events: applicationEvents.rows.map(row => ({
server/lib/activities.ts:7:  applicationId?: string;
server/lib/activities.ts:17:      applicationId: input.applicationId ?? null,
server/routes/api/applications.ts:3:import { applications } from '../../db/schema';
server/routes/api/applications.ts:8:const ApplicationSchema = z.object({
server/routes/api/applications.ts:21:    const input = ApplicationSchema.parse(req.body);
server/routes/api/applications.ts:22:    const result = await db.insert(applications).values({
server/routes/api/applications.ts:27:    // ‚úÖ MONITOR: Application received logging
server/routes/api/applications.ts:28:    console.log("‚úÖ [MONITOR] Application received");
server/routes/api/applications.ts:33:    console.log('‚úÖ Application created:', result);
server/routes/api/applications.ts:36:    console.error('‚ùå Application submission error:', err);
server/routes/api/applications.ts:37:    return res.status(400).json({ error: 'Invalid application submission' });
server/routes/voice.ts:89:      outgoingApplicationSid: finalAppSid,
server/routes/api/lenders-reports.ts:4:import { lenders, lenderProducts, applications } from "../../../shared/schema";
server/routes/api/lenders-reports.ts:23:        COUNT(DISTINCT a.id) AS total_applications_sent,
server/routes/api/lenders-reports.ts:32:      FROM applications a
server/routes/api/lenders-reports.ts:42:        total_applications_sent: 0,
server/routes/api/lenders-reports.ts:64:    // Get detailed application data for the lender
server/routes/api/lenders-reports.ts:65:    const applications = await db.execute(sql`
server/routes/api/lenders-reports.ts:74:      FROM applications a
server/routes/api/lenders-reports.ts:81:      const csvHeader = 'Application ID,Business Name,Amount,Status,Created,Updated,Commission\n';
server/routes/api/lenders-reports.ts:82:      const csvRows = applications.map(app => 
server/routes/api/lenders-reports.ts:91:      res.setHeader('Content-Type', 'application/pdf');
server/routes/api/lenders-reports.ts:140:        a.id AS application_id,
server/routes/api/lenders-reports.ts:146:      FROM applications a
server/routes/contacts.actions.ts:34:  // POST /api/contacts/:id/create-application  { amount }
server/routes/contacts.actions.ts:35:  app.post("/api/contacts/:id/create-application", async (req, res) => {
server/routes/contacts.actions.ts:37:      `insert into applications (contact_id, requested_amount, status, created_at)
server/routes/contacts.actions.ts:41:    res.json({ ok: true, applicationId: row?.id });
server/routes/pipeline.board.ts:5:type Card = { id:string; title:string; amount?:number|null; status:string; contact?:string|null };
server/routes/pipeline.board.ts:6:const mem:{cards:Card[]} = global as any;
server/routes/pipeline.board.ts:7:if(!mem.cards){
server/routes/pipeline.board.ts:8:  (global as any).cards = [
server/routes/pipeline.board.ts:20:export function mountPipelineBoard(app:Express){
server/routes/pipeline.board.ts:21:  // Application details endpoint for drawer - COMPREHENSIVE FIELD COVERAGE
server/routes/pipeline.board.ts:22:  app.get('/api/pipeline/cards/:id/application', async (req: Request, res: Response) => {
server/routes/pipeline.board.ts:25:      console.log(`üöÄ [PIPELINE-BOARD] Fetching comprehensive application details for: ${id}`);
server/routes/pipeline.board.ts:27:      // Get application with fields_canonical data - handle UUID vs external_id
server/routes/pipeline.board.ts:31:        q = `SELECT * FROM applications WHERE id = $1::uuid LIMIT 1`;
server/routes/pipeline.board.ts:35:        q = `SELECT * FROM applications WHERE external_id = $1 LIMIT 1`;
server/routes/pipeline.board.ts:40:      if (!row) return res.status(404).json({ error: 'Application not found' });
server/routes/pipeline.board.ts:50:      const application = {
server/routes/pipeline.board.ts:98:        creditCards: num(canonical.credit_cards), // frontend expects 'creditCards'
server/routes/pipeline.board.ts:106:      console.log(`‚úÖ [PIPELINE-BOARD] Comprehensive data loaded: ${application.businessName} (${Object.keys(application).filter(k => application[k] !== null).length} fields)`);
server/routes/pipeline.board.ts:107:      res.json({ application });
server/routes/pipeline.board.ts:109:      console.error("‚ùå [PIPELINE-BOARD] Error:", error);
server/routes/pipeline.board.ts:110:      return res.status(500).json({ error: "Failed to fetch application data" });
server/routes/pipeline.board.ts:114:  // Documents endpoint for pipeline cards - FIXED PHANTOM DOCUMENTS ISSUE
server/routes/pipeline.board.ts:115:  app.get('/api/pipeline/cards/:id/documents', async (req: Request, res: Response) => {
server/routes/pipeline.board.ts:119:      if (!app) return res.status(404).json({ error: "Application not found" });
server/routes/pipeline.board.ts:129:        WHERE application_id = $1
server/routes/pipeline.board.ts:134:      console.log(`‚úÖ [PIPELINE-BOARD] Found ${rows.length} actual documents for application: ${req.params.id}`);
server/routes/pipeline.board.ts:137:      console.error("‚ùå [PIPELINE-BOARD] Error fetching documents:", error);
server/routes/pipeline.board.ts:142:  app.get('/api/pipeline/board', async (_req: Request, res: Response) => {
server/routes/pipeline.board.ts:162:            WHERE d.application_id = v.id AND d.file_exists = true
server/routes/pipeline.board.ts:164:        FROM v_app_cards v
server/routes/pipeline.board.ts:245:      console.log('üéØ PIPELINE RESPONSE:', {
server/routes/pipeline.board.ts:253:      console.error('‚ùå Pipeline board error:', error);
server/routes/pipeline.board.ts:269:  app.post('/api/pipeline/cards/:id/move', async (req:Request,res:Response)=>{
server/routes/pipeline.board.ts:276:      // Update in database if it's a real application
server/routes/pipeline.board.ts:278:      await pool.query('UPDATE applications SET status = $1, updated_at = NOW() WHERE id = $2', [to, id]);
server/routes/pipeline.board.ts:280:      // Broadcast pipeline update
server/routes/pipeline.board.ts:281:      const { broadcastPipelineUpdate } = await import('../websocket');
server/routes/pipeline.board.ts:282:      broadcastPipelineUpdate(id, 'moved');
server/routes/pipeline.board.ts:284:      res.json({ ok:true, message: `Moved to ${to}`, applicationId: id });
server/routes/pipeline.board.ts:286:      // Fallback to in-memory cards for demo cards
server/routes/pipeline.board.ts:287:      const cards:Card[] = (global as any).cards;
server/routes/pipeline.board.ts:288:      const idx = cards.findIndex(c=>c.id===id);
server/routes/pipeline.board.ts:290:      cards[idx] = { ...cards[idx], status: to };
server/routes/pipeline.board.ts:293:        const { broadcastPipelineUpdate } = await import('../websocket');
server/routes/pipeline.board.ts:294:        broadcastPipelineUpdate(id, 'moved');
server/routes/pipeline.board.ts:299:      res.json({ ok:true, item: cards[idx] });
server/routes/comms/outbox.ts:35:        method:"POST", headers:{ "Content-Type":"application/json" },
server/routes/comms/outbox.ts:40:        method:"POST", headers:{ "Content-Type":"application/json" },
server/routes/comms/outbox.ts:82:      method:"POST", headers:{ "Content-Type":"application/json" },
server/routes/comms/outbox.ts:89:      method:"POST", headers:{ "Content-Type":"application/json" },
server/conflicts/collectSourcedValues.ts:6:export async function collectSourcedValues(applicationId: string): Promise<SourcedValue[]> {
server/conflicts/collectSourcedValues.ts:11:    // 1) Client Application profile - get from applications table
server/conflicts/collectSourcedValues.ts:21:      FROM applications WHERE id = $1 LIMIT 1;
server/conflicts/collectSourcedValues.ts:22:    `, [applicationId])).rows[0];
server/conflicts/collectSourcedValues.ts:31:            sourceId: 'client_application', 
server/conflicts/collectSourcedValues.ts:32:            label: 'Client Application',
server/conflicts/collectSourcedValues.ts:41:      SELECT financials_ocr, updated_at FROM applications WHERE id = $1 AND financials_ocr IS NOT NULL LIMIT 1;
server/conflicts/collectSourcedValues.ts:42:    `, [applicationId])).rows[0];
server/conflicts/collectSourcedValues.ts:63:      SELECT banking_analysis, updated_at FROM applications WHERE id = $1 AND banking_analysis IS NOT NULL LIMIT 1;
server/conflicts/collectSourcedValues.ts:64:    `, [applicationId])).rows[0];
server/conflicts/collectSourcedValues.ts:78:    if (applicationId === 'demo' || applicationId.includes('test') || applicationId.includes('sample')) {
server/routes/application-details.ts:7:// Application details endpoint for pipeline cards
server/routes/application-details.ts:8:router.get("/api/pipeline/cards/:id/application", async (req, res) => {
server/routes/application-details.ts:10:    // Direct database lookup for the application
server/routes/application-details.ts:12:    console.log(`üöÄ [APPLICATION-DETAILS] Fetching data for: ${id}`);
server/routes/application-details.ts:15:      SELECT * FROM applications WHERE id = ${id}::uuid LIMIT 1
server/routes/application-details.ts:18:    console.log(`üîç [APPLICATION-DETAILS] Query result:`, result.length, 'rows');
server/routes/application-details.ts:20:      console.log(`üîç [APPLICATION-DETAILS] First row keys:`, Object.keys(result[0]));
server/routes/application-details.ts:21:      console.log(`üîç [APPLICATION-DETAILS] Sample fields:`, {
server/routes/application-details.ts:31:      console.log(`‚ùå [APPLICATION-DETAILS] Application not found: ${id}`);
server/routes/application-details.ts:32:      return res.status(404).json({ error: "Application not found" });
server/routes/application-details.ts:37:    console.log(`‚úÖ [APPLICATION-DETAILS] Found: ${businessName} (ID: ${app?.id})`);
server/routes/application-details.ts:41:      application: {
server/routes/application-details.ts:54:    console.error("‚ùå [APPLICATION-DETAILS] Error:", error);
server/routes/application-details.ts:55:    return res.status(500).json({ error: "Failed to fetch application data" });
server/routes/application-details.ts:59:// Documents endpoint for pipeline cards
server/routes/application-details.ts:60:router.get("/api/pipeline/cards/:id/documents", async (req, res) => {
server/routes/application-details.ts:63:    console.log(`üìÑ [APPLICATION-DETAILS] Fetching documents for: ${id}`);
server/routes/application-details.ts:68:      WHERE application_id = ${id}::uuid
server/routes/application-details.ts:72:    console.log(`‚úÖ [APPLICATION-DETAILS] Found ${documentsResult.length} documents for application: ${id}`);
server/routes/application-details.ts:75:    console.error("‚ùå [APPLICATION-DETAILS] Error fetching documents:", error);
server/routes/comms/automations.ts:83:    const { applicationId } = req.body;
server/routes/comms/automations.ts:85:    // Find applications with missing documents
server/routes/comms/automations.ts:86:    const apps = applicationId 
server/routes/comms/automations.ts:87:      ? await q<any>(`SELECT id, contact_id FROM applications WHERE id=$1`, [applicationId])
server/routes/comms/automations.ts:90:          FROM applications a
server/routes/comms/automations.ts:94:            WHERE d.application_id = a.id AND d.status IN ('uploaded', 'rejected')
server/routes/comms/automations.ts:113:        targetType: "application",
server/conflicts/sourceTypes.ts:8:  label?: string;                 // human label (e.g., "Income Statement", "Client Application")
server/routes/staff/pipeline.ts:3:import { PIPELINE_STAGES, normalizeStage, PipelineStage } from "../../services/pipeline";
server/routes/staff/pipeline.ts:4:import { notifyPipelineUpdate } from "../../websocket";
server/routes/staff/pipeline.ts:10:    CREATE TABLE IF NOT EXISTS pipeline_activity (
server/routes/staff/pipeline.ts:12:      application_id VARCHAR(64) NOT NULL,
server/routes/staff/pipeline.ts:22:function mapRowToCard(row: any) {
server/routes/staff/pipeline.ts:25:    title: row.business_name || row.title || "Untitled Application",
server/routes/staff/pipeline.ts:32:// Columns with cards
server/routes/staff/pipeline.ts:33:r.get("/pipeline", async (_req: Request, res: Response) => {
server/routes/staff/pipeline.ts:37:    FROM applications a
server/routes/staff/pipeline.ts:41:  const columns = PIPELINE_STAGES.map(c => ({ id: c.id, label: c.label, items: [] as any[] }));
server/routes/staff/pipeline.ts:42:  const byId: Record<PipelineStage, any> = Object.fromEntries(columns.map(c => [c.id, c]));
server/routes/staff/pipeline.ts:44:    const st = (byId[row.status as PipelineStage] ? row.status : "new") as PipelineStage;
server/routes/staff/pipeline.ts:45:    byId[st].items.push(mapRowToCard({ ...row, status: st }));
server/routes/staff/pipeline.ts:51:r.post("/pipeline/move", async (req: Request, res: Response) => {
server/routes/staff/pipeline.ts:52:  const { applicationId, toStage, note } = req.body || {};
server/routes/staff/pipeline.ts:53:  if (!applicationId) return res.status(400).json({ error: "missing_applicationId" });
server/routes/staff/pipeline.ts:54:  let target: PipelineStage;
server/routes/staff/pipeline.ts:57:  const q = await pool.query(`SELECT id, stage as status FROM applications WHERE id = $1::uuid`, [applicationId]);
server/routes/staff/pipeline.ts:58:  if (!q.rows.length) return res.status(404).json({ error: "application_not_found" });
server/routes/staff/pipeline.ts:61:  await pool.query(`UPDATE applications SET stage = $1 WHERE id = $2::uuid`, [target, applicationId]);
server/routes/staff/pipeline.ts:63:    `INSERT INTO pipeline_activity (application_id, from_stage, to_stage, note) VALUES ($1,$2,$3,$4)`,
server/routes/staff/pipeline.ts:64:    [applicationId, from || null, target, note || null]
server/routes/staff/pipeline.ts:69:    notifyPipelineUpdate();
server/routes/staff/pipeline.ts:70:    console.log(`[WebSocket] Pipeline update broadcast for app ${applicationId}: ${from} ‚Üí ${target}`);
server/routes/staff/pipeline.ts:72:    console.warn('[WebSocket] Failed to broadcast pipeline update:', err);
server/routes/staff/pipeline.ts:79:r.get("/pipeline/metrics", async (_req: Request, res: Response) => {
server/routes/staff/pipeline.ts:80:  const { rows } = await pool.query(`SELECT LOWER(status) AS stage, COUNT(*)::int AS count FROM applications GROUP BY LOWER(status)`);
server/routes/staff/pipeline.ts:81:  const counts: Record<string, number> = Object.fromEntries(PIPELINE_STAGES.map(s => [s.id, 0]));
server/routes/staff/pipeline.ts:88:r.get("/pipeline/activity", async (req: Request, res: Response) => {
server/routes/staff/pipeline.ts:89:  const id = String(req.query.applicationId || "");
server/routes/staff/pipeline.ts:90:  if (!id) return res.status(400).json({ error: "missing_applicationId" });
server/routes/staff/pipeline.ts:93:    `SELECT id, application_id, from_stage, to_stage, actor, note, created_at
server/routes/staff/pipeline.ts:94:       FROM pipeline_activity
server/routes/staff/pipeline.ts:95:      WHERE application_id = $1
server/banking/banking_analysis.schema.json:5:  "required": ["applicationId", "periodStart", "periodEnd", "nsf"],
server/banking/banking_analysis.schema.json:7:    "applicationId": { "type": "string" },
server/routes/staff/applications.ts:7:r.get("/applications/:id", async (req: Request, res: Response) => {
server/routes/staff/applications.ts:13:    FROM applications a
server/routes/staff/applications.ts:18:  if (!appQ.rows.length) return res.status(404).json({ error: "application_not_found" });
server/routes/staff/applications.ts:22:    `SELECT COUNT(*)::int AS count FROM documents WHERE application_id = $1 AND status IN ('pending','accepted')`,
server/routes/staff/applications.ts:26:    `SELECT id, application_id, from_stage, to_stage, actor, note, created_at
server/routes/staff/applications.ts:27:       FROM pipeline_activity
server/routes/staff/applications.ts:28:      WHERE application_id = $1
server/routes/bf/applications.ts:3:import { applications, documents } from '../../../shared/schema';
server/routes/bf/applications.ts:8:// Get BF-specific applications
server/routes/bf/applications.ts:11:    console.log('üìã [BF-APPLICATIONS] Fetching BF applications');
server/routes/bf/applications.ts:15:        id: applications.id,
server/routes/bf/applications.ts:16:        firstName: applications.contactFirstName,
server/routes/bf/applications.ts:17:        lastName: applications.contactLastName,
server/routes/bf/applications.ts:18:        email: applications.contactEmail,
server/routes/bf/applications.ts:19:        phoneNumber: applications.contactPhone,
server/routes/bf/applications.ts:20:        businessName: applications.legalBusinessName,
server/routes/bf/applications.ts:21:        loanAmount: applications.loanAmount,
server/routes/bf/applications.ts:22:        loanPurpose: applications.useOfFunds,
server/routes/bf/applications.ts:23:        currentStage: applications.stage,
server/routes/bf/applications.ts:24:        status: applications.status,
server/routes/bf/applications.ts:25:        createdAt: applications.createdAt,
server/routes/bf/applications.ts:26:        updatedAt: applications.updatedAt
server/routes/bf/applications.ts:28:      .from(applications)
server/routes/bf/applications.ts:29:      .orderBy(desc(applications.createdAt));
server/routes/bf/applications.ts:31:    console.log(`üìã [BF-APPLICATIONS] Found ${result.length} BF applications`);
server/routes/bf/applications.ts:35:      applications: result,
server/routes/bf/applications.ts:39:    console.error('‚ùå [BF-APPLICATIONS] Error fetching BF applications:', error);
server/routes/bf/applications.ts:42:      error: 'Failed to fetch BF applications'
server/routes/bf/applications.ts:47:// Get specific BF application by ID
server/routes/bf/applications.ts:52:    console.log(`üìã [BF-APPLICATIONS] Fetching BF application: ${id}`);
server/routes/bf/applications.ts:54:    const applicationResult = await db
server/routes/bf/applications.ts:56:        id: applications.id,
server/routes/bf/applications.ts:57:        firstName: applications.contactFirstName,
server/routes/bf/applications.ts:58:        lastName: applications.contactLastName,
server/routes/bf/applications.ts:59:        email: applications.contactEmail,
server/routes/bf/applications.ts:60:        phoneNumber: applications.contactPhone,
server/routes/bf/applications.ts:61:        businessName: applications.legalBusinessName,
server/routes/bf/applications.ts:62:        loanAmount: applications.loanAmount,
server/routes/bf/applications.ts:63:        loanPurpose: applications.useOfFunds,
server/routes/bf/applications.ts:64:        currentStage: applications.stage,
server/routes/bf/applications.ts:65:        status: applications.status,
server/routes/bf/applications.ts:66:        createdAt: applications.createdAt,
server/routes/bf/applications.ts:67:        updatedAt: applications.updatedAt
server/routes/bf/applications.ts:69:      .from(applications)
server/routes/bf/applications.ts:70:      .where(eq(applications.id, id));
server/routes/bf/applications.ts:72:    if (applicationResult.length === 0) {
server/routes/bf/applications.ts:75:        error: 'BF application not found'
server/routes/bf/applications.ts:89:      .where(eq(documents.applicationId, id))
server/routes/bf/applications.ts:92:    const application = {
server/routes/bf/applications.ts:93:      ...applicationResult[0],
server/routes/bf/applications.ts:99:      application
server/routes/bf/applications.ts:102:    console.error('‚ùå [BF-APPLICATIONS] Error fetching BF application:', error);
server/routes/bf/applications.ts:105:      error: 'Failed to fetch BF application'
server/banking/analysis.service.ts:9:  applicationId: z.string(),
server/banking/analysis.service.ts:90:export async function buildBankingAnalysis(applicationId: string, periodStart: string, periodEnd: string): Promise<BankingAnalysis> {
server/banking/analysis.service.ts:93:    // Check if we have existing banking analysis data in the applications table
server/banking/analysis.service.ts:95:      SELECT banking_analysis FROM applications WHERE id = $1
server/banking/analysis.service.ts:96:    `, [applicationId]);
server/banking/analysis.service.ts:101:      cached.applicationId = applicationId;
server/banking/analysis.service.ts:110:      applicationId,
server/banking/analysis.service.ts:237:      UPDATE applications 
server/banking/analysis.service.ts:240:    `, [JSON.stringify(sampleData), applicationId]);
server/routes/debug-pipeline.ts:3:export function mountDebugPipeline(app: Express) {
server/routes/debug-pipeline.ts:6:  app.get('/debug-pipeline-data', async (req, res) => {
server/routes/debug-pipeline.ts:10:      // Get basic application data
server/routes/debug-pipeline.ts:20:        FROM applications 
server/routes/debug-pipeline.ts:25:      // Get documents for applications
server/routes/debug-pipeline.ts:28:          application_id,
server/routes/debug-pipeline.ts:44:      // Group documents by application
server/routes/debug-pipeline.ts:47:        if (!docsByApp[doc.application_id]) {
server/routes/debug-pipeline.ts:48:          docsByApp[doc.application_id] = [];
server/routes/debug-pipeline.ts:50:        docsByApp[doc.application_id].push(doc);
server/routes/debug-pipeline.ts:55:        applications: appsResult.rows.map(app => ({
server/routes/debug-pipeline.ts:60:          totalApplications: appsResult.rows.length,
server/routes/debug-pipeline.ts:70:      console.error('Debug pipeline error:', error);
server/routes/debug-pipeline.ts:79:  console.log('‚úÖ Debug pipeline endpoint mounted at /debug-pipeline-data');
server/banking/database-setup.sql:7:    application_id UUID NOT NULL REFERENCES applications(id),
server/banking/database-setup.sql:23:    application_id UUID NOT NULL REFERENCES applications(id),
server/banking/database-setup.sql:31:CREATE INDEX IF NOT EXISTS idx_bank_transactions_app_date ON bank_transactions(application_id, tx_date);
server/banking/database-setup.sql:34:CREATE INDEX IF NOT EXISTS idx_bank_statement_headers_app ON bank_statement_headers(application_id);
server/banking/database-setup.sql:36:-- Note: Currently using applications.banking_analysis JSONB column for demo data
server/routes/test-pipeline.ts:3:export function mountTestPipeline(app: Express) {
server/routes/test-pipeline.ts:4:  // Simple test endpoint for pipeline data
server/routes/test-pipeline.ts:5:  app.get('/api/test-pipeline/simple', async (req, res) => {
server/routes/test-pipeline.ts:17:        FROM applications 
server/routes/test-pipeline.ts:24:          application_id,
server/routes/test-pipeline.ts:41:        applications: appsResult.rows,
server/routes/test-pipeline.ts:44:          totalApplications: appsResult.rows.length,
server/routes/test-pipeline.ts:50:      console.error('Test pipeline error:', error);
server/routes/test-pipeline.ts:58:  console.log('‚úÖ Test pipeline endpoint mounted');
server/routes/slf/contacts.ts:31:          'Accept': 'application/json',
server/routes/staff/index.ts:4:import pipeline from "./pipeline";
server/routes/staff/index.ts:5:import applications from "./applications";
server/routes/staff/index.ts:10:staffRouter.use(pipeline);
server/routes/staff/index.ts:11:staffRouter.use(applications);
server/routes/refresh-application-data.ts:5: * Endpoint to refresh application data and ensure all documents are properly linked
server/routes/refresh-application-data.ts:6: * This will update application cards with complete field information and document status
server/routes/refresh-application-data.ts:8:export function mountRefreshApplicationData(app: Express) {
server/routes/refresh-application-data.ts:11:  app.get('/api/applications/refresh/status', async (req, res) => {
server/routes/refresh-application-data.ts:17:          COUNT(*) as total_applications,
server/routes/refresh-application-data.ts:18:          COUNT(*) FILTER (WHERE status = 'new') as new_applications,
server/routes/refresh-application-data.ts:19:          COUNT(DISTINCT d.application_id) as apps_with_documents
server/routes/refresh-application-data.ts:20:        FROM applications a
server/routes/refresh-application-data.ts:21:        LEFT JOIN documents d ON a.id = d.application_id AND d.file_exists = true
server/routes/refresh-application-data.ts:30:          totalApplications: parseInt(stats.total_applications),
server/routes/refresh-application-data.ts:31:          newApplications: parseInt(stats.new_applications),
server/routes/refresh-application-data.ts:32:          applicationsWithDocuments: parseInt(stats.apps_with_documents)
server/routes/refresh-application-data.ts:40:  // Refresh all application data and fix document associations (public endpoint for maintenance)
server/routes/refresh-application-data.ts:41:  app.post('/api/applications/refresh-all', async (req, res) => {
server/routes/refresh-application-data.ts:45:      // First, ensure all documents are properly associated with applications
server/routes/refresh-application-data.ts:54:      // Get refreshed application data with all fields populated
server/routes/refresh-application-data.ts:88:        FROM applications a
server/routes/refresh-application-data.ts:92:            d.application_id,
server/routes/refresh-application-data.ts:115:                WHERE d2.application_id = d.application_id 
server/routes/refresh-application-data.ts:120:          FULL OUTER JOIN expected_documents ed ON d.application_id = ed.application_id
server/routes/refresh-application-data.ts:121:          WHERE d.file_exists = true OR ed.application_id IS NOT NULL
server/routes/refresh-application-data.ts:122:          GROUP BY d.application_id
server/routes/refresh-application-data.ts:123:        ) doc_stats ON a.id = doc_stats.application_id
server/routes/refresh-application-data.ts:128:      const applications = result.rows;
server/routes/refresh-application-data.ts:130:      // Update applications with refreshed data
server/routes/refresh-application-data.ts:131:      const updatePromises = applications.map(async (app) => {
server/routes/refresh-application-data.ts:133:          UPDATE applications 
server/routes/refresh-application-data.ts:151:        message: 'Application data refreshed successfully',
server/routes/refresh-application-data.ts:153:          totalApplications: applications.length,
server/routes/refresh-application-data.ts:154:          withDocuments: applications.filter(a => a.document_count > 0).length,
server/routes/refresh-application-data.ts:155:          readyForLenders: applications.filter(a => a.verified_count > 0 && (!a.missing_required || a.missing_required.length === 0)).length,
server/routes/refresh-application-data.ts:156:          totalDocuments: applications.reduce((sum, a) => sum + parseInt(a.document_count), 0)
server/routes/refresh-application-data.ts:158:        applications: applications.map(app => ({
server/routes/refresh-application-data.ts:171:      console.error('Error refreshing application data:', error);
server/routes/refresh-application-data.ts:174:        error: 'Failed to refresh application data',
server/routes/refresh-application-data.ts:180:  // Refresh individual application
server/routes/refresh-application-data.ts:181:  app.post('/api/applications/:id/refresh', async (req, res) => {
server/routes/refresh-application-data.ts:184:      const applicationId = req.params.id;
server/routes/refresh-application-data.ts:186:      // Get complete application data with documents
server/routes/refresh-application-data.ts:205:        FROM applications a
server/routes/refresh-application-data.ts:209:            d.application_id,
server/routes/refresh-application-data.ts:233:                WHERE d2.application_id = d.application_id 
server/routes/refresh-application-data.ts:238:          FULL OUTER JOIN expected_documents ed ON d.application_id = ed.application_id
server/routes/refresh-application-data.ts:239:          WHERE (d.application_id = $1 OR ed.application_id = $1)
server/routes/refresh-application-data.ts:241:          GROUP BY d.application_id
server/routes/refresh-application-data.ts:242:        ) doc_data ON a.id = doc_data.application_id
server/routes/refresh-application-data.ts:246:      const result = await pool.query(query, [applicationId]);
server/routes/refresh-application-data.ts:251:          error: 'Application not found'
server/routes/refresh-application-data.ts:257:      // Update the application with refreshed metadata
server/routes/refresh-application-data.ts:259:        UPDATE applications 
server/routes/refresh-application-data.ts:267:      await pool.query(updateQuery, [applicationId, missingDocs]);
server/routes/refresh-application-data.ts:271:        application: {
server/routes/refresh-application-data.ts:307:      console.error('Error refreshing application:', error);
server/routes/refresh-application-data.ts:310:        error: 'Failed to refresh application',
server/routes/refresh-application-data.ts:316:  console.log('‚úÖ Application refresh endpoints mounted');
server/banking/sql/banking_analysis.sql:2:--    Assumes transactions table columns: application_id, tx_date, amount, description, type ('debit'|'credit')
server/banking/sql/banking_analysis.sql:5:  SELECT application_id, tx_date::date, amount, type, description, lower(coalesce(normalized_description, description)) AS nd
server/banking/sql/banking_analysis.sql:9:  application_id,
server/banking/sql/banking_analysis.sql:18:GROUP BY application_id, date_trunc('month', tx_date)
server/banking/sql/banking_analysis.sql:19:ORDER BY application_id, month;
server/banking/sql/banking_analysis.sql:25:    application_id,
server/banking/sql/banking_analysis.sql:34:    application_id,
server/banking/sql/banking_analysis.sql:42:  GROUP BY application_id, key
server/banking/sql/banking_analysis.sql:47:  application_id,
server/banking/sql/banking_analysis.sql:59:  application_id,
server/routes/staff/lenderProducts.ts:8: * Simple product directory for the Staff UI card list.
server/routes/googleAdsUpload.ts:10:  applicationId: z.string().uuid(),
server/routes/googleAdsUpload.ts:58:    // Get application with click IDs
server/routes/googleAdsUpload.ts:61:      FROM applications WHERE id = $1
server/routes/googleAdsUpload.ts:62:    `, [body.applicationId]);
server/routes/googleAdsUpload.ts:64:    const application = result.rows[0];
server/routes/googleAdsUpload.ts:65:    if (!application) {
server/routes/googleAdsUpload.ts:66:      return res.status(404).json({ error: "application_not_found" });
server/routes/googleAdsUpload.ts:69:    const clickId = application.gclid || application.gbraid || application.wbraid;
server/routes/googleAdsUpload.ts:71:      return res.status(400).json({ error: "no_click_id_on_application" });
server/routes/googleAdsUpload.ts:93:        applicationId: body.applicationId
server/routes/googleAdsUpload.ts:116:        gclid: application.gclid || undefined,
server/routes/googleAdsUpload.ts:117:        gbraid: application.gbraid || undefined,
server/routes/googleAdsUpload.ts:118:        wbraid: application.wbraid || undefined,
server/routes/googleAdsUpload.ts:122:        orderId: body.applicationId
server/routes/googleAdsUpload.ts:134:        "content-type": "application/json" 
server/routes/googleAdsUpload.ts:144:      applicationId: body.applicationId,
server/routes/googleAdsUpload.ts:168:          applicationId: validatedConversion.applicationId, 
server/routes/googleAdsUpload.ts:173:          applicationId: conversion.applicationId, 
server/routes/staff/contacts.ts:8: * Minimal contact cards used by the Staff UI (left list + details).
server/routes/staff/contacts.ts:34:        SELECT COUNT(*) FROM applications a WHERE a.user_id = u.id
server/routes/staff/contacts.ts:35:      ),0)::int AS "applicationsCount",
server/routes/googleAds.ts:88:    res.send(`<html><body><h2>‚úÖ Google Ads Successfully Linked!</h2><p>You can close this tab and return to the application.</p></body></html>`);
server/routes/googleAds.ts:176:        "content-type": "application/json" 
server/types/ApplicationInput.ts:1:// types/ApplicationInput.ts
server/types/ApplicationInput.ts:2:export interface ApplicationInput {
server/routes/integrations/credit.ts:10:router.post("/pull/:applicationId", async (req:any, res)=>{
server/routes/integrations/credit.ts:12:  const appId = String(req.params.applicationId);
server/routes/integrations/credit.ts:13:  const app = (await db.execute(sql`SELECT id, contact_id FROM applications WHERE id=${appId} LIMIT 1`)).rows?.[0];
server/routes/integrations/credit.ts:14:  if (!app) return res.status(404).json({ error:"application not found" });
server/routes/integrations/credit.ts:20:    case "mock": report = await mock.pullCreditReport({ applicationId: appId, contactId: app.contact_id }); break;
server/routes/integrations/credit.ts:25:    INSERT INTO credit_reports(application_id, provider, bureau_ref, score, score_band, tradelines, inquiries, public_records, raw)
server/routes/integrations/credit.ts:31:    VALUES (${provider}, 'pull', 'ok', 'credit pull complete', ${ { applicationId: appId, reportId: ins.rows?.[0]?.id, score: report.score, score_band: report.score_band } })
server/routes/integrations/credit.ts:37:router.get("/report/:applicationId", async (req, res)=>{
server/routes/integrations/credit.ts:38:  const appId = String((req as any).params.applicationId);
server/routes/integrations/credit.ts:39:  const r = (await db.execute(sql`SELECT * FROM credit_reports WHERE application_id=${appId} ORDER BY created_at DESC LIMIT 1`)).rows?.[0];
server/routes/integrations/tasks.ts:27:          displayName: 'Loan Applications',
server/routes/integrations/tasks.ts:69:          title: 'Review John Doe loan application',
server/routes/integrations/tasks.ts:73:            content: 'Complete review of loan application documents and financial statements',
server/routes/_int.applications.coverage.ts:12:      FROM applications
server/routes/_int.applications.coverage.ts:26:      FROM applications WHERE id = $1
server/routes/_int.applications.coverage.ts:30:    return res.status(404).json({ error: "Application not found" });
server/routes/_int.applications.coverage.ts:40:      COUNT(*) as total_applications,
server/routes/_int.applications.coverage.ts:41:      COUNT(fields_coverage) as mapped_applications,
server/routes/_int.applications.coverage.ts:45:    FROM applications
server/routes/integrations/o365.ts:2:import { ConfidentialClientApplication } from '@azure/msal-node';
server/routes/integrations/o365.ts:15:let msalInstance: ConfidentialClientApplication;
server/routes/integrations/o365.ts:18:  msalInstance = new ConfidentialClientApplication(msalConfig);
server/routes/integrations/calendar.ts:20:          subject: 'Loan Application Review',
server/db/types.ts:25:  application_id?: string;
server/db/types.ts:36:export interface Application { 
server/routes/googleAdsRouter.ts:45:    const r2 = await fetch(TOKEN, { method: "POST", headers:{ "Content-Type":"application/x-www-form-urlencoded" }, body });
server/routes/googleAdsRouter.ts:65:// Overview endpoint with performance cards
server/routes/crm/contacts/twilioLogs.ts:40:        message: 'Welcome to our CRM system! Your loan application is being processed.',
server/routes/linkedin/oauth.ts:50:      headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
server/routes/linkedin/oauth.ts:116:        'Content-Type': 'application/json',
server/routes/composerRouter.ts:3:import { draftReply, wrapUp, cueCards, inmailDraft, docKit } from "../lib/aiProvider";
server/routes/composerRouter.ts:32:/** AI: Draft reply / Wrap-up / Cue cards / LinkedIn draft */
server/routes/composerRouter.ts:35:r.post("/ai/cue-cards", async (req,res)=>{ res.json({ text: await cueCards(req.body||{}) }); });
server/routes/composerRouter.ts:44:    const links = await Promise.all((files||[]).map(async (f:any)=> presignUpload(`uploads/${contact?.id||"anon"}/${Date.now()}-${f.name}`, f.contentType||"application/pdf")));
server/db/schema.ts:22:export const applications = pgTable('applications', {
server/db/schema.ts:32:  applicationId: uuid('application_id').references(()=>applications.id).notNull(),
server/routes/e2eRouter.ts:65:// Create application (minimal)
server/routes/e2eRouter.ts:66:r.post("/applications", async (req, res, next) => {
server/routes/e2eRouter.ts:72:      `insert into applications (id, user_id, status, requested_amount, use_of_funds, created_at, updated_at)
server/routes/e2eRouter.ts:80:// Get application (with documents)
server/routes/e2eRouter.ts:81:r.get("/applications/:id", async (req, res, next) => {
server/routes/e2eRouter.ts:83:    const [app] = await q<any>(`select * from applications where id=$1`, [req.params.id]);
server/routes/e2eRouter.ts:85:    const docs = await q<any>(`select id, application_id, document_type as category, file_type as mime_type, file_size as size_bytes, file_path as s3_key, status from documents where application_id=$1 order by created_at asc`, [req.params.id]);
server/routes/e2eRouter.ts:91:r.post("/applications/:id/documents", upload.single("file"), async (req, res, next) => {
server/routes/e2eRouter.ts:96:    const key = `applications/${req.params.id}/${id}-${req.file.originalname}`;
server/routes/e2eRouter.ts:97:    await s3Put(key, req.file.buffer, req.file.mimetype || "application/octet-stream");
server/routes/e2eRouter.ts:99:      `insert into documents (id, application_id, file_name, file_type, file_size, document_type, file_path)
server/routes/e2eRouter.ts:101:      [id, req.params.id, req.file.originalname, req.file.mimetype || "application/pdf", req.file.size, category.toLowerCase(), key]
server/routes/e2eRouter.ts:110:    const [doc] = await q<any>(`update documents set status='accepted', updated_at=now(), verified_at=now() where id=$1 returning id, application_id`, [req.params.id]);
server/routes/e2eRouter.ts:113:    const pending = await q<any>(`select 1 from documents where application_id=$1 and status <> 'accepted' limit 1`, [doc.application_id]);
server/routes/e2eRouter.ts:115:      await q(`update applications set status='under_review' where id=$1`, [doc.application_id]);
server/routes/e2eRouter.ts:133:r.get("/applications/:id/documents/zip", async (_req, res) => {
server/routes/admin/users.ts:367:      { value: 'staff', label: 'Staff', description: 'Application processing and client management' },
server/routes/admin/lists.ts:24:router.get("/applications", async (req,res)=>{
server/routes/admin/lists.ts:35:  const r = await db.execute(sql`SELECT a.id, a.contact_id, a.status, a.created_at FROM applications a WHERE ${where} ORDER BY a.created_at DESC OFFSET ${offset} LIMIT ${limit}`);
server/routes/admin/lists.ts:39:/* Bulk actions for applications */
server/routes/admin/lists.ts:40:router.post("/applications/bulk/status", async (req,res)=>{
server/routes/admin/lists.ts:44:  await db.execute(sql`UPDATE applications SET status=${status} WHERE id = ANY(${ids}::uuid[])`);
server/routes/admin/lists.ts:51:  if (!q) return res.json({ contacts:[], applications:[], documents:[] });
server/routes/admin/lists.ts:53:  const applications = await db.execute(sql`SELECT id, status FROM applications WHERE id::text LIKE ${"%"+q+"%"} OR lower(status) LIKE ${"%"+q+"%"} ORDER BY created_at DESC LIMIT 10`);
server/routes/admin/lists.ts:55:  res.json({ contacts: contacts.rows||[], applications: applications.rows||[], documents: documents.rows||[] });
server/routes/documents.ts:17:  applicationId: z.string().min(8),
server/routes/documents.ts:42:    const { applicationId, filename, contentType, size } = parsed.data;
server/routes/documents.ts:46:    const key = `apps/${applicationId}/uploads/${Date.now()}_${safeName}`;
server/routes/documents.ts:50:      { applicationId, key, contentType, size: size || 0, filename },
server/routes/documents.ts:121:        applicationId: string;
server/routes/documents.ts:131:    const { applicationId, key, contentType, size, filename } = payload;
server/routes/documents.ts:137:          application_id, storage_key, object_storage_key, mime_type, file_size, 
server/routes/documents.ts:140:          ${applicationId}, ${key}, ${key}, ${contentType}, ${size}, 
server/routes/documents.ts:145:      console.log(`üìù [DOC-COMPLETE] Registered document: ${filename} for application: ${applicationId}`);
server/routes/documents.ts:147:      return res.json({ ok: true, applicationId, key });
server/routes/documents.ts:154:  // GET /api/documents/list?applicationId=UUID  (lists stored objects quickly)
server/routes/documents.ts:156:    const applicationId = `${req.query.applicationId || ""}`;
server/routes/documents.ts:157:    if (!applicationId) return res.status(400).json({ ok: false, error: "MISSING_APPLICATION_ID" });
server/routes/documents.ts:165:        const out = await s3.send(new ListObjectsV2Command({ Bucket: bucket, Prefix: `apps/${applicationId}/uploads/` }));
server/routes/documents.ts:175:      const base = `/tmp/storage/apps/${applicationId}/uploads`;
server/routes/documents.ts:182:          items.push({ key: `apps/${applicationId}/uploads/${f}`, size: s.size, lastModified: s.mtime });
server/routes/admin/documentIntegrity.ts:4:import { checkDocumentIntegrity, cleanupOrphanedDocumentRecords, getApplicationDocumentIntegrity } from '../../utils/documentIntegrity';
server/routes/admin/documentIntegrity.ts:78:// GET /api/admin/documents/integrity/:applicationId - Check integrity for specific application
server/routes/admin/documentIntegrity.ts:79:router.get('/integrity/:applicationId', async (req: any, res: any) => requireRole(['admin']), async (req: RBACRequest, res) => {
server/routes/admin/documentIntegrity.ts:81:    const { applicationId } = req.params;
server/routes/admin/documentIntegrity.ts:83:    if (!applicationId || typeof applicationId !== 'string') {
server/routes/admin/documentIntegrity.ts:84:      return res.status(400).json({ error: 'Invalid application ID' });
server/routes/admin/documentIntegrity.ts:87:    console.log('üîç ADMIN: Checking application document integrity', {
server/routes/admin/documentIntegrity.ts:88:      applicationId,
server/routes/admin/documentIntegrity.ts:93:    const report = await getApplicationDocumentIntegrity(applicationId);
server/routes/admin/documentIntegrity.ts:95:    console.log('‚úÖ ADMIN: Application document integrity check completed', {
server/routes/admin/documentIntegrity.ts:96:      applicationId,
server/routes/admin/documentIntegrity.ts:104:      applicationId,
server/routes/admin/documentIntegrity.ts:110:    console.error('‚ùå ADMIN: Application document integrity check failed:', error);
server/routes/admin/documentIntegrity.ts:112:      error: 'Failed to check application document integrity',
server/db/report-prefs-shim.ts:1:type Pref = { lenderId: string; reports: string[] }; // e.g., ["pipeline","funding","product","declines","geo"]
server/db/report-prefs-shim.ts:5:  get(lenderId:string){ return _prefs.get(lenderId) || { lenderId, reports: ["pipeline","funding","product","declines"] }; },
server/routes/admin/documentAudit.ts:38:          applicationId: file.applicationId,
server/routes/pipeline/bulk-operations.ts:4:import { applications, comms } from "../../db/schema";
server/routes/pipeline/bulk-operations.ts:10:// Bulk move applications to stage
server/routes/pipeline/bulk-operations.ts:13:    const { applicationIds, targetStage, reason } = req.body;
server/routes/pipeline/bulk-operations.ts:15:    if (!Array.isArray(applicationIds) || applicationIds.length === 0) {
server/routes/pipeline/bulk-operations.ts:16:      return res.status(400).json({ ok: false, error: "No applications selected" });
server/routes/pipeline/bulk-operations.ts:21:    for (const appId of applicationIds) {
server/routes/pipeline/bulk-operations.ts:24:        stageGateErrors.push({ applicationId: appId, error: validation.error });
server/routes/pipeline/bulk-operations.ts:36:    // Update applications
server/routes/pipeline/bulk-operations.ts:37:    await db.update(applications)
server/routes/pipeline/bulk-operations.ts:42:      .where(inArray(applications.id, applicationIds));
server/routes/pipeline/bulk-operations.ts:45:    for (const appId of applicationIds) {
server/routes/pipeline/bulk-operations.ts:47:        applicationId: appId,
server/routes/pipeline/bulk-operations.ts:50:        body: `Application moved to ${targetStage} via bulk operation${reason ? `: ${reason}` : ''}`,
server/routes/pipeline/bulk-operations.ts:55:    res.json({ ok: true, updated: applicationIds.length });
server/routes/pipeline/bulk-operations.ts:65:    const { applicationIds, lenderId } = req.body;
server/routes/pipeline/bulk-operations.ts:68:      UPDATE applications 
server/routes/pipeline/bulk-operations.ts:71:      WHERE id = ANY(${applicationIds})
server/routes/pipeline/bulk-operations.ts:74:    res.json({ ok: true, updated: applicationIds.length });
server/routes/pipeline/bulk-operations.ts:83:    const { applicationIds, permanent = false } = req.body;
server/routes/pipeline/bulk-operations.ts:86:      await db.execute(sql`DELETE FROM applications WHERE id = ANY(${applicationIds})`);
server/routes/pipeline/bulk-operations.ts:88:      await db.update(applications)
server/routes/pipeline/bulk-operations.ts:90:        .where(inArray(applications.id, applicationIds));
server/routes/pipeline/bulk-operations.ts:93:    res.json({ ok: true, archived: applicationIds.length });
server/routes/pipeline/bulk-operations.ts:99:async function validateStageGate(applicationId: string, targetStage: string): Promise<{valid: boolean, error?: string}> {
server/routes/pipeline/bulk-operations.ts:108:        WHERE application_id = ${applicationId}
server/routes/pipeline/bulk-operations.ts:121:      const [app] = await db.select().from(applications).where(sql`id = ${applicationId}`);
server/routes/systemKpis.ts:9:    const appsResult = await pool.query(`SELECT COUNT(*) as count FROM applications`);
server/routes/systemKpis.ts:17:    console.log(`üìä [KPIs] Real data: ${apps} applications, ${contacts} contacts, ${lenders} lender products`);
server/routes/systemKpis.ts:21:      applications: apps, 
server/routes/systemKpis.ts:26:          label: 'Active Applications',
server/routes/systemKpis.ts:81:      FROM applications
server/routes/systemKpis.ts:110:      FROM applications ORDER BY created_at DESC LIMIT 10
server/routes/systemKpis.ts:115:      type: 'application',
server/routes/systemKpis.ts:116:      title: `Application Submitted`,
server/routes/systemKpis.ts:122:    console.log(`üìä [ACTIVITY] Real data: ${activities.length} recent activities from applications`);
server/routes/systemKpis.ts:126:      applications: appsResult.rows,
server/routes/public/applications.ts:56:router.post("/applications", async (req: Request, res: Response) => {
server/routes/public/applications.ts:58:    console.log("üìù Received application:", req.body);
server/routes/public/applications.ts:102:      // Create application (legacy) - STRICT VALIDATION: NO PLACEHOLDERS
server/routes/public/applications.ts:125:        INSERT INTO applications (
server/routes/public/applications.ts:136:      const applicationId = rApp.rows[0].id;
server/routes/public/applications.ts:137:      console.log(`‚úÖ Created legacy application ${applicationId} for ${businessName}`);
server/routes/public/applications.ts:141:        id: applicationId,
server/routes/public/applications.ts:149:    // Minimal: upsert user then create application
server/routes/public/applications.ts:160:      INSERT INTO applications (user_id, business_name, funding_amount, purpose, country, currency, status, created_at, updated_at)
server/routes/public/applications.ts:165:    const applicationId = app.rows[0].id;
server/routes/public/applications.ts:169:      `[APPROVAL] New application submitted: ${step3.businessName} (${applicationId}) ‚Äî OK to notify client?`
server/routes/public/applications.ts:172:    console.log(`‚úÖ Created canonical application ${applicationId} for ${step3.businessName}`);
server/routes/public/applications.ts:175:      applicationId, 
server/routes/public/applications.ts:180:    console.error("‚ùå Application creation error:", error);
server/routes/marketing/email.ts:82:        bodyHtml: '<h2>Welcome {firstName}!</h2><p>Thanks for your interest in equipment financing. Our team will review your application and get back to you within 24 hours.</p><p><a href="https://portal.capitalfinance.com/status">Check Application Status</a></p>',
server/routes/marketing/email.ts:83:        bodyText: 'Welcome {firstName}! Thanks for your interest in equipment financing. Our team will review your application and get back to you within 24 hours. Check status at: https://portal.capitalfinance.com/status',
server/routes/marketing/email.ts:85:        triggerEvent: 'application_submitted',
server/routes/marketing/email.ts:104:        subject: 'Documents Needed for {companyName} Application',
server/routes/marketing/email.ts:105:        bodyHtml: '<h2>Hi {firstName},</h2><p>We\'re reviewing your application for {companyName}. To complete the process, we need:</p><ul><li>Tax returns (last 2 years)</li><li>Bank statements (last 3 months)</li><li>Equipment quote</li></ul><p><a href="https://portal.capitalfinance.com/upload">Upload Documents</a></p>',
server/routes/marketing/email.ts:106:        bodyText: 'Hi {firstName}, We\'re reviewing your application for {companyName}. To complete the process, we need: Tax returns (last 2 years), Bank statements (last 3 months), Equipment quote. Upload at: https://portal.capitalfinance.com/upload',
server/routes/ai.ts:39:      FROM applications WHERE id = ${appId}
server/routes/ai.ts:41:    if (!result.rows?.[0]) throw new Error("application_not_found");
server/routes/ai.ts:44:    throw new Error("application_not_found");
server/routes/ai.ts:52:      FROM documents WHERE application_id = ${appId} ORDER BY uploaded_at DESC
server/routes/ai.ts:71:      INSERT INTO timeline_events (application_id, type, payload, created_at)
server/routes/ai.ts:164:    const applicationId = String(req.query.applicationId || "");
server/routes/ai.ts:165:    if (!applicationId) return fail(res, "missing_applicationId");
server/routes/ai.ts:167:    const app = await getApp(applicationId);
server/routes/ai.ts:168:    const docs = await getDocs(applicationId);
server/routes/ai.ts:204:    respond(res, { applicationId, required: [...required], present: [...present], missing, quality });
server/routes/ai.ts:207:    await writeTimeline(applicationId, 'ai.docs.scan', { missing, quality, ts: new Date().toISOString() });
server/routes/ai.ts:216:    const { applicationId } = req.body || {};
server/routes/ai.ts:217:    if (!applicationId) return fail(res, "missing_applicationId");
server/routes/ai.ts:219:    const app = await getApp(applicationId);
server/routes/ai.ts:220:    const docs = await getDocs(applicationId);
server/routes/ai.ts:235:    respond(res, { applicationId, issues });
server/routes/ai.ts:237:    await writeTimeline(applicationId, 'ai.docs.validate', { issues, ts: new Date().toISOString() });
server/routes/ai.ts:246:    const { applicationId } = req.body || {};
server/routes/ai.ts:247:    if (!applicationId) return fail(res, "missing_applicationId");
server/routes/ai.ts:249:    const app = await getApp(applicationId);
server/routes/ai.ts:258:        SELECT features_json FROM bank_features WHERE application_id = ${applicationId}
server/routes/ai.ts:274:    respond(res, { applicationId, score, dscr, volatility, buffers });
server/routes/ai.ts:276:    await writeTimeline(applicationId, 'ai.fin.score', { score, dscr, volatility, buffers, ts: new Date().toISOString() });
server/routes/ai.ts:285:    const { applicationId, lenderId } = req.body || {};
server/routes/ai.ts:286:    if (!applicationId) return fail(res, "missing_applicationId");
server/routes/ai.ts:288:    const app = await getApp(applicationId);
server/routes/ai.ts:298:    respond(res, { applicationId, lenderId, probability: Number(prob.toFixed(2)), etaDays });
server/routes/ai.ts:300:    await writeTimeline(applicationId, 'ai.approval', { lenderId, probability: prob, etaDays, ts: new Date().toISOString() });
server/routes/ai.ts:309:    const { applicationId } = req.body || {};
server/routes/ai.ts:310:    if (!applicationId) return fail(res, "missing_applicationId");
server/routes/ai.ts:320:    respond(res, { applicationId, etaDays, steps });
server/routes/ai.ts:322:    await writeTimeline(applicationId, 'ai.timeline', { etaDays, steps, ts: new Date().toISOString() });
server/routes/ai.ts:331:    const { applicationId } = req.body || {};
server/routes/ai.ts:332:    if (!applicationId) return fail(res, "missing_applicationId");
server/routes/ai.ts:335:    const app = await getApp(applicationId);
server/routes/ai.ts:336:    const docs = await getDocs(applicationId);
server/routes/ai.ts:342:    respond(res, { applicationId, priority });
server/routes/ai.ts:344:    await writeTimeline(applicationId, 'ai.ops.priority', { priority, ts: new Date().toISOString() });
server/routes/ai.ts:353:    const { applicationId } = req.body || {};
server/routes/ai.ts:354:    if (!applicationId) return fail(res, "missing_applicationId");
server/routes/ai.ts:360:        INSERT INTO credit_summaries (id, application_id, status, payload, created_at)
server/routes/ai.ts:361:        VALUES (${id}, ${applicationId}, 'draft', ${JSON.stringify({ sections: ["Overview","Financials","Risks","Recommendations"] })}, ${new Date()})
server/routes/ai.ts:367:    respond(res, { applicationId, id, url: `/staff/credit-summaries/${id}/edit` });
server/routes/ai.ts:369:    await writeTimeline(applicationId, 'ai.credit.summary', { id, ts: new Date().toISOString() });
server/routes/ai.ts:395:    const { applicationId, intent } = parsed.data;
server/routes/ai.ts:398:    const result = await aiComposeEmail({ applicationId, intent });
server/routes/ai.ts:407:    await writeTimeline(applicationId, 'ai.compose.email', { 
server/routes/ai.ts:413:    console.error(`[AI] Email composition failed for ${req.body?.applicationId}:`, e.message);
server/routes/ai.ts:429:    const { applicationId, intent } = parsed.data;
server/routes/ai.ts:432:    const result = await aiComposeSMS({ applicationId, intent });
server/routes/ai.ts:440:    await writeTimeline(applicationId, 'ai.compose.sms', { 
server/routes/ai.ts:446:    console.error(`[AI] SMS composition failed for ${req.body?.applicationId}:`, e.message);
server/routes/ai.ts:453:  const { applicationId, contactId } = req.body || {};
server/routes/ai.ts:454:  if (!applicationId) return fail(res, "missing_applicationId");
server/routes/public/documentsZip.ts:8:r.get("/applications/:id/documents.zip", async (req: Request, res: Response) => {
server/routes/public/documentsZip.ts:13:      WHERE application_id = $1
server/routes/public/documentsZip.ts:20:  res.setHeader("Content-Type", "application/zip");
server/routes/public/documentsZip.ts:21:  res.setHeader("Content-Disposition", `attachment; filename="application_${appId}_documents.zip"`);
server/routes/public/documentsZip.ts:28:    "# Application documents manifest",
server/routes/public/documentsZip.ts:29:    `applicationId=${appId}`,
server/db/pipeline-shim.ts:1:import { ApplicationCard, AppDocMeta, PipelineStage, StageTransition } from "../domain/pipeline";
server/db/pipeline-shim.ts:3:const _apps = new Map<string, ApplicationCard>();
server/db/pipeline-shim.ts:63:export const pipeline = {
server/db/pipeline-shim.ts:64:  async list(): Promise<Record<PipelineStage, ApplicationCard[]>> {
server/db/pipeline-shim.ts:65:    const by: Record<PipelineStage, ApplicationCard[]> = {
server/db/pipeline-shim.ts:75:  async upsert(app: ApplicationCard) {
server/db/pipeline-shim.ts:79:  async move(appId: string, to: PipelineStage, reason?: string, actor?: string) {
server/routes/public/documents.ts:10:  applicationId: z.string(),
server/routes/public/documents.ts:28:    const { applicationId, filename, contentType, sha256, category } = parsed.data;
server/routes/public/documents.ts:32:    const objectKey = `apps/${applicationId}/${Date.now()}-${safeName}`;
server/routes/public/documents.ts:40:      applicationId, 
server/routes/public/documents.ts:63:    const { applicationId, filename, contentType, sha256, category, objectKey } = parsed.data;
server/routes/public/documents.ts:68:        id, application_id, file_name, document_type, 
server/routes/public/documents.ts:73:    `, [applicationId, filename, category, objectKey, sha256, contentType]);
server/routes/public/documents.ts:76:    console.log(`‚úÖ Document confirmed: ${documentId} for application ${applicationId}`);
server/routes/public/documents.ts:91:router.get("/applications/:id/documents.zip", async (req: Request, res: Response) => {
server/routes/public/documents.ts:93:    const { id: applicationId } = req.params;
server/routes/public/documents.ts:95:    // Get documents for this application
server/routes/public/documents.ts:99:      WHERE application_id = $1 
server/routes/public/documents.ts:101:    `, [applicationId]);
server/routes/public/documents.ts:108:    res.setHeader('Content-Type', 'application/zip');
server/routes/public/documents.ts:109:    res.setHeader('Content-Disposition', `attachment; filename="app-${applicationId}-documents.zip"`);
server/db/communications-shim.ts:21:      { id: "m3", type: "email", direction: "outbound", at: new Date(Date.now()-900000).toISOString(), text: "Follow-up email with details", subject: "Your Application Status" },
server/db/communications-shim.ts:39:      { id: "t2", kind: "email", name: "Welcome", subject: "Welcome to Boreal Financial", body: "Thanks for applying with Boreal Financial. We're reviewing your application and will be in touch soon." },
server/db/communications-shim.ts:40:      { id: "t3", kind: "sms", name: "Follow Up", body: "Just checking in on your application status. Any questions? Call us at (825) 451-1768." },
server/db/communications-shim.ts:41:      { id: "t4", kind: "email", name: "Document Request", subject: "Additional Documents Needed", body: "Please provide the following documents to complete your application: bank statements, proof of income, and ID verification." },
server/db/communications-shim.ts:42:      { id: "t5", kind: "sms", name: "Application Approved", body: "Congratulations! Your application has been approved. Please call (825) 451-1768 to finalize next steps." },
server/db/communications-shim.ts:43:      { id: "t6", kind: "email", name: "Status Update", subject: "Application Status Update", body: "Your application is progressing well. We'll contact you within 24-48 hours with next steps." }
server/routes/dashboard-api.ts:9:      label: 'Active Applications',
server/routes/dashboard-api.ts:37:      label: 'Pipeline Value',
server/routes/dashboard-api.ts:64:      type: 'application',
server/routes/dashboard-api.ts:65:      title: 'New Application Submitted',
server/routes/dashboard-api.ts:109:      type: 'application',
server/routes/dashboard-api.ts:110:      title: 'Application Approved',
server/routes/dashboard-api.ts:146:    urgent_applications: 2,
server/routes/dashboard-api.ts:166:    urgent_applications: 2,
server/routes/dashboard-api.ts:188:      applications: {
server/routes/dashboard-api.ts:210:      applications_by_week: [12, 18, 23, 19],
server/routes/dashboard-api.ts:215:      { name: 'Sarah Wilson', applications: 34, funding: 2100000 },
server/routes/dashboard-api.ts:216:      { name: 'Mike Chen', applications: 28, funding: 1800000 },
server/routes/dashboard-api.ts:217:      { name: 'Alex Rodriguez', applications: 27, funding: 1650000 }
server/routes/dashboard-api.ts:222:        message: '2 applications approaching SLA deadline',
server/routes/dashboard-api.ts:223:        action: 'Review applications'
server/routes/dashboard-api.ts:248:      applications_processed: 23,
server/routes/dashboard-api.ts:265:      monthly_applications: { target: 25, actual: 23, percentage: 92 },
server/routes/public/applications_documents.ts:2: * üîó PUBLIC APPLICATIONS DOCUMENT UPLOAD ROUTE
server/routes/public/applications_documents.ts:4: * Implements the missing /api/public/applications/:id/documents endpoint
server/routes/public/applications_documents.ts:23:      'application/pdf',
server/routes/public/applications_documents.ts:24:      'application/msword',
server/routes/public/applications_documents.ts:25:      'application/vnd.openxmlformats-officedocument.wordprocessingml.document',
server/routes/public/applications_documents.ts:26:      'application/vnd.ms-excel',
server/routes/public/applications_documents.ts:27:      'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet',
server/routes/public/applications_documents.ts:32:      'application/octet-stream' // Allow generic binary files (includes PDFs that don't detect properly)
server/routes/public/applications_documents.ts:50:// POST /api/public/applications/:id/documents - Document Upload with S3
server/routes/public/applications_documents.ts:52:  const { id: applicationId } = req.params;
server/routes/public/applications_documents.ts:57:    console.log(`[UPLOAD] Received document for application ${applicationId}`);
server/routes/public/applications_documents.ts:77:    // Validate application ID format
server/routes/public/applications_documents.ts:79:    if (!uuidRegex.test(applicationId)) {
server/routes/public/applications_documents.ts:82:        error: 'Invalid application ID format',
server/routes/public/applications_documents.ts:83:        code: 'INVALID_APPLICATION_ID'
server/routes/public/applications_documents.ts:87:    // Check if application exists and get current status
server/routes/public/applications_documents.ts:89:    const { applications, documents } = await import('../../../shared/schema.js');
server/routes/public/applications_documents.ts:96:      FROM applications a
server/routes/public/applications_documents.ts:97:      LEFT JOIN documents d ON d.application_id = a.id
server/routes/public/applications_documents.ts:98:      WHERE a.id = ${applicationId}
server/routes/public/applications_documents.ts:103:    const application = appResult.rows[0];
server/routes/public/applications_documents.ts:104:    if (!application) {
server/routes/public/applications_documents.ts:107:        error: 'Application not found',
server/routes/public/applications_documents.ts:108:        code: 'APPLICATION_NOT_FOUND'
server/routes/public/applications_documents.ts:115:    const storageKey = `${applicationId}/${documentId}.${fileExtension}`;
server/routes/public/applications_documents.ts:127:        applicationId
server/routes/public/applications_documents.ts:140:          application_id, 
server/routes/public/applications_documents.ts:149:          ${applicationId},
server/routes/public/applications_documents.ts:164:        - Application: ${applicationId}
server/routes/public/applications_documents.ts:172:      // üöÄ PIPELINE AUTOMATION: Check if all required documents are now uploaded
server/routes/public/applications_documents.ts:173:      const newDocumentCount = parseInt(application.current_document_count || '0') + 1;
server/routes/public/applications_documents.ts:175:      let pipelineTransition = null;
server/routes/public/applications_documents.ts:177:      console.log(`üìä [PIPELINE-AUTOMATION] Document count after upload: ${newDocumentCount}/${requiredDocuments}`);
server/routes/public/applications_documents.ts:179:      // If application is in "Requires Docs" stage and we now have sufficient documents
server/routes/public/applications_documents.ts:180:      if (application.stage === 'Requires Docs' && newDocumentCount >= requiredDocuments) {
server/routes/public/applications_documents.ts:182:          console.log(`üîÑ [PIPELINE-AUTOMATION] Triggering stage transition for application ${applicationId}`);
server/routes/public/applications_documents.ts:184:          // Update application stage to "In Review"
server/routes/public/applications_documents.ts:186:            UPDATE applications 
server/routes/public/applications_documents.ts:192:            WHERE id = ${applicationId}
server/routes/public/applications_documents.ts:195:          pipelineTransition = {
server/routes/public/applications_documents.ts:196:            from: application.stage,
server/routes/public/applications_documents.ts:202:          console.log(`‚úÖ [PIPELINE-AUTOMATION] Application ${applicationId} moved to "In Review" stage`);
server/routes/public/applications_documents.ts:205:          console.error(`‚ùå [PIPELINE-AUTOMATION] Failed to transition application:`, transitionError);
server/routes/public/applications_documents.ts:210:      // Return success response with pipeline information
server/routes/public/applications_documents.ts:219:        pipeline: {
server/routes/public/applications_documents.ts:220:          currentStage: pipelineTransition?.to || application.stage,
server/routes/public/applications_documents.ts:223:          transition: pipelineTransition
server/routes/public/applications_documents.ts:225:        message: pipelineTransition 
server/routes/public/applications_documents.ts:226:          ? `Document uploaded successfully - Application moved to ${pipelineTransition.to}`
server/routes/public/applications_documents.ts:251:// GET /api/public/applications/:id/documents - List documents for application
server/routes/public/applications_documents.ts:253:  const { id: applicationId } = req.params;
server/routes/public/applications_documents.ts:256:    console.log(`[DOCUMENTS] Listing documents for application ${applicationId}`);
server/routes/public/applications_documents.ts:258:    // Validate application ID format
server/routes/public/applications_documents.ts:260:    if (!uuidRegex.test(applicationId)) {
server/routes/public/applications_documents.ts:263:        error: 'Invalid application ID format',
server/routes/public/applications_documents.ts:264:        code: 'INVALID_APPLICATION_ID'
server/routes/public/applications_documents.ts:284:      .where(eq(documents.applicationId, applicationId));
server/routes/public/applications_documents.ts:286:    console.log(`[DOCUMENTS] Found ${docs.length} documents for application ${applicationId}`);
server/routes/public/applications_documents.ts:290:      applicationId: applicationId,
server/db/init.sql:1:-- Initialize database tables for Staff Application
server/db/init.sql:21:CREATE TABLE IF NOT EXISTS staff_applications(
server/db/init.sql:31:  application_id uuid REFERENCES staff_applications(id) NOT NULL,
server/routes/chat.ts:26:      applicationId,
server/routes/chat.ts:43:        applicationId,
server/routes/chat.ts:59:          applicationId,
server/routes/chat.ts:93:      applicationId,
server/routes/chat.ts:110:        applicationId,
server/routes/chat.ts:214:    const { applicationId, sessionId, limit = 20 } = req.query;
server/routes/chat.ts:218:    if (applicationId) {
server/routes/chat.ts:219:      query = query.where(eq(chatTranscripts.applicationId, applicationId as string));
server/routes/chat.ts:286:        message: 'Hi, I need help with my application',
server/routes/public/getSignatureStatus.ts:3:import { applications } from '../../../shared/schema';
server/routes/public/getSignatureStatus.ts:8:router.get('/applications/:id/signature-status', async (req, res) => {
server/routes/public/getSignatureStatus.ts:11:    console.log(`üîç Checking signature status for application: ${id}`);
server/routes/public/getSignatureStatus.ts:15:      .from(applications)
server/routes/public/getSignatureStatus.ts:16:      .where(eq(applications.id, id))
server/routes/public/getSignatureStatus.ts:20:      console.log(`‚ùå Application not found: ${id}`);
server/routes/public/getSignatureStatus.ts:23:        error: "Application not found" 
server/routes/public/getSignatureStatus.ts:27:    console.log(`‚úÖ Found application ${id}, signature_status: ${app.signingStatus}`);
server/routes/public/getSignatureStatus.ts:34:      application_id: app.id
server/routes/pipeline-board.ts:1:// server/routes/pipeline-board.ts
server/routes/pipeline-board.ts:15:// GET /api/pipeline/board - Board endpoint with no `SELECT a.*`, only safe columns
server/routes/pipeline-board.ts:28:      FROM applications
server/routes/pipeline-board.ts:49:    res.json({ columns: lanes, lanes: lanes.map(l => ({ name: l, cards: byLane[l] })) });
server/routes/pipeline-board.ts:51:    console.error('pipeline/board error:', e);
server/routes/applications/create.ts:3:import { applications, businesses, users, expectedDocuments, lenderProducts, documents } from '../../../shared/schema';
server/routes/applications/create.ts:14:  console.log(`üöÄ APPLICATION CREATE ROUTER HIT - ${req.method} ${req.originalUrl} - Base: ${req.baseUrl}, Path: ${req.path}`);
server/routes/applications/create.ts:30:// Create new application endpoint - FULLY PUBLIC (no auth required)
server/routes/applications/create.ts:32:  console.log('üìù Application creation request received');
server/routes/applications/create.ts:34:  // üõë BLOCK INTERNAL TEST APPLICATIONS FROM ENTERING SALES PIPELINE
server/routes/applications/create.ts:38:  // Detect test applications by business name or email patterns
server/routes/applications/create.ts:39:  const isTestApplication = 
server/routes/applications/create.ts:56:  if (isTestApplication) {
server/routes/applications/create.ts:57:    console.log('üõë BLOCKING INTERNAL TEST APPLICATION:', {
server/routes/applications/create.ts:65:      reason: 'Internal test submission blocked from sales pipeline',
server/routes/applications/create.ts:68:      message: 'Test applications are not added to production sales pipeline'
server/routes/applications/create.ts:72:  // ‚úÖ MONITOR: Application received
server/routes/applications/create.ts:73:  console.log("‚úÖ [MONITOR] Application received");
server/routes/applications/create.ts:82:      "./logs/application_log.txt",
server/routes/applications/create.ts:83:      `[${new Date().toISOString()}] Application received: ${JSON.stringify(req.body)}\n`
server/routes/applications/create.ts:86:    console.error("‚ùå Failed to write to application log file:", logError);
server/routes/applications/create.ts:167:  // Determine application source and version for traceability
server/routes/applications/create.ts:168:  const applicationSource = req.body.source || 
server/routes/applications/create.ts:173:    source: applicationSource,
server/routes/applications/create.ts:181:    console.error("üö® LEGACY FORMAT DETECTED - REJECTING APPLICATION");
server/routes/applications/create.ts:189:      error: "‚ùå Legacy field format detected. Application must use step1/step3/step4 structure.",
server/routes/applications/create.ts:196:  console.log("üìù Received Application Format:", {
server/routes/applications/create.ts:204:  // üö® STAFF CRITICAL DEBUG BLOCK: Comprehensive try-catch around application creation
server/routes/applications/create.ts:206:    console.log('üö® APPLICATION CREATION DEBUG: Starting application creation process...');
server/routes/applications/create.ts:211:    let { step1, step2, step3, step4, applicationId: clientApplicationId } = req.body;
server/routes/applications/create.ts:272:    // STRICT SCHEMA ENFORCEMENT - Reject applications without proper step structure
server/routes/applications/create.ts:274:      console.error("üö® REJECTED: Invalid application structure - missing required steps");
server/routes/applications/create.ts:281:        reason: "Application must contain step1, step3, and step4 objects"
server/routes/applications/create.ts:284:        error: "‚ùå Invalid application structure. Missing step1, step3, or step4",
server/routes/applications/create.ts:374:    console.log('‚úÖ Step-based application validated:', {
server/routes/applications/create.ts:384:    // ‚úÖ DUPLICATE EMAIL CONSTRAINT ELIMINATED: Multiple applications per email allowed
server/routes/applications/create.ts:385:    // Always creates new application and business, reuses existing user by email
server/routes/applications/create.ts:386:    console.log(`‚úÖ MULTIPLE APPLICATIONS ALLOWED: Processing application for email: ${step4.email}`);
server/routes/applications/create.ts:387:    console.log(`‚úÖ Business name: ${step3.businessName} - proceeding with new application creation`);
server/routes/applications/create.ts:432:    // Create application record - use client-provided ID if valid UUID, otherwise generate UUID
server/routes/applications/create.ts:433:    let applicationId = clientApplicationId;
server/routes/applications/create.ts:436:    if (clientApplicationId && !uuidValidate(clientApplicationId)) {
server/routes/applications/create.ts:437:      console.log(`‚ö†Ô∏è Invalid UUID format provided by client: ${clientApplicationId}, generating new UUID`);
server/routes/applications/create.ts:438:      applicationId = uuidv4();
server/routes/applications/create.ts:439:    } else if (!clientApplicationId) {
server/routes/applications/create.ts:440:      applicationId = uuidv4();
server/routes/applications/create.ts:443:    console.log(`üìã ENHANCED: Application ID handling:`, {
server/routes/applications/create.ts:444:      clientProvided: clientApplicationId ? 'YES' : 'NO',
server/routes/applications/create.ts:445:      providedId: clientApplicationId,
server/routes/applications/create.ts:446:      isValidUUID: clientApplicationId ? uuidValidate(clientApplicationId) : 'N/A',
server/routes/applications/create.ts:447:      finalId: applicationId,
server/routes/applications/create.ts:448:      source: (clientApplicationId && uuidValidate(clientApplicationId)) ? 'CLIENT' : 'AUTO_GENERATED',
server/routes/applications/create.ts:452:    console.log(`üîç ENHANCED: About to insert applicationId into database:`, applicationId);
server/routes/applications/create.ts:455:    console.log('üö® DEBUG: Application database values before insertion:', {
server/routes/applications/create.ts:456:      id: applicationId,
server/routes/applications/create.ts:466:    let newApplication;
server/routes/applications/create.ts:469:      newApplication = await db
server/routes/applications/create.ts:470:        .insert(applications)
server/routes/applications/create.ts:472:          id: applicationId,
server/routes/applications/create.ts:483:            applicationSource: applicationSource,
server/routes/applications/create.ts:492:      console.log('üö® DEBUG: Database insertion successful, application ID:', newApplication?.[0]?.id);
server/routes/applications/create.ts:494:      console.error('üö® CRITICAL DATABASE ERROR during application creation:', dbError);
server/routes/applications/create.ts:498:        applicationId: applicationId,
server/routes/applications/create.ts:506:    const applicationRecord = newApplication?.[0];
server/routes/applications/create.ts:507:    console.log('üö® DEBUG: Application record extracted:', applicationRecord?.id);
server/routes/applications/create.ts:513:    if (formFields.productCategory || applicationRecord.productCategory) {
server/routes/applications/create.ts:515:        const selectedCategory = formFields.productCategory || applicationRecord.productCategory;
server/routes/applications/create.ts:542:        applicationRecord.id,
server/routes/applications/create.ts:548:        console.log(`üìã ENHANCED: Created ${expectedDocsData.length} expected document requirements for application ${applicationRecord.id}`);
server/routes/applications/create.ts:551:        // Don't fail the application creation if expected docs creation fails
server/routes/applications/create.ts:555:    console.log(`üìã ENHANCED: Application created with EXACT ID VERIFICATION:`, {
server/routes/applications/create.ts:556:      applicationId: applicationRecord.id,
server/routes/applications/create.ts:558:      requestedAmount: applicationRecord.requestedAmount,
server/routes/applications/create.ts:559:      status: applicationRecord.status,
server/routes/applications/create.ts:561:      internalId: applicationRecord.id,
server/routes/applications/create.ts:562:      externalId: `app_prod_${applicationRecord.id}`,
server/routes/applications/create.ts:563:      clientProvidedId: clientApplicationId,
server/routes/applications/create.ts:564:      idMatches: applicationRecord.id === applicationId ? 'YES' : 'NO',
server/routes/applications/create.ts:565:      dbInsertedId: applicationRecord.id,
server/routes/applications/create.ts:566:      requestedId: applicationId
server/routes/applications/create.ts:569:    // STAFF REQUIREMENT 1: Log successful application storage
server/routes/applications/create.ts:570:    console.log("‚úÖ [Staff] Application successfully stored:", applicationRecord.id);
server/routes/applications/create.ts:575:        "./logs/application_log.txt",
server/routes/applications/create.ts:576:        `[${new Date().toISOString()}] Application successfully stored: ${applicationRecord.id}\n`
server/routes/applications/create.ts:579:      console.error("‚ùå Failed to write success to application log file:", logError);
server/routes/applications/create.ts:584:      console.log('üî¥ CRITICAL DEBUG: About to attempt database update for application:', applicationRecord.id);
server/routes/applications/create.ts:586:      console.log('üî¥ CRITICAL DEBUG: Applications table exists:', !!applications);
server/routes/applications/create.ts:589:        .update(applications)
server/routes/applications/create.ts:591:          signUrl: 'CHECKPOINT: Code execution reached end of application creation',
server/routes/applications/create.ts:594:        .where(eq(applications.id, applicationRecord.id));
server/routes/applications/create.ts:596:      console.log('üü¢ CRITICAL CHECKPOINT: Post-application creation database update completed');
server/routes/applications/create.ts:599:      console.error('üî¥ CRITICAL CHECKPOINT: Post-application database update failed:', criticalCheckpointError);
server/routes/applications/create.ts:606:      console.log('ü§ñ [CRM AUTO-CREATE] Starting contact auto-creation for application:', applicationRecord.id);
server/routes/applications/create.ts:609:      const { autoCreateContactsFromApplication } = await import('../../services/crmService.js');
server/routes/applications/create.ts:611:      const applicationData = {
server/routes/applications/create.ts:612:        id: applicationRecord.id,
server/routes/applications/create.ts:628:      await autoCreateContactsFromApplication(applicationData);
server/routes/applications/create.ts:633:      // Don't fail application creation if CRM contact creation fails
server/routes/applications/create.ts:634:      console.error('‚ùå [CRM AUTO-CREATE] Contact creation error, but application creation continues');
server/routes/applications/create.ts:637:    // üì± AUTOMATIC SMS TRIGGER: Send missing docs SMS for new applications without documents
server/routes/applications/create.ts:638:    console.log("üì± [AUTO-SMS] Triggering immediate automatic SMS for new application");
server/routes/applications/create.ts:642:      // Since this is a new application without documents, send the "submission_no_docs" SMS
server/routes/applications/create.ts:643:      console.log(`üì± [AUTO-SMS] Sending missing docs SMS for new application: ${applicationRecord.id}`);
server/routes/applications/create.ts:644:      const smsResult = await sendEnhancedSMS(applicationRecord.id, 'submission_no_docs');
server/routes/applications/create.ts:654:      // Don't fail application creation if SMS fails
server/routes/applications/create.ts:657:    // Document signing integration removed - applications use simplified manual review workflow
server/routes/applications/create.ts:660:    // No document signing integration - applications proceed directly to manual staff review
server/routes/applications/create.ts:662:    // ‚úÖ MONITOR: Sales Pipeline Integration
server/routes/applications/create.ts:663:    console.log("‚úÖ [MONITOR] Application created successfully - Added to Sales Pipeline");
server/routes/applications/create.ts:664:    console.log("üéØ [MONITOR] Sales Pipeline: Card added to 'New Application' stage");
server/routes/applications/create.ts:668:      applicationId: applicationRecord.id, // raw UUID
server/routes/applications/create.ts:669:      externalId: `app_prod_${applicationRecord.id}`, // optional, for display
server/routes/applications/create.ts:670:      status: applicationRecord.status,
server/routes/applications/create.ts:671:      message: 'Application created successfully',
server/routes/applications/create.ts:682:    // STAFF REQUIREMENT 1: Log application storage failure
server/routes/applications/create.ts:683:    console.error("‚ùå [Staff] Application storage failed:", error);
server/routes/applications/create.ts:688:        "./logs/application_log.txt",
server/routes/applications/create.ts:689:        `[${new Date().toISOString()}] Application storage failed: ${error instanceof Error ? error.message : String(error)}\n`
server/routes/applications/create.ts:692:      console.error("‚ùå Failed to write failure to application log file:", logError);
server/routes/applications/create.ts:696:    console.error('üö® APPLICATION CREATION FAILED:', error);
server/routes/applications/create.ts:731:      // Continue with the original error handling rather than blocking the application
server/routes/applications/create.ts:732:      console.log("üîÑ Proceeding with application creation despite duplicate email constraint");
server/routes/applications/create.ts:746:      message: 'Application creation failed',
server/routes/applications/create.ts:754:// PATCH /:id - Finalize application submission
server/routes/applications/create.ts:757:    const rawApplicationId = req.params.id;
server/routes/applications/create.ts:761:    const actualId = rawApplicationId.replace(/^test-/, '');
server/routes/applications/create.ts:763:    console.log(`üìù [Application Finalize] Request for: ${rawApplicationId} ‚Üí ${actualId}`);
server/routes/applications/create.ts:764:    console.log(`üìù [Application Finalize] Update data:`, { formData: !!formData, status });
server/routes/applications/create.ts:769:      console.error(`‚ùå [Application Finalize] Invalid UUID format: ${actualId}`);
server/routes/applications/create.ts:771:        error: 'Invalid application ID format'
server/routes/applications/create.ts:775:    // Verify application exists
server/routes/applications/create.ts:776:    const [application] = await db
server/routes/applications/create.ts:778:      .from(applications)
server/routes/applications/create.ts:779:      .where(eq(applications.id, actualId));
server/routes/applications/create.ts:781:    if (!application) {
server/routes/applications/create.ts:782:      console.error(`‚ùå [Application Finalize] Application not found: ${actualId}`);
server/routes/applications/create.ts:784:        error: 'Application not found'
server/routes/applications/create.ts:790:    if (!allowedStatuses.includes(application.status)) {
server/routes/applications/create.ts:791:      console.error(`‚ùå [Application Finalize] Invalid status: ${application.status}`);
server/routes/applications/create.ts:793:        error: 'Application cannot be finalized',
server/routes/applications/create.ts:794:        message: `Application status is '${application.status}', only draft applications can be finalized`,
server/routes/applications/create.ts:795:        currentStatus: application.status
server/routes/applications/create.ts:807:      console.log(`üìù [Application Finalize] Updating form data`);
server/routes/applications/create.ts:819:    // Update application
server/routes/applications/create.ts:820:    const [updatedApplication] = await db
server/routes/applications/create.ts:821:      .update(applications)
server/routes/applications/create.ts:823:      .where(eq(applications.id, actualId))
server/routes/applications/create.ts:826:    console.log(`‚úÖ [Application Finalize] Successfully updated application ${actualId} to status: ${finalStatus}`);
server/routes/applications/create.ts:832:      .where(eq(documents.applicationId, actualId));
server/routes/applications/create.ts:837:      .where(eq(expectedDocuments.applicationId, actualId));
server/routes/applications/create.ts:844:        .update(applications)
server/routes/applications/create.ts:846:        .where(eq(applications.id, actualId));
server/routes/applications/create.ts:848:      console.log(`‚úÖ [Application Finalize] Application ready for lenders - all documents uploaded`);
server/routes/applications/create.ts:855:      message: 'Application finalized successfully',
server/routes/applications/create.ts:856:      application: {
server/routes/applications/create.ts:857:        id: updatedApplication.id,
server/routes/applications/create.ts:858:        status: updatedApplication.status,
server/routes/applications/create.ts:859:        stage: updatedApplication.stage,
server/routes/applications/create.ts:860:        updatedAt: updatedApplication.updatedAt,
server/routes/applications/create.ts:861:        submittedAt: updatedApplication.submittedAt,
server/routes/applications/create.ts:867:    console.error(`‚ùå [Application Finalize] Error:`, error);
server/routes/applications/create.ts:879:console.log('üìã APPLICATION CREATE ROUTE: Loaded and exported successfully');
server/routes/applications/create.ts:880:console.log('üìã APPLICATION CREATE ROUTE: Configured for POST /');
server/routes/contact-details.ts:108:    // Get applications associated with this contact
server/routes/contact-details.ts:109:    const { rows: applications } = await db.execute(sql`
server/routes/contact-details.ts:112:      FROM applications 
server/routes/contact-details.ts:131:      applications: applications.map((app: any) => ({
server/db/repo/apps.ts:3:import { Application, Stage, TenantId } from "../types";
server/db/repo/apps.ts:6:  async get(tenantId: TenantId, appId: string): Promise<Application|null> {
server/db/repo/apps.ts:7:    // Use existing applications table
server/db/repo/apps.ts:8:    const rows = await q<Application>(`SELECT * FROM applications WHERE id=$1`, [appId]);
server/db/repo/apps.ts:12:    return q<Application>(`SELECT * FROM applications WHERE recommended_lender_id=$1 ORDER BY updated_at DESC`, [lenderId]);
server/db/repo/apps.ts:15:    return q<Application>(`SELECT * FROM applications ORDER BY updated_at DESC`);
server/db/repo/apps.ts:17:  async create(app: Partial<Application> & { id: string }): Promise<Application> {
server/db/repo/apps.ts:18:    const rows = await q<Application>(
server/db/repo/apps.ts:19:      `INSERT INTO applications (id, user_id, business_id, status, requested_amount, created_at, updated_at)
server/db/repo/apps.ts:26:  async update(tenantId: TenantId, appId: string, patch: Partial<Application>) {
server/db/repo/apps.ts:41:    const sql = `UPDATE applications SET ${fields.join(",")}, updated_at=NOW() WHERE id=$${i} RETURNING *`;
server/db/repo/apps.ts:42:    const rows = await q<Application>(sql, vals);
server/db/repo/apps.ts:46:    const rows = await q<Application>(
server/db/repo/apps.ts:47:      `UPDATE applications SET stage=$1, updated_at=NOW() WHERE id=$2 RETURNING *`,
server/routes/applications/overrideSigning.ts:30:// PATCH /api/public/applications/:id/override-signing
server/routes/applications/overrideSigning.ts:34:    const applicationId = validateAndNormalizeUUID(req.params.id);
server/routes/applications/overrideSigning.ts:36:    console.log(`üîß Manual signing override for application: ${applicationId}`);
server/routes/applications/overrideSigning.ts:38:    // Update application to mark as signed
server/routes/applications/overrideSigning.ts:40:      UPDATE applications 
server/routes/applications/overrideSigning.ts:51:    const result = await pool.query(updateQuery, [applicationId]);
server/routes/applications/overrideSigning.ts:56:        error: 'Application not found'
server/routes/applications/overrideSigning.ts:60:    const updatedApplication = result.rows[0];
server/routes/applications/overrideSigning.ts:63:      applicationId,
server/routes/applications/overrideSigning.ts:64:      signed: updatedApplication.signed,
server/routes/applications/overrideSigning.ts:65:      signingStatus: updatedApplication.signing_status,
server/routes/applications/overrideSigning.ts:66:      stage: updatedApplication.stage,
server/routes/applications/overrideSigning.ts:67:      signedAt: updatedApplication.signed_at
server/routes/applications/overrideSigning.ts:74:        applicationId,
server/routes/applications/overrideSigning.ts:75:        signed: updatedApplication.signed,
server/routes/applications/overrideSigning.ts:76:        signingStatus: updatedApplication.signing_status,
server/routes/applications/overrideSigning.ts:77:        stage: updatedApplication.stage,
server/routes/applications/overrideSigning.ts:78:        signedAt: updatedApplication.signed_at
server/routes/testing-suite.ts:24:          name: 'Pipeline Management',
server/routes/applications/submit.ts:3:import { applications } from '../../../shared/schema';
server/routes/applications/submit.ts:8:// Submit application endpoint - updates application status to submitted
server/routes/applications/submit.ts:11:    const { id: rawApplicationId } = req.params;
server/routes/applications/submit.ts:15:    const applicationId = rawApplicationId.startsWith('app_prod_') 
server/routes/applications/submit.ts:16:      ? rawApplicationId.replace('app_prod_', '')
server/routes/applications/submit.ts:17:      : rawApplicationId;
server/routes/applications/submit.ts:19:    console.log(`üìã Submit request: ${rawApplicationId} -> ${applicationId}`);
server/routes/applications/submit.ts:21:    // Validate application exists and status is draft
server/routes/applications/submit.ts:22:    const existingApplication = await db
server/routes/applications/submit.ts:24:      .from(applications)
server/routes/applications/submit.ts:25:      .where(eq(applications.id, applicationId))
server/routes/applications/submit.ts:28:    if (!existingApplication.length) {
server/routes/applications/submit.ts:31:        error: 'Application not found'
server/routes/applications/submit.ts:35:    const application = existingApplication[0];
server/routes/applications/submit.ts:38:    if (application.status === 'lender_match' || 
server/routes/applications/submit.ts:39:        application.status === 'approved' || 
server/routes/applications/submit.ts:40:        application.status === 'funded') {
server/routes/applications/submit.ts:42:      console.log(`üö´ SUBMIT REJECTED: Application ${applicationId} already finalized - Status: ${application.status}`);
server/routes/applications/submit.ts:46:        error: 'Application already finalized',
server/routes/applications/submit.ts:47:        message: `Cannot resubmit application that is already in ${application.status} status`,
server/routes/applications/submit.ts:48:        currentStatus: application.status,
server/routes/applications/submit.ts:53:    // Verify application status is draft
server/routes/applications/submit.ts:54:    if (application.status !== 'draft') {
server/routes/applications/submit.ts:57:        error: 'Application cannot be submitted',
server/routes/applications/submit.ts:58:        message: `Application status is '${application.status}', only draft applications can be submitted`
server/routes/applications/submit.ts:62:    // DOCUMENT VALIDATION DECOUPLED - applications can now be submitted without documents
server/routes/applications/submit.ts:63:    const { validateApplicationHasDocuments } = await import('../../utils/documentStorage.js');
server/routes/applications/submit.ts:64:    const hasDocuments = await validateApplicationHasDocuments(applicationId);
server/routes/applications/submit.ts:67:      console.warn(`‚ö†Ô∏è [DOCUMENT INFO] Application ${applicationId} submitted without documents - proceeding anyway`);
server/routes/applications/submit.ts:69:      console.log(`üìÑ [DOCUMENT INFO] Application ${applicationId} submitted with ${hasDocuments} documents`);
server/routes/applications/submit.ts:80:        message: 'Terms and conditions must be accepted to submit application'
server/routes/applications/submit.ts:88:        message: 'Privacy policy must be accepted to submit application'
server/routes/applications/submit.ts:109:    // Update application status to submitted and save acceptance flags
server/routes/applications/submit.ts:110:    const [updatedApplication] = await db
server/routes/applications/submit.ts:111:      .update(applications)
server/routes/applications/submit.ts:117:        ...(application.metadata && typeof application.metadata === 'object' 
server/routes/applications/submit.ts:120:                ...application.metadata,
server/routes/applications/submit.ts:130:      .where(eq(applications.id, applicationId))
server/routes/applications/submit.ts:133:    if (!updatedApplication) {
server/routes/applications/submit.ts:136:        error: 'Failed to update application status'
server/routes/applications/submit.ts:141:    console.log(`üìã Application submission completed:`, {
server/routes/applications/submit.ts:142:      applicationId: updatedApplication.id,
server/routes/applications/submit.ts:143:      status: updatedApplication.status,
server/routes/applications/submit.ts:144:      stage: updatedApplication.stage,
server/routes/applications/submit.ts:149:      submittedAt: updatedApplication.submittedAt
server/routes/applications/submit.ts:152:    console.log(`‚úÖ Application ${updatedApplication.id} submitted successfully with reference ${reference}`);
server/routes/applications/submit.ts:155:    // Ensure every submitted application has corresponding CRM contact
server/routes/applications/submit.ts:157:      console.log('ü§ñ [CRM SUBMIT] Verifying/creating CRM contact for submitted application:', updatedApplication.id);
server/routes/applications/submit.ts:159:      // Get application and business details for contact creation
server/routes/applications/submit.ts:166:          applicationId: applications.id,
server/routes/applications/submit.ts:167:          formData: applications.formData,
server/routes/applications/submit.ts:171:        .from(applications)
server/routes/applications/submit.ts:172:        .innerJoin(businesses, eq(applications.businessId, businesses.id))
server/routes/applications/submit.ts:173:        .where(eq(applications.id, updatedApplication.id))
server/routes/applications/submit.ts:208:                'Client Application Submission',
server/routes/applications/submit.ts:215:            console.log(`‚úÖ [CRM SUBMIT] Created contact for submitted application: ${contactResult.rows[0].email}`);
server/routes/applications/submit.ts:230:        applicationId: updatedApplication.id,
server/routes/applications/submit.ts:231:        trigger: 'new_application',
server/routes/applications/submit.ts:235:      console.log(`üì± [SUBMIT] SMS notification triggered for application: ${updatedApplication.id}`);
server/routes/applications/submit.ts:245:      applicationId: updatedApplication.id,
server/routes/applications/submit.ts:250:    console.error('Application submission error:', error);
server/routes/applications/submit.ts:253:      error: 'Failed to submit application',
server/routes/analytics-advanced.ts:17:        { stage: 'Application Started', count: 89, rate: 57 },
server/routes/analytics-advanced.ts:33:          { month: 'Jan', revenue: 245000, applications: 89 },
server/routes/analytics-advanced.ts:34:          { month: 'Feb', revenue: 267000, applications: 95 },
server/routes/analytics-advanced.ts:35:          { month: 'Mar', revenue: 289000, applications: 102 },
server/routes/analytics-advanced.ts:36:          { month: 'Apr', revenue: 312000, applications: 108 }
server/routes/analytics-advanced.ts:52:          { name: 'John Smith', applications: 23, conversionRate: 78 },
server/routes/analytics-advanced.ts:53:          { name: 'Sarah Johnson', applications: 19, conversionRate: 82 },
server/routes/analytics-advanced.ts:54:          { name: 'Mike Wilson', applications: 21, conversionRate: 74 }
server/routes/applications/upload.ts:7:import { documents, applications, auditLog } from '../../../shared/schema';
server/routes/applications/upload.ts:40:      'application/pdf',
server/routes/applications/upload.ts:44:      'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet',
server/routes/applications/upload.ts:45:      'application/vnd.ms-excel',
server/routes/applications/upload.ts:62:// Upload document endpoint for applications - stores document metadata in database
server/routes/applications/upload.ts:63:router.post('/:applicationId', upload.array('files', 10), async (req: any, res) => {
server/routes/applications/upload.ts:65:    const { applicationId } = req.params;
server/routes/applications/upload.ts:70:    if (!applicationId) {
server/routes/applications/upload.ts:73:        error: 'applicationId is required'
server/routes/applications/upload.ts:78:    const cleanApplicationId = stripAppProdPrefix(applicationId);
server/routes/applications/upload.ts:79:    console.log(`[ID MAPPING] Cleaned app_prod_ prefix: ${applicationId} ‚Üí ${cleanApplicationId}`);
server/routes/applications/upload.ts:88:    // Verify application exists using clean UUID
server/routes/applications/upload.ts:89:    const [application] = await db
server/routes/applications/upload.ts:91:      .from(applications)
server/routes/applications/upload.ts:92:      .where(eq(applications.id, cleanApplicationId));
server/routes/applications/upload.ts:94:    if (!application) {
server/routes/applications/upload.ts:99:        error: 'Application not found'
server/routes/applications/upload.ts:114:        applicationId: cleanApplicationId,
server/routes/applications/upload.ts:120:        uploadedBy: application.userId
server/routes/applications/upload.ts:124:      console.log(`‚úÖ [MONITOR] Document upload request received for application ${req.params.applicationId}`);
server/routes/applications/upload.ts:141:      if (['application/pdf', 'image/jpeg', 'image/jpg', 'image/png', 'text/plain'].includes(file.mimetype)) {
server/routes/applications/upload.ts:160:      applicationId: cleanApplicationId,
server/routes/applications/upload.ts:161:      externalId: applicationId,
server/routes/applications/upload.ts:167:    console.log(`‚úÖ ${files.length} documents uploaded and stored for application ${cleanApplicationId} (external: ${applicationId})`);
server/routes/ai-features.ts:8:    const { applicationId, ocrData, applicantData } = req.body;
server/routes/ai-features.ts:13:      applicationId,
server/routes/ai-features.ts:14:      content: `Based on the provided documentation and application data, the applicant demonstrates strong financial capacity with consistent revenue streams and minimal outstanding debt obligations. Key factors supporting this assessment include verified banking history, positive cash flow trends, and established business operations.`,
server/routes/ai-features.ts:32:    console.log(`ü§ñ [AI] Generated credit summary for application ${applicationId}`);
server/routes/ai-features.ts:43:    const { applicationId, financialData } = req.body;
server/routes/ai-features.ts:46:      applicationId,
server/routes/ai-features.ts:59:    console.log(`üéØ [AI] Generated risk score ${riskAssessment.overallScore} for application ${applicationId}`);
server/routes/ai-features.ts:70:    const { type, applicationData, lenderPreferences } = req.body;
server/routes/ai-features.ts:75:      title: `${type === 'lender' ? 'Lender Application' : 'Credit Summary'} - ${applicationData.applicantName}`,
server/routes/ai-features.ts:77:# ${type === 'lender' ? 'Loan Application Package' : 'Executive Credit Summary'}
server/routes/ai-features.ts:79:**Applicant:** ${applicationData.applicantName || 'Business Entity'}
server/routes/ai-features.ts:80:**Requested Amount:** $${applicationData.requestedAmount || '50,000'}
server/routes/ai-features.ts:81:**Purpose:** ${applicationData.purpose || 'Business expansion and working capital'}
server/routes/ai-features.ts:99:    console.log(`üìÑ [AI] Generated ${type} template for ${applicationData.applicantName}`);
server/routes/applications/signatureStatus.ts:1:// server/routes/applications/signatureStatus.ts
server/routes/applications/signatureStatus.ts:4:import { applications } from "../../../shared/schema";
server/routes/applications/signatureStatus.ts:13:    return res.status(400).json({ success: false, error: "Missing application ID" });
server/routes/applications/signatureStatus.ts:17:    const app = await db.query.applications.findFirst({
server/routes/applications/signatureStatus.ts:18:      where: eq(applications.id, appId),
server/routes/applications/signatureStatus.ts:22:      return res.status(404).json({ success: false, error: "Application not found" });
server/routes/applications/signatureStatus.ts:27:      application_id: app.id,
server/routes/applications/complete.ts:3:import { applications } from '../../../shared/schema';
server/routes/applications/complete.ts:8:// Complete application endpoint - finalizes an application
server/routes/applications/complete.ts:17:        error: 'Application ID is required'
server/routes/applications/complete.ts:21:    // Check current application status to prevent re-submissions
server/routes/applications/complete.ts:23:      .select({ status: applications.status, stage: applications.stage })
server/routes/applications/complete.ts:24:      .from(applications)
server/routes/applications/complete.ts:25:      .where(eq(applications.id, id))
server/routes/applications/complete.ts:31:        error: 'Application not found'
server/routes/applications/complete.ts:44:        error: 'Application already finalized',
server/routes/applications/complete.ts:45:        message: `Application cannot be resubmitted. Current status: ${currentApp.status}, stage: ${currentApp.stage}`,
server/routes/applications/complete.ts:55:    // Update application to completed status
server/routes/applications/complete.ts:56:    const [updatedApplication] = await db
server/routes/applications/complete.ts:57:      .update(applications)
server/routes/applications/complete.ts:62:      .where(eq(applications.id, id))
server/routes/applications/complete.ts:65:    if (!updatedApplication) {
server/routes/applications/complete.ts:68:        error: 'Application not found'
server/routes/applications/complete.ts:72:    console.log(`‚úÖ Application ${id} completed with status: ${status}`);
server/routes/applications/complete.ts:76:      message: `Application completed successfully with status: ${status}`,
server/routes/applications/complete.ts:77:      application: updatedApplication
server/routes/applications/complete.ts:81:    console.error('Error completing application:', error);
server/routes/applications/complete.ts:84:      error: 'Failed to complete application'
server/routes/contacts.ts:5:import { mergeContactsFromApplications } from "../services/contacts";
server/routes/contacts.ts:16:// Pipeline endpoint for compatibility
server/routes/contacts.ts:17:r.get("/pipeline", async (req, res) => {
server/routes/contacts.ts:19:    console.log('üîç GET /api/contacts/pipeline - Fetching contact details');
server/routes/contacts.ts:23:    console.error("‚ùå [CONTACTS-PIPELINE] Error:", e);
server/routes/contacts.ts:24:    res.status(500).json({ error: "Failed to fetch pipeline contacts" });
server/routes/contacts.ts:72:    // Fallback: Fetch from applications if no contacts in contacts table
server/routes/contacts.ts:73:    console.log('üîÑ No contacts found, falling back to applications merge');
server/routes/contacts.ts:79:      FROM applications a 
server/routes/contacts.ts:102:    const mergedContacts = mergeContactsFromApplications(apps);
server/routes/contacts.ts:110:// GET /api/contacts/normalized - Deduplicated view with application counts from ContactIndex
server/routes/contacts.ts:123:      applicationsCount: contact.applicationsCount || 0,
server/routes/contacts.ts:124:      applications: contact.applications || [],
server/routes/contacts.ts:148:      FROM applications a 
server/routes/contacts.ts:213:      FROM applications a 
server/routes/contacts.ts:256:        applicationsCount: records.length,
server/routes/contacts.ts:257:        applications: records.map((r: any) => r.id),
server/routes/contacts.ts:310:    // Get applications for this contact
server/routes/contacts.ts:311:    const applications = await pool.query(`
server/routes/contacts.ts:313:      FROM applications 
server/routes/contacts.ts:320:      applications: applications.rows.map(app => ({
server/routes/contacts.ts:328:    console.log(`‚úÖ Contact found: ${contact.name} with ${applications.rows.length} applications`);
server/routes/contacts.ts:351:    // Get application timeline events for this contact
server/routes/contacts.ts:355:        legal_business_name, 'application' as event_type
server/routes/contacts.ts:356:      FROM applications 
server/routes/contacts.ts:366:      summary: `Application: ${event.legal_business_name || 'Business'} - $${(event.requested_amount || 0).toLocaleString()} (${event.status})`,
server/routes/contacts.ts:369:      event_type: 'application'
server/routes/client-api.ts:10:// ‚úÖ Secure lender products - requires document approval for applicationId queries  
server/routes/client-api.ts:14:// ===== APPLICATION SUBMISSION API =====
server/routes/client-api.ts:15:const ApplicationSchema = z.object({
server/routes/client-api.ts:43:router.post("/applications", async (req: Request, res: Response) => {
server/routes/client-api.ts:45:    console.log("üìù [CLIENT-API] Received application submission:", req.body);
server/routes/client-api.ts:47:    const parsed = ApplicationSchema.safeParse(req.body);
server/routes/client-api.ts:71:    // Create application using correct schema
server/routes/client-api.ts:75:      INSERT INTO applications (
server/routes/client-api.ts:97:    const application = appResult.rows[0];
server/routes/client-api.ts:99:    console.log(`‚úÖ [CLIENT-API] Created application ${application.id} for ${step3.businessName}`);
server/routes/client-api.ts:103:      application: {
server/routes/client-api.ts:104:        id: application.id,
server/routes/client-api.ts:105:        status: application.status,
server/routes/client-api.ts:106:        created_at: application.created_at
server/routes/client-api.ts:111:    console.error("‚ùå [CLIENT-API] Application submission error:", error);
server/routes/client-api.ts:112:    res.status(500).json({ error: "Failed to submit application" });
server/routes/client-api.ts:116:// ===== APPLICATION STATUS API =====
server/routes/client-api.ts:117:router.get("/applications/:id", async (req: Request, res: Response) => {
server/routes/client-api.ts:133:      FROM applications a
server/routes/client-api.ts:139:      return res.status(404).json({ error: "Application not found" });
server/routes/client-api.ts:142:    res.json({ success: true, application: result.rows[0] });
server/routes/client-api.ts:145:    console.error("‚ùå [CLIENT-API] Error fetching application:", error);
server/routes/client-api.ts:146:    res.status(500).json({ error: "Failed to fetch application" });
server/routes/client-api.ts:152:  applicationId: z.string().uuid(),
server/routes/client-api.ts:173:    const { applicationId, documentType, fileName, fileSize, mimeType } = parsed.data;
server/routes/client-api.ts:175:    // Verify application exists
server/routes/client-api.ts:177:      SELECT id FROM applications WHERE id = $1
server/routes/client-api.ts:178:    `, [applicationId]);
server/routes/client-api.ts:181:      return res.status(404).json({ error: "Application not found" });
server/routes/client-api.ts:187:        id, application_id, file_name, file_type, file_size, mime_type,
server/routes/client-api.ts:192:    `, [applicationId, fileName, documentType, fileSize, mimeType]);
server/routes/client-api.ts:196:    console.log(`‚úÖ [CLIENT-API] Document uploaded: ${document.id} for application ${applicationId}`);
server/routes/client-api.ts:215:  applicationId: z.string().uuid().optional(),
server/routes/client-api.ts:220:  category: z.enum(['general_inquiry', 'application_help', 'technical_issue', 'complaint']).default('general_inquiry')
server/routes/client-api.ts:235:    const { applicationId, email, name, message, priority, category } = parsed.data;
server/routes/client-api.ts:240:        id, application_id, user_email, user_name, initial_message,
server/routes/client-api.ts:245:    `, [applicationId, email, name, message, priority, category]);
server/routes/client-api.ts:268:  applicationId: z.string().uuid().optional(),
server/routes/client-api.ts:291:    const { applicationId, email, name, issueType, title, description, severity, browserInfo, currentUrl } = parsed.data;
server/routes/client-api.ts:296:        id, application_id, reporter_email, reporter_name, issue_type,
server/routes/client-api.ts:302:    `, [applicationId, email, name, issueType, title, description, severity, browserInfo, currentUrl]);
server/routes/client-api.ts:331:      "POST /applications",
server/routes/client-api.ts:332:      "GET /applications/:id", 
server/db/schema/application_stage_history.sql:1:-- Application Stage History Table
server/db/schema/application_stage_history.sql:4:CREATE TABLE IF NOT EXISTS application_stage_history (
server/db/schema/application_stage_history.sql:6:  application_id VARCHAR(255) NOT NULL,
server/db/schema/application_stage_history.sql:13:  FOREIGN KEY (application_id) REFERENCES applications(id) ON DELETE CASCADE
server/db/schema/application_stage_history.sql:16:CREATE INDEX IF NOT EXISTS idx_stage_history_app_id ON application_stage_history(application_id);
server/db/schema/application_stage_history.sql:17:CREATE INDEX IF NOT EXISTS idx_stage_history_changed_at ON application_stage_history(changed_at);
server/db/schema/application_stage_history.sql:19:-- Ensure applications table has stage column
server/db/schema/application_stage_history.sql:20:ALTER TABLE applications ADD COLUMN IF NOT EXISTS stage VARCHAR(50) DEFAULT 'New';
server/routes/twilio/voice.ts:42:      outgoingApplicationSid: process.env.TWILIO_TWIML_APP_SID,
server/routes/twilio/voice.ts:258:  res.setHeader('Content-Type', 'application/json');
server/routes/twilio/voice.ts:316:    }, 'Press 1 for loan applications, Press 2 for customer service, or stay on the line for an agent.');
server/routes/twilio/voice.ts:370:    }, 'Press 1 for new applications, Press 2 for existing customers, or stay on the line for assistance.');
server/routes/public.ts:14:    const { applicationId, filename, contentType, sha256, category } = req.body;
server/routes/public.ts:16:    if (!applicationId || !filename || !contentType) {
server/routes/public.ts:21:    const objectKey = `apps/${applicationId}/${Date.now()}-${safeName}`;
server/routes/public.ts:30:      applicationId, 
server/routes/public.ts:43:    const { applicationId, filename, objectKey } = req.body;
server/routes/public.ts:47:    console.log(`üìÑ [MONITOR] App ID: ${applicationId}, File: ${filename}`);
server/routes/public.ts:48:    console.log(`‚úÖ Document confirmed: ${filename} for application ${applicationId} (S3 key: ${objectKey})`);
server/routes/public.ts:61:// GET /api/public/applications/:id/documents.zip
server/routes/public.ts:62:r.get("/applications/:id/documents.zip", async (req, res) => {
server/routes/public.ts:64:    const { id: applicationId } = req.params;
server/routes/public.ts:66:    res.setHeader('Content-Type', 'application/zip');
server/routes/public.ts:67:    res.setHeader('Content-Disposition', `attachment; filename="app-${applicationId}-documents.zip"`);
server/routes/public.ts:81:    const demoContent1 = `Application ID: ${applicationId}\nDocument: Demo Bank Statement\nGenerated: ${new Date().toISOString()}\n\n[This would contain actual bank statement content in production]`;
server/routes/public.ts:82:    const demoContent2 = `Application ID: ${applicationId}\nDocument: Demo Income Statement\nGenerated: ${new Date().toISOString()}\n\n[This would contain actual income statement content in production]`;
server/routes/public.ts:86:    archive.append(`Application ${applicationId} processed successfully`, { name: 'readme.txt' });
server/routes/public.ts:89:    console.log(`‚úÖ ZIP download generated for application ${applicationId}`);
server/routes/public.ts:99:// POST /api/public/applications
server/routes/public.ts:100:r.post("/applications", async (req, res) => {
server/routes/public.ts:108:    const applicationId = crypto.randomUUID();
server/routes/public.ts:110:    monitor("Application received", { 
server/routes/public.ts:118:    monitorEvent("APPLICATION_CREATED", { 
server/routes/public.ts:119:      appId: applicationId,
server/routes/public.ts:131:      monitor("Application processed", lenderResponse);
server/routes/public.ts:140:      const { mapToCanonical } = await import('../mappings/applicationFieldMap');
server/routes/public.ts:172:        INSERT INTO applications (
server/routes/public.ts:179:        applicationId,
server/routes/public.ts:189:      console.log(`üíæ Application saved with comprehensive data: ${applicationId} (${coverage}% field coverage)`);
server/routes/public.ts:197:    // ‚úÖ MONITOR: WebSocket broadcast for real-time pipeline updates
server/routes/public.ts:199:      const { broadcastPipelineUpdate } = await import('../websocket');
server/routes/public.ts:200:      broadcastPipelineUpdate(applicationId, 'created');
server/routes/public.ts:201:      console.log("üì° [PIPELINE-BROADCAST] created:", applicationId);
server/routes/public.ts:206:    console.log(`‚úÖ Application created: ${applicationId}`);
server/routes/public.ts:209:      id: applicationId,
server/routes/public.ts:210:      applicationId: applicationId,
server/routes/public.ts:212:      message: "Application submitted successfully",
server/routes/public.ts:218:    console.error("Application creation error:", error);
server/queues/retryQueue.ts:22:  applicationId: string;
server/queues/retryQueue.ts:56:  const { applicationId, fileBuffer, fileName, documentType, attempt } = job.data;
server/queues/retryQueue.ts:62:    const s3Result = await uploadToS3(fileBuffer, fileName, applicationId);
server/queues/retryQueue.ts:74:      applicationId: applicationId,
server/queues/retryQueue.ts:89:    await logRetrySuccess(applicationId, fileName, documentId);
server/queues/retryQueue.ts:99:          applicationId,
server/queues/retryQueue.ts:120:        .where(eq(retryUploadLogs.applicationId, applicationId))
server/queues/retryQueue.ts:147:  const { applicationId, fileName, attempt } = job.data;
server/queues/retryQueue.ts:157:      .where(eq(retryUploadLogs.applicationId, applicationId))
server/queues/retryQueue.ts:179:          applicationId,
server/routes/wsTestEmit.ts:4:  emitApplicationsUpdate, 
server/routes/wsTestEmit.ts:5:  emitPipelineUpdate 
server/routes/wsTestEmit.ts:18:      case "applications:update":
server/routes/wsTestEmit.ts:19:        emitApplicationsUpdate();
server/routes/wsTestEmit.ts:21:      case "pipeline:update":
server/routes/wsTestEmit.ts:22:        emitPipelineUpdate();
server/routes/production-health.ts:22:        (SELECT COUNT(*) FROM applications) as total_applications
server/routes/production-health.ts:36:        totalApplications: dbStats.rows[0]?.total_applications || 0
server/routes/crud.ts:3:import { lenders, lenderProducts, applications, users } from "../../shared/schema";
server/routes/crud.ts:91:// APPLICATIONS READ (uses existing table structure)
server/routes/crud.ts:92:r.get("/applications", scopeByTenant, async (req: TenantRequest, res) => {
server/routes/crud.ts:96:    const whereClause = eq(applications.tenantId, req.tenant);
server/routes/crud.ts:98:    const items = await db.select().from(applications)
server/routes/crud.ts:100:      .orderBy(desc(applications.createdAt))
server/routes/crud.ts:104:    const totalResult = await db.select({ count: count() }).from(applications)
server/routes/crud.ts:110:    console.error("Applications GET error:", error);
server/routes/applications.normalized.ts:9:  // Map database status to proper pipeline stages
server/routes/applications.normalized.ts:31:// GET /normalized - canonical list with field mapping (mounted at /api/applications)
server/routes/applications.normalized.ts:34:    console.log('üéØ [NORMALIZED] Fetching applications with field mapping...');
server/routes/applications.normalized.ts:42:      FROM applications a 
server/routes/applications.normalized.ts:51:    // Normalize each application using the field mapping
server/routes/applications.normalized.ts:54:    console.log('‚úÖ Normalized', items.length, 'applications');
server/routes/applications.normalized.ts:62:    console.error('‚ùå Error in normalized applications route:', error);
server/routes/applications.normalized.ts:70:// GET /normalized/:id - single normalized application (mounted at /api/applications) 
server/routes/applications.normalized.ts:76:      FROM applications a 
server/routes/applications.normalized.ts:86:    console.error('‚ùå Error fetching single normalized application:', error);
server/routes/applications.normalized.ts:91:// Pipeline board endpoint (mounted at /api/pipeline)
server/routes/applications.normalized.ts:94:    console.log('üéØ [NORMALIZED] Fetching pipeline board with lanes...');
server/routes/applications.normalized.ts:96:    // Get applications from DB
server/routes/applications.normalized.ts:102:      FROM applications a 
server/routes/applications.normalized.ts:129:    console.error('‚ùå Error in normalized pipeline board route:', error);
server/jobs/jobs_sla_watch.ts:16:    // For now, skip SLA monitoring until applications schema is properly defined
server/jobs/jobs_sla_watch.ts:17:    console.log('[SLA-WATCH] SLA monitoring temporarily disabled - applications schema needs Drizzle migration');
server/routes/twilio/logs.ts:18:    message: 'Your loan application has been approved!',
server/routes/pipeline-db.ts:3:import { applications } from "../../shared/schema";
server/routes/pipeline-db.ts:8:// Define pipeline stages to match existing system
server/routes/pipeline-db.ts:9:const PIPELINE_STAGES = ["new", "requires_docs", "in_review", "lender", "accepted", "declined"] as const;
server/routes/pipeline-db.ts:10:type Stage = typeof PIPELINE_STAGES[number];
server/routes/pipeline-db.ts:12:// Map database application status to pipeline stages
server/routes/pipeline-db.ts:26:// GET /api/pipeline/board - Get pipeline board from real database
server/routes/pipeline-db.ts:30:      id: applications.id,
server/routes/pipeline-db.ts:31:      businessName: applications.legalBusinessName,
server/routes/pipeline-db.ts:32:      requestedAmount: applications.requestedAmount,
server/routes/pipeline-db.ts:33:      status: applications.status,
server/routes/pipeline-db.ts:34:      createdAt: applications.createdAt,
server/routes/pipeline-db.ts:35:      docsComplete: applications.isReadyForLenders
server/routes/pipeline-db.ts:36:    }).from(applications)
server/routes/pipeline-db.ts:37:      .orderBy(desc(applications.createdAt))
server/routes/pipeline-db.ts:67:      order: PIPELINE_STAGES,
server/routes/pipeline-db.ts:71:    console.error("Error fetching pipeline board:", error);
server/routes/pipeline-db.ts:72:    res.status(500).json({ error: "Failed to fetch pipeline board" });
server/routes/pipeline-db.ts:76:// GET /api/pipeline/cards/:id - Get single card details
server/routes/pipeline-db.ts:77:router.get("/cards/:id", async (req, res) => {
server/routes/pipeline-db.ts:80:      .from(applications)
server/routes/pipeline-db.ts:81:      .where(eq(applications.id, req.params.id))
server/routes/pipeline-db.ts:104:    console.error("Error fetching card:", error);
server/routes/pipeline-db.ts:105:    res.status(500).json({ error: "Failed to fetch card" });
server/routes/pipeline-db.ts:109:// PATCH /api/pipeline/cards/:id/move - Move card to new stage
server/routes/pipeline-db.ts:110:router.patch("/cards/:id/move", async (req, res) => {
server/routes/pipeline-db.ts:114:    if (!PIPELINE_STAGES.includes(to)) {
server/routes/pipeline-db.ts:130:    const result = await db.update(applications)
server/routes/pipeline-db.ts:135:      .where(eq(applications.id, req.params.id))
server/routes/pipeline-db.ts:144:      id: applications.id,
server/routes/pipeline-db.ts:145:      businessName: applications.legalBusinessName,
server/routes/pipeline-db.ts:146:      requestedAmount: applications.requestedAmount,
server/routes/pipeline-db.ts:147:      status: applications.status,
server/routes/pipeline-db.ts:148:      createdAt: applications.createdAt,
server/routes/pipeline-db.ts:149:      docsComplete: applications.isReadyForLenders
server/routes/pipeline-db.ts:150:    }).from(applications)
server/routes/pipeline-db.ts:151:      .orderBy(desc(applications.createdAt))
server/routes/pipeline-db.ts:181:      board: { order: PIPELINE_STAGES, lanes }
server/routes/pipeline-db.ts:184:    console.error("Error moving card:", error);
server/routes/pipeline-db.ts:185:    res.status(500).json({ error: "Failed to move card" });
server/jobs/lib.ts:22:export async function lastActivityAt(opts: { contactId?: string; applicationId?: string }) {
server/jobs/lib.ts:27:  //     ...(opts.applicationId ? { applicationId: opts.applicationId } : {}) 
server/routes/users-api.ts:393:      // Get all applications that reference this user
server/routes/users-api.ts:394:      const { applications, documents } = await import('../../shared/schema');
server/routes/users-api.ts:395:      const userApps = await db.select({ id: applications.id })
server/routes/users-api.ts:396:        .from(applications)
server/routes/users-api.ts:397:        .where(eq(applications.contactId, id));
server/routes/users-api.ts:402:        // First delete documents that reference these applications
server/routes/users-api.ts:405:            .where(eq(documents.applicationId, appId))
server/routes/users-api.ts:409:            console.log(`üóëÔ∏è [CASCADE] Deleted ${deletedDocs.length} documents for application: ${appId}`);
server/routes/users-api.ts:413:        // Then delete the applications
server/routes/users-api.ts:414:        const deletedApps = await db.delete(applications)
server/routes/users-api.ts:415:          .where(eq(applications.contactId, id))
server/routes/users-api.ts:416:          .returning({ id: applications.id });
server/routes/users-api.ts:418:        console.log(`üóëÔ∏è [CASCADE] Deleted ${deletedApps.length} applications for user: ${existingUser[0].email}`);
server/routes/publicApplicationDocuments.ts:31:    'application/pdf',
server/routes/publicApplicationDocuments.ts:32:    'application/x-pdf',
server/routes/publicApplicationDocuments.ts:33:    'application/octet-stream', // fallback for PDFs
server/routes/publicApplicationDocuments.ts:35:    'application/msword',
server/routes/publicApplicationDocuments.ts:36:    'application/vnd.openxmlformats-officedocument.wordprocessingml.document',
server/routes/publicApplicationDocuments.ts:41:    'application/json',
server/routes/publicApplicationDocuments.ts:43:    'application/vnd.ms-excel',
server/routes/publicApplicationDocuments.ts:44:    'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet'
server/routes/publicApplicationDocuments.ts:85:  'signed_application',
server/routes/publicApplicationDocuments.ts:96:// POST /api/public/applications/:id/documents
server/routes/publicApplicationDocuments.ts:99:  console.log(`‚úÖ [MONITOR] Document upload request received for application ${req.params.id}`);
server/routes/publicApplicationDocuments.ts:106:    const rawApplicationId = req.params.id;
server/routes/publicApplicationDocuments.ts:111:    const actualId = rawApplicationId.replace(/^test-/, '');
server/routes/publicApplicationDocuments.ts:113:    console.log(`üì§ [Public Documents] Application ID: ${rawApplicationId} ‚Üí ${actualId}`);
server/routes/publicApplicationDocuments.ts:121:        field: 'applicationId',
server/routes/publicApplicationDocuments.ts:122:        message: 'Invalid application ID format'
server/routes/publicApplicationDocuments.ts:151:      console.log(`‚ùå [Public Documents] Validation failed for ${rawApplicationId}:`, validationErrors);
server/routes/publicApplicationDocuments.ts:164:      if (validationErrors.some(err => err.field === 'applicationId')) {
server/routes/publicApplicationDocuments.ts:166:          error: 'Invalid application ID format'
server/routes/publicApplicationDocuments.ts:176:    console.log(`üîç [Public Documents] Validating application: ${actualId}`);
server/routes/publicApplicationDocuments.ts:178:    // Check if application exists and is in draft status
server/routes/publicApplicationDocuments.ts:180:    const applicationResult = await db.query.applications.findFirst({
server/routes/publicApplicationDocuments.ts:181:      where: (applications, { eq }) => eq(applications.id, actualId)
server/routes/publicApplicationDocuments.ts:184:    if (!applicationResult) {
server/routes/publicApplicationDocuments.ts:185:      // Clean up temporary file if application not found
server/routes/publicApplicationDocuments.ts:189:          console.log(`üßπ [PUBLIC UPLOAD] Cleaned up temporary file for non-existent application: ${file.path}`);
server/routes/publicApplicationDocuments.ts:196:        error: 'Application not found',
server/routes/publicApplicationDocuments.ts:197:        details: `No application found with ID: ${actualId}`
server/routes/publicApplicationDocuments.ts:216:    console.log(`‚úÖ [MONITOR] Application: ${actualId}`);
server/routes/publicApplicationDocuments.ts:223:        applicationId: rawApplicationId,
server/routes/lender-matches.ts:3:import { applications, lenderProducts, lenders } from '../../shared/schema';
server/routes/lender-matches.ts:8:interface MatchedApplication {
server/routes/lender-matches.ts:10:  applicationId: string;
server/routes/lender-matches.ts:24:  application: any,
server/routes/lender-matches.ts:36:  if (application.requestedAmount >= product.minimum_lending_amount && 
server/routes/lender-matches.ts:37:      application.requestedAmount <= product.maximum_lending_amount) {
server/routes/lender-matches.ts:42:      Math.abs(application.requestedAmount - product.minimum_lending_amount),
server/routes/lender-matches.ts:43:      Math.abs(application.requestedAmount - product.maximum_lending_amount)
server/routes/lender-matches.ts:51:  if (application.country === product.country_offered || product.country_offered === 'Global') {
server/routes/lender-matches.ts:56:  if (application.creditScore && product.minimum_credit_score) {
server/routes/lender-matches.ts:57:    if (application.creditScore >= product.minimum_credit_score) {
server/routes/lender-matches.ts:61:      const deviation = product.minimum_credit_score - application.creditScore;
server/routes/lender-matches.ts:71:  if (application.purpose && product.product_category) {
server/routes/lender-matches.ts:72:    const purposeLower = application.purpose.toLowerCase();
server/routes/lender-matches.ts:93:// GET /api/lender/matches - Get matched applications for authenticated lender
server/routes/lender-matches.ts:116:    // Get all pending applications (mock data for now)
server/routes/lender-matches.ts:117:    const mockApplications = [
server/routes/lender-matches.ts:170:    const matches: MatchedApplication[] = [];
server/routes/lender-matches.ts:172:    // Calculate matches for each application
server/routes/lender-matches.ts:173:    for (const application of mockApplications) {
server/routes/lender-matches.ts:174:      const applicationMatches = [];
server/routes/lender-matches.ts:180:        const score = calculateMatchScore(application, product);
server/routes/lender-matches.ts:191:          id: `match-${application.id}`,
server/routes/lender-matches.ts:192:          applicationId: application.id,
server/routes/lender-matches.ts:193:          applicantName: application.applicantName,
server/routes/lender-matches.ts:194:          requestedAmount: application.requestedAmount,
server/routes/lender-matches.ts:195:          purpose: application.purpose,
server/routes/lender-matches.ts:196:          country: application.country,
server/routes/lender-matches.ts:197:          creditScore: application.creditScore,
server/routes/lender-matches.ts:198:          status: application.status,
server/routes/lender-matches.ts:201:          submittedAt: application.submittedAt
server/routes/lender-matches.ts:222:      error: 'Failed to process application matches',
server/routes/lender-matches.ts:271:    // 3. Update the application status
server/routes/oauth-connect.ts:126:        'Content-Type': 'application/x-www-form-urlencoded',
server/routes/oauth-connect.ts:127:        'Accept': 'application/json'
server/services/pipelineService.ts:2: * üöÄ AUTOMATED SALES PIPELINE SERVICE
server/services/pipelineService.ts:4: * Automatically moves applications between pipeline stages based on document status
server/services/pipelineService.ts:7: * Pipeline Stages:
server/services/pipelineService.ts:18:import { applications, documents } from '@shared/schema';
server/services/pipelineService.ts:22:export interface PipelineStageEvaluation {
server/services/pipelineService.ts:36:export class PipelineService {
server/services/pipelineService.ts:39:   * Evaluate what stage an application should be in based on current data
server/services/pipelineService.ts:41:  static async evaluateApplicationStage(applicationId: string): Promise<PipelineStageEvaluation> {
server/services/pipelineService.ts:43:      console.log(`üîç [PIPELINE] Evaluating stage for application: ${applicationId}`);
server/services/pipelineService.ts:45:      // Get application data
server/services/pipelineService.ts:48:          id: applications.id,
server/services/pipelineService.ts:50:          status: applications.status,
server/services/pipelineService.ts:51:          createdAt: applications.createdAt
server/services/pipelineService.ts:53:        .from(applications)
server/services/pipelineService.ts:54:        .where(eq(applications.id, applicationId))
server/services/pipelineService.ts:58:        throw new Error('Application not found');
server/services/pipelineService.ts:61:      const application = appResult[0];
server/services/pipelineService.ts:62:      const currentStage = application.stage || 'New';
server/services/pipelineService.ts:73:        .where(eq(documents.applicationId, applicationId));
server/services/pipelineService.ts:85:        WHERE application_id = ${applicationId}
server/services/pipelineService.ts:91:      console.log(`üìä [PIPELINE] Document stats - Total: ${totalDocs}, Accepted: ${acceptedDocs}, Rejected: ${rejectedDocs}, Pending: ${pendingDocs}, Missing: ${missingDocs}`);
server/services/pipelineService.ts:93:      // CORRECTED PIPELINE RULES: Strict enforcement per user requirements
server/services/pipelineService.ts:100:        reason = 'PIPELINE MISCLASSIFICATION FIX: Cannot be "Off to Lender" with 0 documents';
server/services/pipelineService.ts:106:          reason = `PIPELINE FIX: Cannot be "Off to Lender" with ${rejectedDocs} rejected documents`;
server/services/pipelineService.ts:109:          reason = `PIPELINE FIX: Cannot be "Off to Lender" with ${pendingDocs} pending documents`;
server/services/pipelineService.ts:112:      // Rule 1: Applications with no documents ‚Üí "Requires Docs"
server/services/pipelineService.ts:138:      const evaluation: PipelineStageEvaluation = {
server/services/pipelineService.ts:152:      console.log(`‚úÖ [PIPELINE] Evaluation complete:`, evaluation);
server/services/pipelineService.ts:156:      console.error('‚ùå [PIPELINE] Error evaluating application stage:', error);
server/services/pipelineService.ts:162:   * Evaluate and update application stage in one operation
server/services/pipelineService.ts:164:  static async evaluateAndUpdateStage(applicationId: string) {
server/services/pipelineService.ts:166:      console.log(`üîÑ [PIPELINE] Evaluating and updating stage for application: ${applicationId}`);
server/services/pipelineService.ts:168:      const evaluation = await this.evaluateApplicationStage(applicationId);
server/services/pipelineService.ts:171:        console.log(`üîÑ [PIPELINE] Stage needs update: ${evaluation.currentStage} ‚Üí ${evaluation.suggestedStage}`);
server/services/pipelineService.ts:173:        // Update application stage
server/services/pipelineService.ts:178:          UPDATE applications 
server/services/pipelineService.ts:182:          WHERE id = ${applicationId}
server/services/pipelineService.ts:185:        console.log(`‚úÖ [PIPELINE] Application ${applicationId} stage updated to: ${evaluation.suggestedStage}`);
server/services/pipelineService.ts:198:            console.log(`üì± [PIPELINE] Triggering SMS: ${templateType} for stage: ${evaluation.suggestedStage}`);
server/services/pipelineService.ts:202:              sendEnhancedSMS(applicationId, templateType as any)
server/services/pipelineService.ts:205:                    console.log(`‚úÖ [PIPELINE] SMS sent for stage transition: ${evaluation.currentStage} ‚Üí ${evaluation.suggestedStage}`);
server/services/pipelineService.ts:207:                    console.error(`‚ùå [PIPELINE] SMS failed for stage transition:`, result.error);
server/services/pipelineService.ts:211:                  console.error(`‚ùå [PIPELINE] SMS error for stage transition:`, error);
server/services/pipelineService.ts:214:              console.error(`‚ùå [PIPELINE] Failed to import SMS service:`, importError);
server/services/pipelineService.ts:218:          console.error(`‚ùå [PIPELINE] SMS notification error:`, smsError);
server/services/pipelineService.ts:219:          // Don't fail pipeline update if SMS fails
server/services/pipelineService.ts:229:        console.log(`‚è≠Ô∏è [PIPELINE] No stage update needed for application: ${applicationId}`);
server/services/pipelineService.ts:239:      console.error('‚ùå [PIPELINE] Error in evaluateAndUpdateStage:', error);
server/services/pipelineService.ts:245:   * Update application stage based on evaluation
server/services/pipelineService.ts:247:  static async updateApplicationStage(applicationId: string, evaluation: PipelineStageEvaluation): Promise<void> {
server/services/pipelineService.ts:250:        console.log(`‚è∏Ô∏è [PIPELINE] No stage update needed for ${applicationId}`);
server/services/pipelineService.ts:254:      console.log(`üîÑ [PIPELINE] Updating ${applicationId}: ${evaluation.currentStage} ‚Üí ${evaluation.suggestedStage}`);
server/services/pipelineService.ts:258:        .update(applications)
server/services/pipelineService.ts:262:        .where(eq(applications.id, applicationId));
server/services/pipelineService.ts:265:      await db.execute(sql`UPDATE applications SET stage = ${evaluation.suggestedStage}, updated_at = CURRENT_TIMESTAMP WHERE id = ${applicationId}`);
server/services/pipelineService.ts:267:      // Log the stage change using raw SQL since application_stage_history is not in schema
server/services/pipelineService.ts:269:        INSERT INTO application_stage_history (
server/services/pipelineService.ts:270:          application_id, previous_stage, new_stage, reason, changed_at
server/services/pipelineService.ts:271:        ) VALUES (${applicationId}, ${evaluation.currentStage}, ${evaluation.suggestedStage}, ${evaluation.reason}, CURRENT_TIMESTAMP)
server/services/pipelineService.ts:274:      console.log(`‚úÖ [PIPELINE] Stage updated: ${applicationId} ‚Üí ${evaluation.suggestedStage}`);
server/services/pipelineService.ts:279:        console.log(`üì± [PIPELINE] Triggering SMS for stage transition: ${evaluation.currentStage} ‚Üí ${evaluation.suggestedStage}`);
server/services/pipelineService.ts:281:        const smsResult = await sendStageTransitionSMS(applicationId, evaluation.currentStage, evaluation.suggestedStage);
server/services/pipelineService.ts:283:          console.log(`‚úÖ [PIPELINE] SMS notification sent successfully for ${applicationId}`);
server/services/pipelineService.ts:285:          console.log(`‚ö†Ô∏è [PIPELINE] SMS notification failed: ${smsResult.error}`);
server/services/pipelineService.ts:288:        console.error(`‚ùå [PIPELINE] SMS integration error:`, smsError);
server/services/pipelineService.ts:289:        // Don't fail the pipeline update if SMS fails
server/services/pipelineService.ts:295:        io.emit('pipeline:stage-changed', {
server/services/pipelineService.ts:296:          applicationId,
server/services/pipelineService.ts:302:        console.log(`üì° [PIPELINE] Real-time update sent for ${applicationId}`);
server/services/pipelineService.ts:306:      console.error('‚ùå [PIPELINE] Error updating application stage:', error);
server/services/pipelineService.ts:312:   * Main function: Evaluate and update application stage automatically
server/services/pipelineService.ts:314:  static async processApplicationStage(applicationId: string): Promise<PipelineStageEvaluation> {
server/services/pipelineService.ts:316:      console.log(`üöÄ [PIPELINE] Processing stage for application: ${applicationId}`);
server/services/pipelineService.ts:318:      const evaluation = await this.evaluateApplicationStage(applicationId);
server/services/pipelineService.ts:321:        await this.updateApplicationStage(applicationId, evaluation);
server/services/pipelineService.ts:327:      console.error('‚ùå [PIPELINE] Error processing application stage:', error);
server/services/pipelineService.ts:333:   * Trigger pipeline evaluation when documents change
server/services/pipelineService.ts:335:  static async onDocumentChange(applicationId: string, changeType: 'upload' | 'status_change' | 'delete'): Promise<void> {
server/services/pipelineService.ts:337:      console.log(`üìÑ [PIPELINE] Document ${changeType} detected for ${applicationId}`);
server/services/pipelineService.ts:342:      await this.processApplicationStage(applicationId);
server/services/pipelineService.ts:345:      console.error('‚ùå [PIPELINE] Error handling document change:', error);
server/services/pipelineService.ts:350:   * Batch process all applications (for maintenance)
server/services/pipelineService.ts:352:  static async processAllApplications(): Promise<void> {
server/services/pipelineService.ts:354:      console.log('üîÑ [PIPELINE] Starting batch processing of all applications...');
server/services/pipelineService.ts:356:      const applicationsResult = await db
server/services/pipelineService.ts:357:        .select({ id: applications.id })
server/services/pipelineService.ts:358:        .from(applications)
server/services/pipelineService.ts:359:        .where(ne(applications.status, 'declined'))
server/services/pipelineService.ts:360:        .orderBy(desc(applications.createdAt));
server/services/pipelineService.ts:365:      for (const app of applicationsResult) {
server/services/pipelineService.ts:367:          const evaluation = await this.processApplicationStage(app.id);
server/services/pipelineService.ts:373:          console.error(`‚ùå [PIPELINE] Error processing ${app.id}:`, error);
server/services/pipelineService.ts:377:      console.log(`‚úÖ [PIPELINE] Batch processing complete: ${processed} processed, ${updated} updated`);
server/services/pipelineService.ts:380:      console.error('‚ùå [PIPELINE] Error in batch processing:', error);
server/services/pipelineService.ts:385:export default PipelineService;
server/routes/pipeline.mjs:1:// Stub file for pipeline router
server/routes/pipeline.mjs:5:// TODO: implement pipeline logic
server/routes/pipeline.mjs:6:router.get('/pipeline', (req, res) => {
server/routes/pipeline.mjs:7:  res.json({ status: 'ok', message: 'Pipeline stub' });
server/jobs/jobs_daily_brief.ts:14:  const apps = await db.applications.findMany({ 
server/routes/voice-outgoing.ts:47:          Hello, this is a call from Boreal Financial regarding ${contactName ? `your application, ${contactName}` : 'your application'}. 
server/jobs/jobs_ads_anomaly.ts:30:        headers: { 'Content-Type': 'application/json' },
server/services/smsService.ts:67: * Send SMS for specific application using existing enhanced SMS system
server/services/smsService.ts:69:export async function sendSmsForApplication(
server/services/smsService.ts:70:  applicationId: string,
server/services/smsService.ts:74:  return sendEnhancedSMS(applicationId, templateType, customData);
server/routes/marketing-integration.ts:202:        a.status as application_status
server/routes/marketing-integration.ts:205:      LEFT JOIN applications a ON c.id = a.contact_id
server/routes/marketing-integration.ts:266:      LEFT JOIN applications a ON c.id = a.contact_id
server/routes/marketing-integration.ts:355:        COUNT(DISTINCT a.id) as applications,
server/routes/marketing-integration.ts:359:      LEFT JOIN applications a ON ma.contact_id = a.contact_id
server/routes/marketing-integration.ts:371:        COUNT(CASE WHEN te.type = 'application_submit' THEN 1 END) as applications,
server/routes/marketing-integration.ts:376:      LEFT JOIN applications a ON ma.contact_id = a.contact_id
server/services/microsoftGraphService.ts:77:      headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
server/services/microsoftGraphService.ts:118:        'Content-Type': 'application/json',
server/services/documentAuditService.ts:25:          applicationId: "bc4260af-f35e-42c7-a637-4422fb5fb048",
server/services/documentAuditService.ts:100:        const storageKey = await s3Storage.set(buffer, doc.file_name, doc.application_id);
server/jobs/contactsGuard.ts:17:      // Fetch all applications with contact data
server/jobs/contactsGuard.ts:22:        FROM applications a 
server/jobs/contactsGuard.ts:30:      // Group applications by canonical email
server/jobs/contactsGuard.ts:74:          applicationsCount: records.length,
server/jobs/contactsGuard.ts:75:          applications: records.map((r: any) => r.id),
server/services/documentNotificationService.ts:2:import { documents, applications } from '../../shared/schema';
server/services/documentNotificationService.ts:7:  applicationId: string;
server/services/documentNotificationService.ts:71:          d.application_id,
server/services/documentNotificationService.ts:79:        JOIN applications a ON d.application_id = a.id
server/services/documentNotificationService.ts:89:        applicationId: row.application_id,
server/services/documentNotificationService.ts:143:üÜî APPLICATION: ${submission.applicationId}
server/services/aiCreditSummaryService.ts:8:import { applications, contacts, documents } from '../../shared/schema';
server/services/aiCreditSummaryService.ts:27:  applicationId: string;
server/services/aiCreditSummaryService.ts:42: * Generate AI credit summary for an application
server/services/aiCreditSummaryService.ts:45:  applicationId: string,
server/services/aiCreditSummaryService.ts:53:  console.log(`üß† [AI-SUMMARY] Generating credit summary for application: ${applicationId}`);
server/services/aiCreditSummaryService.ts:60:    // Fetch application data with all related information
server/services/aiCreditSummaryService.ts:61:    const appData = await fetchApplicationData(applicationId);
server/services/aiCreditSummaryService.ts:64:      throw new Error(`Application not found: ${applicationId}`);
server/services/aiCreditSummaryService.ts:75:      applicationId,
server/services/aiCreditSummaryService.ts:167:    const filename = `CreditSummary-${existingSummary.applicationId}.pdf`;
server/services/aiCreditSummaryService.ts:171:      mimeType: 'application/pdf'
server/services/aiCreditSummaryService.ts:193:      applicationId: existingSummary.applicationId,
server/services/aiCreditSummaryService.ts:200:      mimeType: 'application/pdf',
server/services/aiCreditSummaryService.ts:212:        existingSummary.applicationId,
server/services/aiCreditSummaryService.ts:238: * Fetch comprehensive application data for AI processing
server/services/aiCreditSummaryService.ts:240:async function fetchApplicationData(applicationId: string): Promise<CreditSummaryData | null> {
server/services/aiCreditSummaryService.ts:242:    // Get application with contact info
server/services/aiCreditSummaryService.ts:245:        id: applications.id,
server/services/aiCreditSummaryService.ts:246:        businessName: applications.businessName,
server/services/aiCreditSummaryService.ts:247:        requestedAmount: applications.requestedAmount,
server/services/aiCreditSummaryService.ts:248:        useOfFunds: applications.useOfFunds,
server/services/aiCreditSummaryService.ts:249:        industry: applications.industry,
server/services/aiCreditSummaryService.ts:250:        revenueRange: applications.revenueRange,
server/services/aiCreditSummaryService.ts:251:        yearsInBusiness: applications.yearsInBusiness,
server/services/aiCreditSummaryService.ts:252:        businessWebsite: applications.businessWebsite,
server/services/aiCreditSummaryService.ts:257:      .from(applications)
server/services/aiCreditSummaryService.ts:258:      .leftJoin(contacts, eq(applications.contactId, contacts.id))
server/services/aiCreditSummaryService.ts:259:      .where(eq(applications.id, applicationId));
server/services/aiCreditSummaryService.ts:267:      .where(eq(documents.applicationId, applicationId));
server/services/aiCreditSummaryService.ts:270:      applicationId,
server/services/aiCreditSummaryService.ts:284:    console.error(`‚ùå [AI-SUMMARY] Failed to fetch application data:`, error);
server/services/aiCreditSummaryService.ts:323:          system: 'You are a senior credit analyst writing a comprehensive credit summary for a business loan application.'
server/services/aiCreditSummaryService.ts:348:You are a senior credit analyst writing a comprehensive credit summary for a business loan application.
server/services/aiCreditSummaryService.ts:350:APPLICATION DETAILS:
server/services/aiCreditSummaryService.ts:432:  applicationId: string,
server/services/aiCreditSummaryService.ts:446:      applicationId,
server/services/aiCreditSummaryService.ts:540:        <p>Application ID: ${summary.applicationId}</p>
server/jobs/missingDocsReminder.ts:3: * Automated weekday SMS reminders for applications missing required documents
server/jobs/missingDocsReminder.ts:18:    // Get applications that need document reminders - include all relevant stages
server/jobs/missingDocsReminder.ts:19:    const applicationsQuery = await db.execute(sql`
server/jobs/missingDocsReminder.ts:21:      FROM applications 
server/jobs/missingDocsReminder.ts:28:    const applications = applicationsQuery.rows || applicationsQuery;
server/jobs/missingDocsReminder.ts:29:    console.log(`üì® [MISSING-DOCS-REMINDER] Found ${applications.length} applications to check`);
server/jobs/missingDocsReminder.ts:31:    if (applications.length === 0) {
server/jobs/missingDocsReminder.ts:32:      console.log('üì® [MISSING-DOCS-REMINDER] No applications need reminders today');
server/jobs/missingDocsReminder.ts:35:        totalApplications: 0,
server/jobs/missingDocsReminder.ts:37:        message: 'No applications need document reminders',
server/jobs/missingDocsReminder.ts:44:    // Check each application for missing documents
server/jobs/missingDocsReminder.ts:45:    for (const app of applications) {
server/jobs/missingDocsReminder.ts:50:          WHERE application_id = ${app.id} 
server/jobs/missingDocsReminder.ts:65:    console.log(`üì® [MISSING-DOCS-REMINDER] ${remindersNeeded.length} applications need reminders`);
server/jobs/missingDocsReminder.ts:75:          applicationId: app.id,
server/jobs/missingDocsReminder.ts:93:          applicationId: app.id,
server/jobs/missingDocsReminder.ts:106:      totalApplications: remindersNeeded.length,
server/routes/ai-features-extended.ts:3: * Comprehensive AI enhancement suite for Staff Application
server/routes/ai-features-extended.ts:9:import { documents, contacts, applications } from '../../shared/schema';
server/routes/ai-features-extended.ts:77:    const { applicationId, lenderName } = req.body;
server/routes/ai-features-extended.ts:79:    if (!applicationId) {
server/routes/ai-features-extended.ts:80:      return res.status(400).json({ success: false, error: 'Application ID required' });
server/routes/ai-features-extended.ts:83:    // Get application data
server/routes/ai-features-extended.ts:86:      .from(applications)
server/routes/ai-features-extended.ts:87:      .where(eq(applications.id, applicationId));
server/routes/ai-features-extended.ts:90:      return res.status(404).json({ success: false, error: 'Application not found' });
server/routes/ai-features-extended.ts:93:    const prompt = `Draft a professional email to submit this loan application to ${lenderName || 'the lender'}:
server/routes/ai-features-extended.ts:112:    console.log(`‚úÖ [AI-EMAIL] Email drafted for: ${applicationId}`);
server/routes/ai-features-extended.ts:131: * GET /api/ai-extended/summary-history/:applicationId
server/routes/ai-features-extended.ts:133:router.get('/summary-history/:applicationId', async (req, res) => {
server/routes/ai-features-extended.ts:135:    const { applicationId } = req.params;
server/routes/ai-features-extended.ts:187:Context: ${context || 'Loan application discussion'}
server/routes/ai-features-extended.ts:416:    const { applicationData, documentData, ocrData } = req.body;
server/routes/ai-features-extended.ts:418:    if (!applicationData) {
server/routes/ai-features-extended.ts:419:      return res.status(400).json({ success: false, error: 'Application data required' });
server/routes/ai-features-extended.ts:422:    const prompt = `Score this loan application's likelihood of funding approval (0-100):
server/routes/ai-features-extended.ts:424:Application Data:
server/routes/ai-features-extended.ts:425:${JSON.stringify(applicationData, null, 2)}
server/routes/ai-features-extended.ts:471:    const { applicationData, ocrResults, metadata } = req.body;
server/routes/ai-features-extended.ts:473:    if (!applicationData) {
server/routes/ai-features-extended.ts:474:      return res.status(400).json({ success: false, error: 'Application data required' });
server/routes/ai-features-extended.ts:477:    const prompt = `Analyze this application for potential fraud indicators:
server/routes/ai-features-extended.ts:479:Application:
server/routes/ai-features-extended.ts:480:${JSON.stringify(applicationData, null, 2)}
server/routes/application-detail.mjs:1:// Stub file for application detail router
server/routes/application-detail.mjs:5:// TODO: implement application detail logic
server/routes/application-detail.mjs:6:router.get('/application-detail/:id', (req, res) => {
server/routes/application-detail.mjs:7:  res.json({ status: 'ok', message: 'Application detail stub', id: req.params.id });
server/services/uploadService.ts:24:  applicationId: string,
server/services/uploadService.ts:32:  console.log(`üîß [UPLOAD-SERVICE] Processing upload: ${filename} for application ${applicationId}`);
server/services/uploadService.ts:38:    const s3Result = await uploadToS3(buffer, filename, applicationId);
server/services/uploadService.ts:50:      applicationId: applicationId,
server/services/uploadService.ts:82:        applicationId: applicationId,
server/services/uploadService.ts:117:  applicationId: string;
server/services/uploadService.ts:125:      applicationId: payload.applicationId,
server/services/uploadService.ts:143:export async function logRetrySuccess(applicationId: string, fileName: string, documentId: string) {
server/services/uploadService.ts:149:      .where(eq(retryUploadLogs.applicationId, applicationId))
server/routes/ai-summary.ts:19: * Get existing summary for an application
server/routes/ai-summary.ts:21:router.get('/:applicationId', async (req, res) => {
server/routes/ai-summary.ts:23:    const { applicationId } = req.params;
server/routes/ai-summary.ts:25:    console.log(`üìä [AI-SUMMARY] Fetching summary for application: ${applicationId}`);
server/routes/ai-summary.ts:30:      .where(eq(creditSummaries.applicationId, applicationId))
server/routes/ai-summary.ts:53: * Generate new AI summary for an application
server/routes/ai-summary.ts:57:    const { applicationId, templateId } = req.body;
server/routes/ai-summary.ts:59:    if (!applicationId) {
server/routes/ai-summary.ts:62:        error: 'Application ID is required'
server/routes/ai-summary.ts:66:    console.log(`üß† [AI-SUMMARY] Generating summary for application: ${applicationId}`);
server/routes/ai-summary.ts:68:    const result = await generateAICreditSummary(applicationId, templateId);
server/jobs/startupFixMissingPaths.ts:12:      SELECT id, file_name, file_path, application_id, file_size, checksum 
server/jobs/startupFixMissingPaths.ts:25:      const { id, file_name, file_path, application_id } = doc;
server/services/pipelineAutomation.ts:3:export class PipelineAutomationService {
server/services/pipelineAutomation.ts:6:   * Check if all required documents are accepted for an application
server/services/pipelineAutomation.ts:9:  static async checkDocumentCompletionStatus(applicationId: string) {
server/services/pipelineAutomation.ts:11:      console.log(`üîç Checking document completion for application ${applicationId}`);
server/services/pipelineAutomation.ts:13:      // Get all documents for this application
server/services/pipelineAutomation.ts:17:        WHERE application_id = $1
server/services/pipelineAutomation.ts:20:      const documentsResult = await pool.query(documentsQuery, [applicationId]);
server/services/pipelineAutomation.ts:24:        console.log(`üìÑ No documents found for application ${applicationId}`);
server/services/pipelineAutomation.ts:34:      console.log(`üìä Document status for ${applicationId}: ${verifiedDocs}/${totalDocs} verified, ${rejectedDocs} rejected, ${pendingDocs} pending`);
server/services/pipelineAutomation.ts:38:        await this.moveToLenderMatching(applicationId);
server/services/pipelineAutomation.ts:48:        await this.notifyClientOfRejection(applicationId);
server/services/pipelineAutomation.ts:63:      console.error(`‚ùå Error checking document completion for ${applicationId}:`, error);
server/services/pipelineAutomation.ts:69:   * Move application to "Lender Match" stage in pipeline
server/services/pipelineAutomation.ts:71:  static async moveToLenderMatching(applicationId: string) {
server/services/pipelineAutomation.ts:73:      console.log(`üéØ Moving application ${applicationId} to Lender Match stage`);
server/services/pipelineAutomation.ts:76:        UPDATE applications 
server/services/pipelineAutomation.ts:77:        SET pipeline_stage = 'Off to Lender',
server/services/pipelineAutomation.ts:81:        RETURNING id, pipeline_stage, status
server/services/pipelineAutomation.ts:84:      const result = await pool.query(updateQuery, [applicationId]);
server/services/pipelineAutomation.ts:87:        console.log(`‚úÖ Application ${applicationId} moved to Lender Match stage`);
server/services/pipelineAutomation.ts:90:        await this.notifyStaffOfProgression(applicationId, 'lender_match');
server/services/pipelineAutomation.ts:94:        console.log(`‚ö†Ô∏è Application ${applicationId} not found for stage update`);
server/services/pipelineAutomation.ts:95:        return { success: false, error: 'Application not found' };
server/services/pipelineAutomation.ts:99:      console.error(`‚ùå Error moving application ${applicationId} to lender matching:`, error);
server/services/pipelineAutomation.ts:107:  static async notifyClientOfRejection(applicationId: string) {
server/services/pipelineAutomation.ts:109:      console.log(`üì± Sending rejection notification for application ${applicationId}`);
server/services/pipelineAutomation.ts:111:      // Get application and contact details
server/services/pipelineAutomation.ts:114:        FROM applications 
server/services/pipelineAutomation.ts:118:      const appResult = await pool.query(appQuery, [applicationId]);
server/services/pipelineAutomation.ts:121:        console.log(`‚ö†Ô∏è Application ${applicationId} not found for notification`);
server/services/pipelineAutomation.ts:122:        return { success: false, error: 'Application not found' };
server/services/pipelineAutomation.ts:128:        console.log(`‚ö†Ô∏è No phone number found for application ${applicationId}`);
server/services/pipelineAutomation.ts:133:      const message = `Hi ${contact_first_name || 'there'}! Some documents for ${legal_business_name || 'your application'} need revision. Please check your email or contact us for details. - Boreal Financial`;
server/services/pipelineAutomation.ts:150:      console.error(`‚ùå Error sending rejection notification for ${applicationId}:`, error);
server/services/pipelineAutomation.ts:156:   * Notify staff team of automatic pipeline progression
server/services/pipelineAutomation.ts:158:  static async notifyStaffOfProgression(applicationId: string, newStage: string) {
server/services/pipelineAutomation.ts:160:      console.log(`üîî Notifying staff of progression: ${applicationId} ‚Üí ${newStage}`);
server/services/pipelineAutomation.ts:162:      // Get application details for notification
server/services/pipelineAutomation.ts:165:        FROM applications 
server/services/pipelineAutomation.ts:169:      const appResult = await pool.query(appQuery, [applicationId]);
server/services/pipelineAutomation.ts:180:      return { success: false, error: 'Application details not found' };
server/services/pipelineAutomation.ts:183:      console.error(`‚ùå Error notifying staff of progression for ${applicationId}:`, error);
server/services/pipelineAutomation.ts:191:  static async notifyDocumentUpload(applicationId: string, documentType: string, fileName: string) {
server/services/pipelineAutomation.ts:193:      console.log(`üìÑ New document uploaded: ${fileName} (${documentType}) for application ${applicationId}`);
server/services/pipelineAutomation.ts:195:      // Get application details
server/services/pipelineAutomation.ts:198:        FROM applications 
server/services/pipelineAutomation.ts:202:      const appResult = await pool.query(appQuery, [applicationId]);
server/services/pipelineAutomation.ts:213:      return { success: false, error: 'Application not found' };
server/services/pipelineAutomation.ts:216:      console.error(`‚ùå Error notifying document upload for ${applicationId}:`, error);
server/services/documents.ts:2:import { documents, applications } from '../../shared/schema';
server/services/documents.ts:12:  applicationId: z.string().uuid("Valid application ID required"),
server/services/documents.ts:22:    'application_summary_pdf',
server/services/documents.ts:33:    applicationId: string,
server/services/documents.ts:44:        applicationId,
server/services/documents.ts:52:        applicationId,
server/services/documents.ts:56:      // Verify application exists
server/services/documents.ts:57:      const [application] = await db
server/services/documents.ts:59:        .from(applications)
server/services/documents.ts:60:        .where(eq(applications.id, applicationId));
server/services/documents.ts:62:      if (!application) {
server/services/documents.ts:63:        throw new Error('Application not found');
server/services/documents.ts:67:      const storageKey = await s3Storage.set(fileBuffer, metadata.fileName, applicationId);
server/services/documents.ts:72:        applicationId,
server/services/documents.ts:90:      this.processDocumentOCR(newDocument.id, fileBuffer, metadata.documentType, applicationId).catch(error => {
server/services/documents.ts:105:  async getDocuments(applicationId: string) {
server/services/documents.ts:110:        .where(eq(documents.applicationId, applicationId));
server/services/documents.ts:119:  private async processDocumentOCR(documentId: string, fileBuffer: Buffer, documentType: string, applicationId?: string) {
server/services/documents.ts:126:      // Save OCR and AI results to database if applicationId is provided
server/services/documents.ts:127:      if (applicationId) {
server/services/documents.ts:128:        await ocrService.saveOCRResults(applicationId, documentId, ocrResults);
server/services/documents.ts:129:        console.log('üíæ [DOCUMENTS] AI results saved to database for application:', applicationId);
server/routes/pdf-generation.ts:3: * Test and bulk generate application PDFs
server/routes/pdf-generation.ts:8:  generateApplicationPDF, 
server/routes/pdf-generation.ts:9:  generateAllApplicationPDFs, 
server/routes/pdf-generation.ts:17: * Test PDF generation for a single application
server/routes/pdf-generation.ts:21:    const { applicationId } = req.body;
server/routes/pdf-generation.ts:23:    console.log(`üß™ [PDF-TEST] Starting PDF generation test`, { applicationId });
server/routes/pdf-generation.ts:25:    const result = await testPDFGeneration(applicationId);
server/routes/pdf-generation.ts:32:          applicationId: result.applicationId,
server/routes/pdf-generation.ts:55: * Generate PDF for a specific application
server/routes/pdf-generation.ts:57:router.post('/generate/:applicationId', async (req, res) => {
server/routes/pdf-generation.ts:59:    const { applicationId } = req.params;
server/routes/pdf-generation.ts:61:    console.log(`üìù [PDF-GEN] Generating PDF for application: ${applicationId}`);
server/routes/pdf-generation.ts:64:    const pdfBuffer = await generateApplicationPDF(applicationId);
server/routes/pdf-generation.ts:67:    const filename = `ApplicationSummary-${applicationId}.pdf`;
server/routes/pdf-generation.ts:69:      applicationId,
server/routes/pdf-generation.ts:72:      'generated_application_summary',
server/routes/pdf-generation.ts:80:        applicationId,
server/routes/pdf-generation.ts:97: * Generate PDFs for all applications in bulk
server/routes/pdf-generation.ts:103:    const results = await generateAllApplicationPDFs();
server/services/ocr.ts:107:    if (header.startsWith('25504446')) return 'application/pdf';
server/services/ocr.ts:110:    return 'application/octet-stream';
server/services/ocr.ts:214:  async saveOCRResults(applicationId: string, documentId: string, results: OCRResult) {
server/services/ocr.ts:219:      const { documentAnalysis, applications, bankingAnalysis } = await import('../../shared/schema');
server/services/ocr.ts:239:      // Save banking insights to applications table and banking_analysis table
server/services/ocr.ts:241:        // Update applications table with banking analysis
server/services/ocr.ts:242:        await db.update(applications)
server/services/ocr.ts:244:          .where(eq(applications.id, applicationId));
server/services/ocr.ts:249:            application_id: applicationId,
server/services/ocr.ts:256:            target: bankingAnalysis.application_id,
server/services/ocr.ts:267:          console.warn('‚ö†Ô∏è [OCR] Banking analysis table not available, saved to applications table only');
server/routes/o365-integration.ts:2: * Office 365 Integration for Staff Application
server/routes/o365-integration.ts:290:        content: description || 'Business meeting scheduled via Staff Application',
server/routes/_admin-catalog.mjs:39:      headers: { "Content-Type":"application/json", "Authorization": `Bearer ${token}` },
server/services/applications.ts:2:import { applications, documents } from '../../shared/schema';
server/services/applications.ts:7:export const applicationCreateSchema = z.object({
server/services/applications.ts:25:export type ApplicationCreateInput = z.infer<typeof applicationCreateSchema>;
server/services/applications.ts:27:export class ApplicationsService {
server/services/applications.ts:28:  async createApplication(data: ApplicationCreateInput) {
server/services/applications.ts:30:      console.log('üìù [APPLICATIONS] Creating new application:', {
server/services/applications.ts:38:      const validatedData = applicationCreateSchema.parse(data);
server/services/applications.ts:40:      // Create application record using ACTUAL database column names
server/services/applications.ts:41:      const [newApplication] = await db.insert(applications).values({
server/services/applications.ts:54:        stage: 'New', // Use valid pipeline_stage enum value (capital case)
server/services/applications.ts:55:        status: 'draft', // Use valid application_status enum value
server/services/applications.ts:60:      console.log('‚úÖ [APPLICATIONS] Application created successfully:', newApplication.id);
server/services/applications.ts:63:        id: newApplication.id,
server/services/applications.ts:64:        status: newApplication.status
server/services/applications.ts:67:      console.error('‚ùå [APPLICATIONS] Failed to create application:', error);
server/services/applications.ts:72:  async getApplication(id: string) {
server/services/applications.ts:74:      const [application] = await db.select().from(applications).where(eq(applications.id, id));
server/services/applications.ts:76:      if (!application) {
server/services/applications.ts:77:        throw new Error('Application not found');
server/services/applications.ts:80:      return application;
server/services/applications.ts:82:      console.error('‚ùå [APPLICATIONS] Failed to get application:', error);
server/services/applications.ts:87:  async updateApplicationStatus(id: string, status: string, stage?: string) {
server/services/applications.ts:92:      const [updatedApplication] = await db
server/services/applications.ts:93:        .update(applications)
server/services/applications.ts:95:        .where(eq(applications.id, id))
server/services/applications.ts:98:      if (!updatedApplication) {
server/services/applications.ts:99:        throw new Error('Application not found');
server/services/applications.ts:102:      console.log('‚úÖ [APPLICATIONS] Application status updated:', {
server/services/applications.ts:108:      return updatedApplication;
server/services/applications.ts:110:      console.error('‚ùå [APPLICATIONS] Failed to update application status:', error);
server/services/applications.ts:115:  async submitApplication(id: string) {
server/services/applications.ts:117:      console.log('üì§ [APPLICATIONS] Submitting application:', id);
server/services/applications.ts:119:      // Update application to submitted status
server/services/applications.ts:120:      const updatedApplication = await this.updateApplicationStatus(id, 'submitted', 'In Review'); // Use correct enum case
server/services/applications.ts:124:      //   .update(applications)
server/services/applications.ts:129:      //   .where(eq(applications.id, id));
server/services/applications.ts:131:      console.log('‚úÖ [APPLICATIONS] Application submitted successfully:', id);
server/services/applications.ts:134:        id: updatedApplication.id,
server/services/applications.ts:138:      console.error('‚ùå [APPLICATIONS] Failed to submit application:', error);
server/services/applications.ts:144:export const applicationsService = new ApplicationsService();
server/routes/app-submit.mjs:7: * POST /api/applications
server/routes/app-submit.mjs:11:r.post("/applications", async (req, res) => {
server/routes/app-submit.mjs:28:      `INSERT INTO applications(product_id, submission_country, product_snapshot, required_documents)
server/services/crmService.ts:4: * Automatically creates CRM contacts when applications are submitted
server/services/crmService.ts:19:  applicationId?: string;
server/services/crmService.ts:22:interface ApplicationData {
server/services/crmService.ts:37: * Auto-create CRM contacts from application submission
server/services/crmService.ts:40:export async function autoCreateContactsFromApplication(appData: ApplicationData): Promise<void> {
server/services/crmService.ts:42:    console.log(`üè¢ [CRM] Auto-creating contacts for application ${appData.id}`);
server/services/crmService.ts:64:        applicationId: appData.id
server/services/crmService.ts:83:        applicationId: appData.id
server/services/crmService.ts:96:          AND application_id = ${contact.applicationId}
server/services/crmService.ts:109:              application_id,
server/services/crmService.ts:117:              ${contact.applicationId},
server/services/crmService.ts:131:    console.log(`üè¢ [CRM] Auto-contact creation completed for application ${appData.id}`);
server/services/crmService.ts:134:    console.error(`‚ùå [CRM] Auto-contact creation failed for application ${appData.id}:`, error);
server/services/crmService.ts:159:      LEFT JOIN applications a ON c.application_id = a.id
server/services/crmService.ts:183:        application_id UUID,
server/services/crmService.ts:184:        source VARCHAR(50) DEFAULT 'application',
server/services/crmService.ts:195:      ADD COLUMN IF NOT EXISTS source VARCHAR(50) DEFAULT 'application',
server/services/crmService.ts:264:  autoCreateContactsFromApplication,
server/routes/twilio-diagnostics.ts:257:      <Say voice="alice">This is a Twilio diagnostic test call from the Staff Application. The voice calling system is working correctly.</Say>
server/services/applicationMapper.ts:1:import { mapToCanonical } from "../mappings/applicationFieldMap";
server/services/applicationMapper.ts:6:export async function applyMapping(applicationId: string, raw: any) {
server/services/applicationMapper.ts:12:      `UPDATE applications
server/services/applicationMapper.ts:19:      [applicationId, raw, canonical, unmapped, coverage]
server/services/applicationMapper.ts:24:      UPDATE applications
server/services/applicationMapper.ts:29:    `, [applicationId]);
server/routes/application-pdf.ts:5:import { applications, documents, lenders, lender_products } from "../../shared/schema.js";
server/routes/application-pdf.ts:13:  if (req.path === '/test-pdf-generator' || req.path === '/applications/generate-all-pdfs') {
server/routes/application-pdf.ts:50:// Generate application summary HTML template
server/routes/application-pdf.ts:51:function generateApplicationSummaryHTML(application: any, documents: any[], ocrData: any, lenderMatches: any[]) {
server/routes/application-pdf.ts:70:      <title>Application Summary - ${application.business_name || 'Business Application'}</title>
server/routes/application-pdf.ts:190:        <h1>Application Summary Report</h1>
server/routes/application-pdf.ts:192:        <div class="subtitle">Application ID: ${application.id}</div>
server/routes/application-pdf.ts:196:        <h2>Application Overview</h2>
server/routes/application-pdf.ts:201:              <span class="status-badge status-${application.status || 'draft'}">
server/routes/application-pdf.ts:202:                ${(application.status || 'draft').replace('_', ' ')}
server/routes/application-pdf.ts:208:            <div class="info-value">${formatDate(application.submitted_at)}</div>
server/routes/application-pdf.ts:212:            <div class="info-value">${application.stage || 'New'}</div>
server/routes/application-pdf.ts:216:            <div class="info-value">${formatCurrency(application.loan_amount)}</div>
server/routes/application-pdf.ts:226:            <div class="info-value">${application.business_name || 'Not provided'}</div>
server/routes/application-pdf.ts:230:            <div class="info-value">${application.legal_business_name || 'Not provided'}</div>
server/routes/application-pdf.ts:234:            <div class="info-value">${application.dba_name || 'Not provided'}</div>
server/routes/application-pdf.ts:238:            <div class="info-value">${application.business_type || 'Not specified'}</div>
server/routes/application-pdf.ts:242:            <div class="info-value">${application.business_email || 'Not provided'}</div>
server/routes/application-pdf.ts:246:            <div class="info-value">${application.business_phone || 'Not provided'}</div>
server/routes/application-pdf.ts:255:              <div class="info-value">${formatCurrency(application.annual_revenue)}</div>
server/routes/application-pdf.ts:259:              <div class="info-value">${application.years_in_business || 'Not specified'}</div>
server/routes/application-pdf.ts:263:              <div class="info-value">${application.number_of_employees || 'Not specified'}</div>
server/routes/application-pdf.ts:267:              <div class="info-value">${application.use_of_funds || 'Not specified'}</div>
server/routes/application-pdf.ts:278:            <div class="info-value">${application.contact_first_name || ''} ${application.contact_last_name || ''}</div>
server/routes/application-pdf.ts:282:            <div class="info-value">${application.contact_email || 'Not provided'}</div>
server/routes/application-pdf.ts:286:            <div class="info-value">${application.contact_phone || 'Not provided'}</div>
server/routes/application-pdf.ts:290:            <div class="info-value">${application.business_address || 'Not provided'}</div>
server/routes/application-pdf.ts:324:          <p><em>Detailed banking analysis available in application review system.</em></p>
server/routes/application-pdf.ts:346:        <p><em>Lender matching will be performed once application is complete and submitted.</em></p>
server/routes/application-pdf.ts:351:        <p>This application summary was generated automatically from your business lending platform.</p>
server/routes/application-pdf.ts:352:        <p>Document ID: ${application.id} | Generated: ${new Date().toISOString()}</p>
server/routes/application-pdf.ts:359:// Generate PDF for a single application
server/routes/application-pdf.ts:360:r.post("/application/:id/generate-pdf", async (req: any, res) => {
server/routes/application-pdf.ts:364:    console.log(`üîÑ Generating PDF for application ${id}...`);
server/routes/application-pdf.ts:366:    // Fetch application data
server/routes/application-pdf.ts:367:    const [applicationData] = await db
server/routes/application-pdf.ts:369:      .from(applications)
server/routes/application-pdf.ts:370:      .where(eq(applications.id, id))
server/routes/application-pdf.ts:373:    if (!applicationData) {
server/routes/application-pdf.ts:374:      return res.status(404).json({ ok: false, error: "Application not found" });
server/routes/application-pdf.ts:378:    const applicationDocuments = await db
server/routes/application-pdf.ts:381:      .where(eq(documents.applicationId, id));
server/routes/application-pdf.ts:384:    const ocrData = applicationData.financials_ocr || {};
server/routes/application-pdf.ts:390:    const htmlContent = generateApplicationSummaryHTML(
server/routes/application-pdf.ts:391:      applicationData, 
server/routes/application-pdf.ts:392:      applicationDocuments, 
server/routes/application-pdf.ts:398:    const pdfBuffer = await generatePDF(htmlContent, `application-${id}-summary.pdf`);
server/routes/application-pdf.ts:402:      applicationId: id,
server/routes/application-pdf.ts:403:      fileName: `Application_Summary_${applicationData.business_name || 'Business'}_${new Date().toISOString().split('T')[0]}.pdf`,
server/routes/application-pdf.ts:404:      fileType: 'application/pdf',
server/routes/application-pdf.ts:405:      documentType: 'application_summary_pdf',
server/routes/application-pdf.ts:411:      storageKey: `application-summaries/${id}/summary-${Date.now()}.pdf`,
server/routes/application-pdf.ts:412:      description: 'Auto-generated application summary PDF with business details, document status, and OCR analysis'
server/routes/application-pdf.ts:415:    console.log(`‚úÖ PDF generated and stored for application ${id}`);
server/routes/application-pdf.ts:418:    res.setHeader('Content-Type', 'application/pdf');
server/routes/application-pdf.ts:419:    res.setHeader('Content-Disposition', `attachment; filename="Application_Summary_${id}.pdf"`);
server/routes/application-pdf.ts:432:// Generate PDFs for all applications (with bypass for testing)
server/routes/application-pdf.ts:433:r.post("/applications/generate-all-pdfs", async (req: any, res) => {
server/routes/application-pdf.ts:435:    console.log('üîÑ Starting bulk PDF generation for all applications...');
server/routes/application-pdf.ts:437:    // Fetch all applications using raw SQL to avoid schema conflicts
server/routes/application-pdf.ts:438:    const allApplications = await pool.query(`
server/routes/application-pdf.ts:445:      FROM applications 
server/routes/application-pdf.ts:449:    console.log(`üìä Found ${allApplications.rows.length} applications to process`);
server/routes/application-pdf.ts:452:      total: allApplications.rows.length,
server/routes/application-pdf.ts:459:    for (const app of allApplications.rows) {
server/routes/application-pdf.ts:461:        console.log(`üîÑ Processing application ${app.id}...`);
server/routes/application-pdf.ts:464:        const applicationDocuments = await pool.query(`
server/routes/application-pdf.ts:467:          WHERE application_id = $1
server/routes/application-pdf.ts:475:        const htmlContent = generateApplicationSummaryHTML(
server/routes/application-pdf.ts:477:          applicationDocuments.rows, 
server/routes/application-pdf.ts:483:        const pdfBuffer = await generatePDF(htmlContent, `application-${app.id}-summary.pdf`);
server/routes/application-pdf.ts:487:          INSERT INTO documents (application_id, file_name, file_type, document_type, file_size, uploaded_by, 
server/routes/application-pdf.ts:493:          `Application_Summary_${app.business_name || 'Business'}_${new Date().toISOString().split('T')[0]}.pdf`,
server/routes/application-pdf.ts:494:          'application/pdf',
server/routes/application-pdf.ts:495:          'application_summary_pdf',
server/routes/application-pdf.ts:501:          `application-summaries/${app.id}/summary-${Date.now()}.pdf`,
server/routes/application-pdf.ts:502:          'Auto-generated application summary PDF with business details, document status, and OCR analysis'
server/routes/application-pdf.ts:507:          application_id: app.id,
server/routes/application-pdf.ts:514:        console.log(`‚úÖ PDF generated for application ${app.id}`);
server/routes/application-pdf.ts:518:        const errorMsg = `Application ${app.id}: ${error instanceof Error ? error.message : 'Unknown error'}`;
server/routes/application-pdf.ts:520:        console.error(`‚ùå Failed to generate PDF for application ${app.id}:`, error);
server/routes/application-pdf.ts:570:    res.setHeader('Content-Type', 'application/pdf');
server/routes/_admin/push-products.mjs:38:      headers: { "Content-Type":"application/json", "X-Sync-Token": token },
server/services/ai.ts:119:function sysDocScan(applicationId: string) {
server/services/ai.ts:121:Return response as JSON only matching the supplied schema. Use only provided application data and prior docs.
server/services/ai.ts:123:ApplicationId: ${applicationId}`;
server/services/ai.ts:127:export async function aiScanDocs(input: { applicationId: string; docHash?: string }) {
server/services/ai.ts:128:  const prompt = `${sysDocScan(input.applicationId)}
server/services/ai.ts:129:Data: (The server should assemble key figures from DB + latest OCR snippets for app ${input.applicationId}.)`;
server/services/ai.ts:133:export async function aiValidate(input: { applicationId: string }) {
server/services/ai.ts:135:Use strict field names; do NOT invent values. AppId=${input.applicationId}`;
server/services/ai.ts:139:export async function aiRedFlags(input: { applicationId: string }) {
server/services/ai.ts:140:  const prompt = `List potential red flags from financials and documents for AppId=${input.applicationId}. 
server/services/ai.ts:145:export async function aiFinancialHealth(input: { applicationId: string }) {
server/services/ai.ts:146:  const prompt = `Compute a 0‚Äì100 financial health score for AppId=${input.applicationId}.
server/services/ai.ts:151:export async function aiApprovalProbability(input: { applicationId: string }) {
server/services/ai.ts:152:  const prompt = `Estimate probability of approval for AppId=${input.applicationId} based on policy-like rules.
server/services/ai.ts:157:export async function aiRouting(input: { applicationId: string }) {
server/services/ai.ts:158:  const prompt = `Recommend 1‚Äì3 lenders for AppId=${input.applicationId} based on product fit and limits.
server/services/ai.ts:163:export async function aiCreditSummary(input: { applicationId: string }) {
server/services/ai.ts:164:  const prompt = `Draft a concise credit summary for AppId=${input.applicationId}. No hallucinations. Summarize facts only.`;
server/services/ai.ts:168:export async function aiBenchmarks(input: { applicationId: string }) {
server/services/ai.ts:169:  const prompt = `Compare key metrics for AppId=${input.applicationId} vs industry median. Provide 1‚Äì3 metrics.`;
server/services/ai.ts:173:export async function aiComposeEmail(input: { applicationId: string; intent: string }) {
server/services/ai.ts:174:  const prompt = `Write a professional email for AppId=${input.applicationId}. Intent: ${input.intent}. 
server/services/ai.ts:179:export async function aiComposeSMS(input: { applicationId: string; intent: string }) {
server/services/ai.ts:180:  const prompt = `Write an SMS (<= 300 chars) for AppId=${input.applicationId}. Intent: ${input.intent}.
server/services/ai.ts:185:export async function aiRequestMissing(input: { applicationId: string }) {
server/services/ai.ts:186:  const prompt = `From what is already on file for AppId=${input.applicationId}, produce a short checklist of missing items.`;
server/services/ai.ts:190:export async function aiAML(input: { applicationId: string }) {
server/services/ai.ts:191:  const prompt = `You simulate a KYC/AML screen for AppId=${input.applicationId}. Only return "clear", "review", or "match" with any matches.`;
server/services/ai.ts:195:export async function aiLenderQA(input: { applicationId: string; question: string }) {
server/services/ai.ts:196:  const prompt = `Answer lender policy question for AppId=${input.applicationId} using known product schema only: ${input.question}.
server/services/ai.ts:210:    headers: { "Authorization": `Bearer ${KEY}`, "Content-Type": "application/json" },
server/services/ai.ts:227:    headers: { "Authorization": `Bearer ${KEY}`, "Content-Type": "application/json" },
server/routes/push-products.mjs:26:      headers: { "Content-Type":"application/json", "X-Sync-Token": SYNC_TOKEN },
server/routes/push-products.mjs:30:    res.status(push.status).type("application/json").send(body);
server/middleware/auth.ts:11:  "/api/pipeline/cards",
server/middleware/auth.ts:12:  "/api/pipeline/board",
server/routes/tasks-api.ts:31:      description: 'Call Leo Martinez to discuss next steps in application process',
server/routes/tasks-api.ts:38:        type: 'application',
server/routes/tasks-api.ts:40:        name: 'Quick Mart LLC Application'
server/routes/tasks-api.ts:55:        type: 'application',
server/routes/tasks-api.ts:57:        name: 'Denver Construction Application'
server/routes/tasks-api.ts:132:    description: 'Email bank statements to Maya at Acme Manufacturing for equipment financing application',
server/services/generateSignedApplicationPdf.ts:6:export async function generateSignedApplicationPdf(applicationId: string) {
server/services/generateSignedApplicationPdf.ts:8:    console.log(`üìÑ [PDF] Generating signed application PDF for: ${applicationId}`);
server/services/generateSignedApplicationPdf.ts:10:    // 1. Fetch application data using raw SQL (avoiding schema issues)
server/services/generateSignedApplicationPdf.ts:11:    const applicationQuery = await db.execute(
server/services/generateSignedApplicationPdf.ts:14:       FROM applications a
server/services/generateSignedApplicationPdf.ts:18:      [applicationId]
server/services/generateSignedApplicationPdf.ts:21:    if (!applicationQuery || applicationQuery.length === 0) {
server/services/generateSignedApplicationPdf.ts:22:      throw new Error("Application not found");
server/services/generateSignedApplicationPdf.ts:25:    const application = applicationQuery[0] as any;
server/services/generateSignedApplicationPdf.ts:26:    const formData = application.form_data ? JSON.parse(application.form_data) : {};
server/services/generateSignedApplicationPdf.ts:28:    console.log(`‚úÖ [PDF] Application data retrieved for: ${application.business_name || 'Unknown Business'}`);
server/services/generateSignedApplicationPdf.ts:41:    page.drawText('LOAN APPLICATION - SIGNED COPY', {
server/services/generateSignedApplicationPdf.ts:56:    const businessName = application.business_name || formData.step3?.businessName || 'Not provided';
server/services/generateSignedApplicationPdf.ts:57:    const businessType = application.business_type || formData.step3?.businessType || 'Not provided';
server/services/generateSignedApplicationPdf.ts:58:    const requestedAmount = application.requested_amount || formData.step1?.requestedAmount || 'Not provided';
server/services/generateSignedApplicationPdf.ts:59:    const useOfFunds = application.use_of_funds || formData.step1?.useOfFunds || 'Not provided';
server/services/generateSignedApplicationPdf.ts:97:    const contactName = `${application.first_name || formData.step4?.firstName || ''} ${application.last_name || formData.step4?.lastName || ''}`.trim() || 'Not provided';
server/services/generateSignedApplicationPdf.ts:98:    const contactEmail = application.email || formData.step4?.email || 'Not provided';
server/services/generateSignedApplicationPdf.ts:99:    const contactPhone = application.phone || formData.step4?.phone || 'Not provided';
server/services/generateSignedApplicationPdf.ts:122:    // Application Details
server/services/generateSignedApplicationPdf.ts:123:    page.drawText('APPLICATION DETAILS', {
server/services/generateSignedApplicationPdf.ts:130:    page.drawText(`Application ID: ${applicationId}`, {
server/services/generateSignedApplicationPdf.ts:137:    page.drawText(`Status: ${application.status || 'Submitted'}`, {
server/services/generateSignedApplicationPdf.ts:144:    page.drawText(`Submission Date: ${new Date(application.created_at).toLocaleDateString()}`, {
server/services/generateSignedApplicationPdf.ts:159:    page.drawText('By submitting this application electronically, I certify that all information', {
server/services/generateSignedApplicationPdf.ts:193:    const storageKey = await uploadDocumentToS3(applicationId, buffer, {
server/services/generateSignedApplicationPdf.ts:194:      documentType: "signed_application",
server/services/generateSignedApplicationPdf.ts:195:      fileName: "Signed_Application.pdf",
server/services/generateSignedApplicationPdf.ts:198:    console.log(`‚úÖ [MONITOR] Final PDF uploaded - signed_application`);
server/services/generateSignedApplicationPdf.ts:205:        id, application_id, file_name, document_type, status, 
server/services/generateSignedApplicationPdf.ts:210:        applicationId,
server/services/generateSignedApplicationPdf.ts:211:        "Signed_Application.pdf",
server/services/generateSignedApplicationPdf.ts:212:        "signed_application",
server/services/generateSignedApplicationPdf.ts:229:      fileName: "Signed_Application.pdf"
server/services/bigQueryClient.ts:18:      AND event_name IN ('form_started', 'step_completed', 'application_submitted', 'document_uploaded', 'application_approved')
server/services/bigQueryClient.ts:32:      { event_name: 'application_submitted', count: 320 },
server/services/bigQueryClient.ts:33:      { event_name: 'application_approved', count: 125 }
server/services/bigQueryClient.ts:49:        AND event_name IN ('page_view', 'application_start', 'form_submit', 'application_complete')
server/services/bigQueryClient.ts:67:      { event_name: 'application_start', unique_users: 456, total_events: 892 },
server/services/bigQueryClient.ts:69:      { event_name: 'application_complete', unique_users: 89, total_events: 125 }
server/routes/bulletproofHealthV2.ts:18:        application_id, document_type, created_at, updated_at
server/routes/bulletproofHealthV2.ts:45:          application_id: doc.application_id
server/routes/bulletproofHealthV2.ts:96:          application_id: doc.application_id,
server/routes/bulletproofHealthV2.ts:203:        d.application_id,
server/routes/contacts-seed.ts:108:// Contact details for HubSpot-style card
server/routes/contacts-seed.ts:140:          description: 'Sent rate sheet and application form',
server/services/analyticsClient.ts:33:        { dimensionValues: [{ value: 'application_start' }], metricValues: [{ value: '320' }] },
server/services/analyticsClient.ts:36:        { dimensionValues: [{ value: 'application_complete' }], metricValues: [{ value: '62' }] }
server/services/analyticsClient.ts:62:        { dimensionValues: [{ value: '/staff/applications' }], metricValues: [{ value: '567' }] },
server/middleware/hybridAuth.ts:13:  { method: 'POST', path: /^\/api\/public\/applications$/ },
server/middleware/hybridAuth.ts:14:  { method: 'GET', path: /^\/api\/public\/applications\/[a-f0-9\-]{36}\/signing-status$/ },
server/middleware/hybridAuth.ts:15:  { method: 'GET', path: /^\/api\/public\/applications\/[a-f0-9\-]{36}\/required-docs$/ },
server/middleware/hybridAuth.ts:16:  { method: 'POST', path: /^\/api\/public\/applications\/[a-f0-9\-]{36}\/selected-category$/ },
server/middleware/hybridAuth.ts:28:    { method: 'GET', path: /^\/api\/public\/applications\/debug\/applications\/[a-f0-9\-]{36}$/ }
server/services/aiApplicationService.ts:2: * AI Application Service
server/services/aiApplicationService.ts:3: * Comprehensive AI features for application processing
server/services/aiApplicationService.ts:7:import { applications, documents, contacts } from '../../shared/schema';
server/services/aiApplicationService.ts:20:export interface AIApplicationData {
server/services/aiApplicationService.ts:21:  applicationId: string;
server/services/aiApplicationService.ts:41: * Generate AI credit summary for application
server/services/aiApplicationService.ts:43:export async function generateAICreditSummary(applicationId: string): Promise<{
server/services/aiApplicationService.ts:49:    console.log(`üß† [AI-SUMMARY] Generating credit summary for: ${applicationId}`);
server/services/aiApplicationService.ts:51:    const appData = await getApplicationData(applicationId);
server/services/aiApplicationService.ts:54:      throw new Error('Application not found');
server/services/aiApplicationService.ts:61:    await saveCreditSummary(applicationId, summary);
server/services/aiApplicationService.ts:63:    console.log(`‚úÖ [AI-SUMMARY] Generated summary for: ${applicationId}`);
server/services/aiApplicationService.ts:67:    console.error(`‚ùå [AI-SUMMARY] Failed for ${applicationId}:`, error);
server/services/aiApplicationService.ts:76: * Generate AI risk score for application
server/services/aiApplicationService.ts:78:export async function generateRiskScore(applicationId: string): Promise<{
server/services/aiApplicationService.ts:85:    console.log(`üéØ [AI-RISK] Generating risk score for: ${applicationId}`);
server/services/aiApplicationService.ts:87:    const appData = await getApplicationData(applicationId);
server/services/aiApplicationService.ts:90:      throw new Error('Application not found');
server/services/aiApplicationService.ts:101:    await saveRiskAssessment(applicationId, riskLevel, explanation);
server/services/aiApplicationService.ts:103:    console.log(`‚úÖ [AI-RISK] Generated risk ${riskLevel} for: ${applicationId}`);
server/services/aiApplicationService.ts:107:    console.error(`‚ùå [AI-RISK] Failed for ${applicationId}:`, error);
server/services/aiApplicationService.ts:118:export async function generateNextStepSuggestion(applicationId: string): Promise<{
server/services/aiApplicationService.ts:125:    console.log(`üöÄ [AI-NEXTSTEP] Generating suggestion for: ${applicationId}`);
server/services/aiApplicationService.ts:127:    const appData = await getApplicationData(applicationId);
server/services/aiApplicationService.ts:130:      throw new Error('Application not found');
server/services/aiApplicationService.ts:139:    console.log(`‚úÖ [AI-NEXTSTEP] Generated suggestion for: ${applicationId}`);
server/services/aiApplicationService.ts:143:    console.error(`‚ùå [AI-NEXTSTEP] Failed for ${applicationId}:`, error);
server/services/aiApplicationService.ts:154:export async function analyzeDocumentMatching(applicationId: string): Promise<{
server/services/aiApplicationService.ts:160:    console.log(`üìÑ [AI-DOCMATCH] Analyzing documents for: ${applicationId}`);
server/services/aiApplicationService.ts:162:    const docs = await getApplicationDocuments(applicationId);
server/services/aiApplicationService.ts:177:    console.log(`‚úÖ [AI-DOCMATCH] Analyzed ${docs.length} documents for: ${applicationId}`);
server/services/aiApplicationService.ts:181:    console.error(`‚ùå [AI-DOCMATCH] Failed for ${applicationId}:`, error);
server/services/aiApplicationService.ts:192:export async function generateDocumentSummary(applicationId: string): Promise<{
server/services/aiApplicationService.ts:198:    console.log(`üìã [AI-DOCSUMMARY] Summarizing documents for: ${applicationId}`);
server/services/aiApplicationService.ts:200:    const docs = await getApplicationDocuments(applicationId);
server/services/aiApplicationService.ts:209:    console.log(`‚úÖ [AI-DOCSUMMARY] Summarized ${docs.length} documents for: ${applicationId}`);
server/services/aiApplicationService.ts:213:    console.error(`‚ùå [AI-DOCSUMMARY] Failed for ${applicationId}:`, error);
server/services/aiApplicationService.ts:225:  applicationId: string, 
server/services/aiApplicationService.ts:235:    console.log(`üìÑ [AI-SUBMIT] Submitting summary for: ${applicationId}`);
server/services/aiApplicationService.ts:244:    const pdfBuffer = await generateSummaryPDF(applicationId, customizedSummary);
server/services/aiApplicationService.ts:247:    const appData = await getApplicationData(applicationId);
server/services/aiApplicationService.ts:248:    const filename = `${appData?.businessName || 'Application'} - Credit Summary.pdf`;
server/services/aiApplicationService.ts:253:      mimeType: 'application/pdf'
server/services/aiApplicationService.ts:258:      applicationId,
server/services/aiApplicationService.ts:265:      mimeType: 'application/pdf',
server/services/aiApplicationService.ts:284:    console.error(`‚ùå [AI-SUBMIT] Failed for ${applicationId}:`, error);
server/services/aiApplicationService.ts:294:async function getApplicationData(applicationId: string): Promise<AIApplicationData | null> {
server/services/aiApplicationService.ts:298:        id: applications.id,
server/services/aiApplicationService.ts:299:        businessName: applications.businessName,
server/services/aiApplicationService.ts:300:        industry: applications.industry,
server/services/aiApplicationService.ts:301:        yearsInBusiness: applications.yearsInBusiness,
server/services/aiApplicationService.ts:302:        requestedAmount: applications.requestedAmount,
server/services/aiApplicationService.ts:303:        useOfFunds: applications.useOfFunds,
server/services/aiApplicationService.ts:304:        status: applications.status,
server/services/aiApplicationService.ts:310:      .from(applications)
server/services/aiApplicationService.ts:311:      .leftJoin(contacts, eq(applications.contactId, contacts.id))
server/services/aiApplicationService.ts:312:      .where(eq(applications.id, applicationId));
server/services/aiApplicationService.ts:320:      .where(eq(documents.applicationId, applicationId));
server/services/aiApplicationService.ts:323:      applicationId,
server/services/aiApplicationService.ts:337:    console.error('Failed to fetch application data:', error);
server/services/aiApplicationService.ts:342:async function getApplicationDocuments(applicationId: string): Promise<any[]> {
server/services/aiApplicationService.ts:347:      .where(eq(documents.applicationId, applicationId));
server/services/aiApplicationService.ts:398:async function saveCreditSummary(applicationId: string, summary: string): Promise<void> {
server/services/aiApplicationService.ts:401:  console.log(`üíæ Saving credit summary for ${applicationId}`);
server/services/aiApplicationService.ts:404:async function saveRiskAssessment(applicationId: string, riskLevel: string, explanation: string): Promise<void> {
server/services/aiApplicationService.ts:405:  // Save to risk assessments table or application metadata
server/services/aiApplicationService.ts:406:  console.log(`üíæ Saving risk assessment ${riskLevel} for ${applicationId}`);
server/services/aiApplicationService.ts:415:async function generateSummaryPDF(applicationId: string, summary: string): Promise<Buffer> {
server/services/aiApplicationService.ts:428:  page.drawText(`Application ID: ${applicationId}`, {
server/routes/base64Upload.ts:14:    const { applicationId, fileName, documentType, base64Data } = req.body;
server/routes/base64Upload.ts:16:    if (!applicationId || !fileName || !documentType || !base64Data) {
server/routes/base64Upload.ts:18:        error: "Missing required fields: applicationId, fileName, documentType, base64Data" 
server/routes/base64Upload.ts:59:      applicationId,
server/routes/base64Upload.ts:79:          headers: { 'Content-Type': 'application/json' },
server/routes/base64Upload.ts:81:            applicationId,
server/routes/base64Upload.ts:118:    'application/pdf': '.pdf',
server/routes/base64Upload.ts:122:    'application/msword': '.doc',
server/routes/base64Upload.ts:123:    'application/vnd.openxmlformats-officedocument.wordprocessingml.document': '.docx',
server/routes/base64Upload.ts:124:    'application/vnd.ms-excel': '.xls',
server/routes/base64Upload.ts:125:    'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet': '.xlsx',
server/routes/ocr-conflicts.ts:7:// Get OCR data with conflict detection for application
server/routes/ocr-conflicts.ts:8:router.get("/api/pipeline/cards/:id/ocr-conflicts", async (req, res) => {
server/routes/ocr-conflicts.ts:10:    const { id: applicationId } = req.params;
server/routes/ocr-conflicts.ts:12:    console.log(`üîç Analyzing OCR conflicts for application: ${applicationId}`);
server/routes/ocr-conflicts.ts:14:    // Get all OCR results for this application
server/routes/ocr-conflicts.ts:27:      WHERE d.application_id = ${applicationId}
server/routes/ocr-conflicts.ts:34:    // Get application data for comparison
server/routes/ocr-conflicts.ts:35:    const applicationResult = await db.execute(sql`
server/routes/ocr-conflicts.ts:37:      FROM applications a
server/routes/ocr-conflicts.ts:38:      WHERE a.id = ${applicationId}
server/routes/ocr-conflicts.ts:41:    const application = applicationResult[0];
server/routes/ocr-conflicts.ts:44:    const processedData = processOCRConflicts(ocrResults, application);
server/routes/ocr-conflicts.ts:47:      applicationId,
server/routes/ocr-conflicts.ts:51:      applicationComparison: processedData.applicationComparison,
server/routes/ocr-conflicts.ts:62:      applicationId,
server/routes/ocr-conflicts.ts:122:      applicationComparison: {
server/routes/ocr-conflicts.ts:123:        businessName: { application: 'Acme Manufacturing', ocr: 'Acme Manufacturing LLC', match: true },
server/routes/ocr-conflicts.ts:124:        revenue: { application: 4200000, ocr: 4250000, match: false, variance: 50000 }
server/routes/ocr-conflicts.ts:136:function processOCRConflicts(ocrResults: any[], application: any) {
server/routes/ocr-conflicts.ts:140:  const applicationComparison = {};
server/routes/ocr-conflicts.ts:213:    applicationComparison,
server/services/pdfGeneratorService.ts:3: * Handles application PDF generation and batch processing
server/services/pdfGeneratorService.ts:8:import { applications, documents, contacts } from '../../shared/schema';
server/services/pdfGeneratorService.ts:14:export interface ApplicationPDFData {
server/services/pdfGeneratorService.ts:15:  applicationId: string;
server/services/pdfGeneratorService.ts:31: * Generate comprehensive PDF for a single application
server/services/pdfGeneratorService.ts:33:export async function generateApplicationPDF(applicationId: string): Promise<Buffer> {
server/services/pdfGeneratorService.ts:34:  console.log(`üìù [PDF-GEN] Starting PDF generation for application: ${applicationId}`);
server/services/pdfGeneratorService.ts:37:    // Fetch application data with contact info
server/services/pdfGeneratorService.ts:40:        id: applications.id,
server/services/pdfGeneratorService.ts:41:        businessName: applications.businessName,
server/services/pdfGeneratorService.ts:42:        requestedAmount: applications.requestedAmount,
server/services/pdfGeneratorService.ts:43:        useOfFunds: applications.useOfFunds,
server/services/pdfGeneratorService.ts:44:        businessEmail: applications.businessEmail,
server/services/pdfGeneratorService.ts:45:        businessPhone: applications.businessPhone,
server/services/pdfGeneratorService.ts:46:        submittedAt: applications.submittedAt,
server/services/pdfGeneratorService.ts:47:        industry: applications.industry,
server/services/pdfGeneratorService.ts:48:        revenueRange: applications.revenueRange,
server/services/pdfGeneratorService.ts:49:        yearsInBusiness: applications.yearsInBusiness,
server/services/pdfGeneratorService.ts:55:      .from(applications)
server/services/pdfGeneratorService.ts:56:      .leftJoin(contacts, eq(applications.contactId, contacts.id))
server/services/pdfGeneratorService.ts:57:      .where(eq(applications.id, applicationId));
server/services/pdfGeneratorService.ts:60:      throw new Error(`Application not found: ${applicationId}`);
server/services/pdfGeneratorService.ts:75:    page.drawText('APPLICATION SUMMARY', {
server/services/pdfGeneratorService.ts:91:    // Application Information
server/services/pdfGeneratorService.ts:92:    page.drawText('APPLICATION DETAILS', {
server/services/pdfGeneratorService.ts:102:      { label: 'Application ID:', value: appResult.id },
server/services/pdfGeneratorService.ts:179:    console.log(`‚úÖ [PDF-GEN] PDF generated successfully for application: ${applicationId}`);
server/services/pdfGeneratorService.ts:183:    console.error(`‚ùå [PDF-GEN] Failed to generate PDF for application ${applicationId}:`, error);
server/services/pdfGeneratorService.ts:192:  applicationId: string,
server/services/pdfGeneratorService.ts:195:  category: string = 'generated_application_summary',
server/services/pdfGeneratorService.ts:205:      mimeType: 'application/pdf'
server/services/pdfGeneratorService.ts:210:      applicationId,
server/services/pdfGeneratorService.ts:217:      mimeType: 'application/pdf',
server/services/pdfGeneratorService.ts:222:        category: 'Application Summary'
server/services/pdfGeneratorService.ts:236: * Generate PDFs for all applications in bulk
server/services/pdfGeneratorService.ts:238:export async function generateAllApplicationPDFs(): Promise<{
server/services/pdfGeneratorService.ts:242:  errors: { applicationId: string; error: string }[];
server/services/pdfGeneratorService.ts:244:  console.log(`üîÑ [PDF-GEN] Starting bulk PDF generation for all applications`);
server/services/pdfGeneratorService.ts:247:    // Get all applications
server/services/pdfGeneratorService.ts:249:      .from(applications);
server/services/pdfGeneratorService.ts:251:    console.log(`üìä [PDF-GEN] Found ${apps.length} applications to process`);
server/services/pdfGeneratorService.ts:257:      errors: [] as { applicationId: string; error: string }[]
server/services/pdfGeneratorService.ts:260:    // Process each application
server/services/pdfGeneratorService.ts:263:        console.log(`üîÑ [PDF-GEN] Processing application: ${app.id} (${app.businessName || 'No business name'})`);
server/services/pdfGeneratorService.ts:266:        const pdfBuffer = await generateApplicationPDF(app.id);
server/services/pdfGeneratorService.ts:269:        const filename = `ApplicationSummary-${app.id}.pdf`;
server/services/pdfGeneratorService.ts:274:          'generated_application_summary',
server/services/pdfGeneratorService.ts:279:        console.log(`‚úÖ [PDF-GEN] Successfully processed application: ${app.id}`);
server/services/pdfGeneratorService.ts:282:        console.error(`‚ùå [PDF-GEN] Failed to process application ${app.id}:`, error);
server/services/pdfGeneratorService.ts:285:          applicationId: app.id,
server/services/pdfGeneratorService.ts:301: * Test PDF generation for a single application
server/services/pdfGeneratorService.ts:303:export async function testPDFGeneration(applicationId?: string): Promise<{
server/services/pdfGeneratorService.ts:305:  applicationId?: string;
server/services/pdfGeneratorService.ts:314:    // If no application ID provided, get the first one
server/services/pdfGeneratorService.ts:315:    if (!applicationId) {
server/services/pdfGeneratorService.ts:316:      const [app] = await db.select({ id: applications.id })
server/services/pdfGeneratorService.ts:317:        .from(applications)
server/services/pdfGeneratorService.ts:321:        throw new Error('No applications found in database');
server/services/pdfGeneratorService.ts:324:      applicationId = app.id;
server/services/pdfGeneratorService.ts:327:    console.log(`üß™ [PDF-GEN] Testing with application: ${applicationId}`);
server/services/pdfGeneratorService.ts:330:    const pdfBuffer = await generateApplicationPDF(applicationId);
server/services/pdfGeneratorService.ts:333:    const filename = `Test-ApplicationSummary-${applicationId}.pdf`;
server/services/pdfGeneratorService.ts:335:      applicationId,
server/services/pdfGeneratorService.ts:344:      applicationId,
server/middleware/diagProvenance.ts:77:        // Helper: tag APPLICATION (validate-intake echo or created row)
server/middleware/diagProvenance.ts:78:        const tagApplication = (a: any) => prov.attach(a, {
server/middleware/diagProvenance.ts:110:        else if (body && (path.includes('/applications/validate-intake') || path.endsWith('/applications'))) {
server/middleware/diagProvenance.ts:112:          if (body.intake) body.intake = tagApplication(body.intake);
server/middleware/diagProvenance.ts:113:          if (body.application) body.application = tagApplication(body.application);
server/middleware/diagProvenance.ts:114:          (body as any)._diag = { counts: prov.summarize([body.product, body.intake, body.application].filter(Boolean) as any) };
server/routes/financials.ts:8:router.get("/api/pipeline/cards/:id/financials", async (req, res) => {
server/routes/financials.ts:10:    const { id: applicationId } = req.params;
server/routes/financials.ts:12:    console.log(`üìä Fetching financial data for application: ${applicationId}`);
server/routes/financials.ts:14:    // Get all OCR results for this application - financial documents only
server/routes/financials.ts:26:      WHERE d.application_id = ${applicationId}
server/routes/bankingAnalysis.ts:7: * GET /api/banking/analysis/:applicationId?start=YYYY-MM-DD&end=YYYY-MM-DD
server/routes/bankingAnalysis.ts:9:router.get('/analysis/:applicationId', async (req, res, next) => {
server/routes/bankingAnalysis.ts:11:    const applicationId = req.params.applicationId;
server/routes/bankingAnalysis.ts:14:    const data = await buildBankingAnalysis(applicationId, start, end);
server/services/o365Service.ts:7:import { AuthenticationResult, ConfidentialClientApplication } from '@azure/msal-node';
server/services/o365Service.ts:20:let cca: ConfidentialClientApplication | null = null;
server/services/o365Service.ts:24:    cca = new ConfidentialClientApplication(msalConfig);
server/routes/financials-demo.ts:6:router.get("/api/pipeline/cards/:id/financials-demo", async (req, res) => {
server/routes/financials-demo.ts:8:    console.log(`üìä Serving demo financial data for application: ${req.params.id}`);
server/services/attributionService.ts:14:    applicationId?: string;
server/services/attributionService.ts:39:        applicationId: eventData.applicationId,
server/routes/autoGeneratePDF.ts:2: * Auto-trigger PDF generation when applications are submitted
server/routes/autoGeneratePDF.ts:5:import { generateSignedApplicationPDF } from "../utils/pdfGenerator";
server/routes/autoGeneratePDF.ts:8: * Auto-generate PDF for newly submitted applications
server/routes/autoGeneratePDF.ts:10:export async function autoGeneratePDF(applicationId: string, application: any): Promise<string | null> {
server/routes/autoGeneratePDF.ts:12:    console.log(`üîÑ [AUTO-PDF] Auto-generating PDF for application ${applicationId}`);
server/routes/autoGeneratePDF.ts:14:    // Check if application has form_data
server/routes/autoGeneratePDF.ts:15:    if (!application.form_data && !application.formData) {
server/routes/autoGeneratePDF.ts:21:    const storageKey = await generateSignedApplicationPDF(application);
server/routes/autoGeneratePDF.ts:27:    console.error(`‚ùå [AUTO-PDF] Auto-generation failed for ${applicationId}:`, error);
server/routes/autoGeneratePDF.ts:34: * Integration hook for application submission endpoint
server/routes/autoGeneratePDF.ts:39:    description: "Automatically generates signed application PDFs",
server/services/pipeline.ts:1:export type PipelineStage = "new" | "requires_docs" | "in_review" | "sent_to_lender" | "closed";
server/services/pipeline.ts:3:export const PIPELINE_STAGES: { id: PipelineStage; label: string }[] = [
server/services/pipeline.ts:11:export function normalizeStage(s: unknown): PipelineStage {
server/services/pipeline.ts:12:  const v = String(s || "").toLowerCase().trim() as PipelineStage;
server/services/pipeline.ts:13:  const allowed = new Set(PIPELINE_STAGES.map(x => x.id));
server/routes/lender.portal.ts:5:import { lenders, lenderProducts, applications, users } from "../../shared/schema";
server/routes/lender.portal.ts:219:    // Get real application data if available
server/routes/lender.portal.ts:220:    const applicationStats = await db.execute(sql`
server/routes/lender.portal.ts:222:        COUNT(*)::int as total_applications,
server/routes/lender.portal.ts:225:      FROM applications a
server/routes/lender.portal.ts:231:    const appStats = applicationStats[0] || { total_applications: 0, total_approvals: 0, avg_amount: 0 };
server/routes/lender.portal.ts:236:      totalViews: appStats.total_applications * 3 + 50, // Estimate views
server/routes/lender.portal.ts:237:      totalApplications: appStats.total_applications,
server/routes/lender.portal.ts:238:      approvalRate: appStats.total_applications > 0 ? appStats.total_approvals / appStats.total_applications : 0,
server/routes/lender.portal.ts:241:        { month: 'Jan 2025', applications: Math.floor(appStats.total_applications * 0.3), approvals: Math.floor(appStats.total_approvals * 0.3), volume: Math.floor(appStats.avg_amount * 0.3) },
server/routes/lender.portal.ts:242:        { month: 'Feb 2025', applications: Math.floor(appStats.total_applications * 0.5), approvals: Math.floor(appStats.total_approvals * 0.5), volume: Math.floor(appStats.avg_amount * 0.5) },
server/routes/lender.portal.ts:243:        { month: 'Mar 2025', applications: Math.floor(appStats.total_applications * 0.2), approvals: Math.floor(appStats.total_approvals * 0.2), volume: Math.floor(appStats.avg_amount * 0.2) }
server/routes/lender.portal.ts:280:  // Get matched applications for this lender (last 30 days)
server/routes/lender.portal.ts:281:  const { rows: applications } = await db.execute(sql`
server/routes/lender.portal.ts:283:    FROM applications 
server/routes/lender.portal.ts:295:    FROM applications 
server/routes/lender.portal.ts:308:    applications
server/routes/lenders-match.ts:8: * GET /api/lenders/match?applicationId=xyz
server/routes/lenders-match.ts:9: * Get matched lenders for an application
server/routes/lenders-match.ts:13:    const { applicationId } = req.query;
server/routes/lenders-match.ts:15:    if (!applicationId) {
server/routes/lenders-match.ts:16:      return res.status(400).json({ error: 'Application ID is required' });
server/routes/lenders-match.ts:19:    console.log(`üéØ [LENDERS] Finding matches for application ${applicationId}`);
server/routes/lenders-match.ts:61: * Send application to selected lender
server/routes/lenders-match.ts:65:    const { applicationId, lenderProductId } = req.body;
server/routes/lenders-match.ts:67:    if (!applicationId || !lenderProductId) {
server/routes/lenders-match.ts:68:      return res.status(400).json({ error: 'Application ID and Lender Product ID are required' });
server/routes/lenders-match.ts:71:    console.log(`üì§ [LENDERS] Sending application ${applicationId} to lender ${lenderProductId}`);
server/routes/lenders-match.ts:73:    // Update application status to "Sent to Lender"
server/routes/lenders-match.ts:77:        UPDATE applications SET stage = 'sent_to_lender', updated_at = NOW() WHERE id = $1
server/routes/lenders-match.ts:78:      `, [applicationId]);
server/routes/lenders-match.ts:82:        INSERT INTO pipeline_activity (application_id, from_stage, to_stage, actor, note)
server/routes/lenders-match.ts:84:      `, [applicationId, `Sent to lender ${lenderProductId}`]);
server/routes/lenders-match.ts:86:      console.warn("Failed to update application status:", dbErr);
server/routes/lenders-match.ts:93:      message: 'Application sent to lender successfully',
server/routes/lenders-match.ts:98:    res.status(500).json({ error: 'Failed to send application to lender' });
server/routes/autoDocumentRoutes.ts:7:import { processDocument, processApplicationDocuments } from '../middleware/autoDocumentProcessor';
server/routes/autoDocumentRoutes.ts:25:      SELECT id, file_name, document_type, application_id
server/routes/autoDocumentRoutes.ts:43:      document.application_id,
server/routes/autoDocumentRoutes.ts:64: * POST /api/auto-documents/process-application/:applicationId
server/routes/autoDocumentRoutes.ts:65: * Process all documents for an application
server/routes/autoDocumentRoutes.ts:67:router.post('/process-application/:applicationId', async (req, res) => {
server/routes/autoDocumentRoutes.ts:69:    const { applicationId } = req.params;
server/routes/autoDocumentRoutes.ts:71:    console.log(`üîÑ [AUTO-DOCS] Processing all documents for application: ${applicationId}`);
server/routes/autoDocumentRoutes.ts:73:    const results = await processApplicationDocuments(applicationId);
server/routes/autoDocumentRoutes.ts:80:      message: 'Application document processing completed',
server/routes/autoDocumentRoutes.ts:81:      applicationId,
server/routes/autoDocumentRoutes.ts:89:    console.error('‚ùå [AUTO-DOCS] Application processing error:', error);
server/routes/autoDocumentRoutes.ts:98: * GET /api/auto-documents/status/:applicationId
server/routes/autoDocumentRoutes.ts:99: * Get processing status for an application
server/routes/autoDocumentRoutes.ts:101:router.get('/status/:applicationId', async (req, res) => {
server/routes/autoDocumentRoutes.ts:103:    const { applicationId } = req.params;
server/routes/autoDocumentRoutes.ts:110:      WHERE application_id = ${applicationId}
server/routes/autoDocumentRoutes.ts:117:      WHERE application_id = ${applicationId}
server/routes/autoDocumentRoutes.ts:124:      WHERE application_id = ${applicationId}
server/routes/autoDocumentRoutes.ts:129:      applicationId,
server/routes/autoDocumentRoutes.ts:161:    // Get applications with processing status
server/routes/autoDocumentRoutes.ts:162:    const applicationsResult = await db.execute(sql`
server/routes/autoDocumentRoutes.ts:168:      FROM applications a
server/routes/autoDocumentRoutes.ts:169:      LEFT JOIN documents d ON a.id = d.application_id
server/routes/autoDocumentRoutes.ts:170:      LEFT JOIN ocr_results ocr ON a.id = ocr.application_id
server/routes/autoDocumentRoutes.ts:171:      LEFT JOIN banking_analysis ba ON a.id = ba.application_id
server/routes/autoDocumentRoutes.ts:179:      applications: applicationsResult.rows.map((row: any) => ({
server/routes/autoDocumentRoutes.ts:180:        applicationId: row.id,
server/middleware/authBypass.ts:5:  /^\/api\/pipeline\/board$/,
server/middleware/authBypass.ts:6:  /^\/api\/pipeline\/cards\/[^/]+\/application$/,
server/middleware/authBypass.ts:7:  /^\/api\/pipeline\/cards\/[^/]+\/documents$/,
server/services/applications.adapter.ts:33:  const id = r.id || r.appId || r.application_id || String(r.uuid || r._id);
server/services/applications.adapter.ts:39:  const status = r.status || r.stage || r.pipeline_status || 'new';
server/middleware/mountSpa.ts:41:          res.setHeader('Content-Type', 'application/javascript');
server/routes/sms-notifications.ts:7:// Send SMS notification when application stage changes
server/routes/sms-notifications.ts:10:    const { applicationId, stage } = req.body;
server/routes/sms-notifications.ts:12:    if (!applicationId || !stage) {
server/routes/sms-notifications.ts:13:      return res.status(400).json({ error: "Missing applicationId or stage" });
server/routes/sms-notifications.ts:16:    // Get application and user details
server/routes/sms-notifications.ts:19:      FROM applications a
server/routes/sms-notifications.ts:22:    `, [applicationId]);
server/routes/sms-notifications.ts:25:      return res.status(404).json({ error: "Application not found" });
server/routes/sms-notifications.ts:42:        message = `Hi ${clientName}! Great news - your ${businessName} application is now being reviewed by our underwriting team. We'll contact you soon with updates. - Boreal Financial`;
server/routes/sms-notifications.ts:45:        message = `${clientName}, your ${businessName} application has been sent to our lending partners! You may receive calls from potential lenders. We're here to help throughout the process. - Boreal Financial`;
server/routes/sms-notifications.ts:57:        INSERT INTO sms_logs (application_id, phone, message, stage, status, sent_at)
server/routes/sms-notifications.ts:59:      `, [applicationId, phone, message, stage]);
server/services/contacts.ts:27:export function mergeContactsFromApplications(apps: App[]) {
server/services/contacts.ts:57:      applications: arr.map(a => a.id),
server/services/contacts.ts:58:      applicationsCount: arr.length,
server/services/embed.ts:7:      headers: { "Content-Type":"application/json", "Authorization":`Bearer ${key}` },
server/routes/issues.ts:45:        title: 'Application form not submitting',
server/routes/issues.ts:46:        description: 'User unable to submit loan application form - button appears inactive.',
server/routes/applications-board.ts:5:// Mock data for BF pipeline board (until database is properly connected)
server/routes/applications-board.ts:6:const mockBfApplications = [
server/routes/applications-board.ts:55: * GET /api/applications/board
server/routes/applications-board.ts:56: * Get applications formatted for pipeline board view (BF silo)
server/routes/applications-board.ts:60:    console.log('üìã [BF-BOARD] Fetching BF applications for pipeline board...');
server/routes/applications-board.ts:63:    const boardData = mockBfApplications.map(app => ({
server/routes/applications-board.ts:72:    console.log(`üìã [BF-BOARD] Returning ${boardData.length} BF applications`);
server/routes/applications-board.ts:79:      error: 'Failed to load pipeline board'
server/services/mergeFieldsV2.ts:18:      ApplicationId: "",
server/services/mergeFieldsV2.ts:19:      ApplicationStage: "",
server/services/mergeFieldsV2.ts:29:  // Pull missing/rejected documents for the most recent application by this contact
server/services/mergeFieldsV2.ts:30:  const [application] = await q<any>(`
server/services/mergeFieldsV2.ts:32:    FROM applications a
server/services/mergeFieldsV2.ts:40:  if (application) {
server/services/mergeFieldsV2.ts:44:      WHERE application_id=$1
server/services/mergeFieldsV2.ts:45:    `, [application.id]);
server/services/mergeFieldsV2.ts:58:    ApplicationId: application?.id || "",
server/services/mergeFieldsV2.ts:59:    ApplicationStage: application?.stage || "",
server/middleware/apiAllowlist.ts:4:  /^\/api\/pipeline/,
server/middleware/apiAllowlist.ts:11:  /^\/api\/applications/,
server/middleware/apiAllowlist.ts:21:  /^\/api\/public\/applications$/,
server/middleware/apiAllowlist.ts:25:  /^\/api\/client-compat\/public\/applications$/,
server/routes/health.ts:50:    const appCount = await db.execute(sql`SELECT COUNT(*) as count FROM applications`);
server/routes/health.ts:63:          applications: appCount.rows[0]?.count || 0, 
server/routes/health.ts:130:  const appsWithLenders = await db.execute(sql`SELECT COUNT(*) as count FROM applications WHERE lender_id IS NOT NULL`);
server/routes/health.ts:133:    applications_with_lenders: appsWithLenders.rows[0]?.count || 0
server/services/reminders.ts:22:    SELECT c.id as contact_id, a.id as application_id
server/services/reminders.ts:23:    FROM applications a
server/services/reminders.ts:26:      SELECT 1 FROM documents d WHERE d.application_id=a.id AND d.status IN ('pending','rejected')
server/services/reminders.ts:47:      JOIN applications a ON a.id=laa.application_id
server/services/reminders.ts:48:      LEFT JOIN lender_matches m ON m.application_id=a.id
server/services/reminders.ts:87:        await fetch("http://localhost:"+process.env.PORT+"/api/automations/send-sms", { method:"POST", headers:{"Content-Type":"application/json"}, body: JSON.stringify(payload) });
server/services/reminders.ts:98:          await fetch("http://localhost:"+process.env.PORT+"/api/automations/send-email", { method:"POST", headers:{"Content-Type":"application/json"}, body: JSON.stringify(payload) });
server/routes/clientCompat.ts:199:/** POST /api/client-compat/public/applications  (maps client payload ‚Üí Staff DB) */
server/routes/clientCompat.ts:200:r.post("/public/applications", async (req, res) => {
server/routes/clientCompat.ts:208:    // Minimal upsert: create Contact (by email) then Application
server/routes/clientCompat.ts:214:    const appTable = await pickTable(["Application", "applications"]);
server/routes/clientCompat.ts:215:    if (!contactTable || !appTable) throw new Error("Contact/Application tables missing");
server/routes/clientCompat.ts:236:    // APPLICATION create - use valid stage enum value, include required user_id 
server/routes/clientCompat.ts:250:    return res.json({ ok: true, applicationId: appId, status: "received" });
server/services/automatedReminders.ts:55:  targetType: "contact" | "thread" | "application" | "lender_org";
server/services/automatedReminders.ts:92:      if (reminder.target_type === "application") {
server/services/automatedReminders.ts:93:        const [app] = await q<any>(`SELECT contact_id FROM applications WHERE id=$1 LIMIT 1`, [reminder.target_id]);
server/routes/applicationMetadata.ts:12:console.log('üîß [APP-METADATA] Application metadata router loaded');
server/routes/applicationMetadata.ts:19:    message: 'Application metadata router working',
server/routes/applicationMetadata.ts:24:// GET /api/application-metadata/:id - Safe public access to application metadata for upload page
server/routes/applicationMetadata.ts:29:    console.log(`üîç [APP-METADATA] Request for application metadata: ${id}`);
server/routes/applicationMetadata.ts:37:        error: 'Invalid application ID format'
server/routes/applicationMetadata.ts:42:    res.setHeader('Content-Type', 'application/json');
server/routes/applicationMetadata.ts:57:      FROM applications 
server/routes/applicationMetadata.ts:63:      console.log(`‚ùå [APP-METADATA] Application not found: ${id}`);
server/routes/applicationMetadata.ts:66:        error: 'Application not found'
server/routes/applicationMetadata.ts:70:    const application = result.rows[0];
server/routes/applicationMetadata.ts:82:    const category = application.product_category || application.loan_category || 'working_capital';
server/routes/applicationMetadata.ts:83:    const businessName = application.dba_name || application.business_name || 'Business Name Not Set';
server/routes/applicationMetadata.ts:88:      application: {
server/routes/applicationMetadata.ts:89:        id: application.id,
server/routes/applicationMetadata.ts:90:        status: application.status,
server/routes/applicationMetadata.ts:91:        stage: application.stage,
server/routes/applicationMetadata.ts:94:        requestedAmount: application.requested_amount || 'Amount Not Set',
server/routes/applicationMetadata.ts:95:        createdAt: application.created_at,
server/routes/applicationMetadata.ts:100:    console.log(`‚úÖ [APP-METADATA] Returning safe metadata for application: ${id}`);
server/routes/applicationMetadata.ts:104:    console.error(`‚ùå [APP-METADATA] Error fetching application metadata:`, error);
server/routes/applicationMetadata.ts:107:      error: 'Failed to fetch application metadata',
server/routes/applicationMetadata.ts:113:console.log('‚úÖ [APP-METADATA] Application metadata routes registered');
server/services/mergeFields.ts:20:      ApplicationId: "",
server/services/mergeFields.ts:21:      ApplicationStage: "",
server/services/mergeFields.ts:31:  // Pull missing/rejected documents for the most recent application by this contact
server/services/mergeFields.ts:32:  const [application] = await execute(`
server/services/mergeFields.ts:34:    FROM applications a
server/services/mergeFields.ts:42:  if (application) {
server/services/mergeFields.ts:46:      WHERE application_id = $1
server/services/mergeFields.ts:47:    `, [application.id]);
server/services/mergeFields.ts:60:    ApplicationId: application?.id || "",
server/services/mergeFields.ts:61:    ApplicationStage: application?.stage || "",
server/routes/activities.ts:7:  const { contactId, applicationId, limit = "50", cursor } = req.query as any;
server/routes/activities.ts:10:  if (applicationId) where.applicationId = String(applicationId);
server/middleware/fileUploadSecurity.ts:14:  'application/pdf': ['.pdf'],
server/middleware/fileUploadSecurity.ts:18:  'application/msword': ['.doc'],
server/middleware/fileUploadSecurity.ts:19:  'application/vnd.openxmlformats-officedocument.wordprocessingml.document': ['.docx'],
server/middleware/fileUploadSecurity.ts:20:  'application/vnd.ms-excel': ['.xls'],
server/middleware/fileUploadSecurity.ts:21:  'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet': ['.xlsx'],
server/middleware/fileUploadSecurity.ts:37:  const allowedPdfMimes = ['application/pdf', 'application/x-pdf', 'application/octet-stream', 'binary/octet-stream'];
server/middleware/fileUploadSecurity.ts:71:    // Create application-specific directory
server/middleware/fileUploadSecurity.ts:72:    const applicationId = req.params.applicationId || req.params.id || 'temp';
server/middleware/fileUploadSecurity.ts:74:    // Validate applicationId to prevent path traversal
server/middleware/fileUploadSecurity.ts:75:    if (!applicationId || typeof applicationId !== 'string') {
server/middleware/fileUploadSecurity.ts:76:      return cb(new Error('Invalid application ID'));
server/middleware/fileUploadSecurity.ts:82:    const safeId = applicationId.replace(/[^a-zA-Z0-9-_]/g, '');
server/middleware/fileUploadSecurity.ts:84:    if (applicationId !== safeId || (applicationId !== 'temp' && !uuidRegex.test(applicationId) && !numericRegex.test(applicationId))) {
server/middleware/fileUploadSecurity.ts:85:      return cb(new Error('Invalid application ID format'));
server/middleware/fileUploadSecurity.ts:88:    const uploadDir = path.join(process.cwd(), 'uploads', applicationId);
server/routes/voice_calls.ts:16:  // Create Call row (attach contact/application later if we can match by phone)
server/routes/voice_calls.ts:71:    headers: { "Content-Type": "application/json" },
server/routes/voice_calls.ts:78:// Get calls for a contact or application
server/routes/voice_calls.ts:80:  const { contactId, applicationId, tenant = "bf" } = req.query;
server/routes/voice_calls.ts:84:  if (applicationId) where.applicationId = String(applicationId);
server/routes/voice_calls.ts:96:// Activities endpoint for contact/application activity streams
server/routes/voice_calls.ts:98:  const { contactId, applicationId, tenant = "bf", limit = 50 } = req.query;
server/routes/voice_calls.ts:102:  if (applicationId) where.applicationId = String(applicationId);
server/services/ga4.ts:24:      headers: { "Content-Type": "application/json" },
server/routes/analytics-dashboard.ts:3:import { applications, documents, users, lenderUsers, contacts, smsMessages, callLogs, emailMessages } from '../../shared/schema';
server/routes/analytics-dashboard.ts:20:    const [totalApplications] = await db.execute(sql`
server/routes/analytics-dashboard.ts:22:      FROM applications
server/routes/analytics-dashboard.ts:25:    const [activeApplications] = await db.execute(sql`
server/routes/analytics-dashboard.ts:27:      FROM applications 
server/routes/analytics-dashboard.ts:31:    const [completedApplications] = await db.execute(sql`
server/routes/analytics-dashboard.ts:33:      FROM applications 
server/routes/analytics-dashboard.ts:56:    const [recentApplications] = await db.execute(sql`
server/routes/analytics-dashboard.ts:58:      FROM applications 
server/routes/analytics-dashboard.ts:70:        totalApplications: totalApplications?.[0]?.count || 0,
server/routes/analytics-dashboard.ts:71:        activeApplications: activeApplications?.[0]?.count || 0,
server/routes/analytics-dashboard.ts:72:        completedApplications: completedApplications?.[0]?.count || 0,
server/routes/analytics-dashboard.ts:78:        applicationsLast30Days: recentApplications?.[0]?.count || 0,
server/routes/analytics-dashboard.ts:106:// GET /api/reports/pipeline-activity - Pipeline analytics
server/routes/analytics-dashboard.ts:107:router.get('/pipeline-activity', developmentAuth, async (req, res) => {
server/routes/analytics-dashboard.ts:110:    console.log('üìä [ANALYTICS] Fetching pipeline activity');
server/routes/analytics-dashboard.ts:115:    // Get applications in date range
server/routes/analytics-dashboard.ts:118:        id: applications.id,
server/routes/analytics-dashboard.ts:119:        status: applications.status,
server/routes/analytics-dashboard.ts:120:        stage: applications.stage,
server/routes/analytics-dashboard.ts:121:        createdAt: applications.createdAt,
server/routes/analytics-dashboard.ts:122:        submittedAt: applications.submittedAt,
server/routes/analytics-dashboard.ts:123:        requestedAmount: applications.requestedAmount,
server/routes/analytics-dashboard.ts:124:        productCategory: applications.productCategory
server/routes/analytics-dashboard.ts:126:      .from(applications)
server/routes/analytics-dashboard.ts:128:        gte(applications.createdAt, start),
server/routes/analytics-dashboard.ts:129:        lte(applications.createdAt, end)
server/routes/analytics-dashboard.ts:132:    // Applications by status
server/routes/analytics-dashboard.ts:144:    // Applications by stage
server/routes/analytics-dashboard.ts:156:    // Applications trend by date
server/routes/analytics-dashboard.ts:157:    const applicationsByDate = allApps.reduce((acc, app) => {
server/routes/analytics-dashboard.ts:169:    const pipelineData = {
server/routes/analytics-dashboard.ts:176:        applicationsByDate
server/routes/analytics-dashboard.ts:181:    console.log('üìä [ANALYTICS] Pipeline activity generated:', allApps.length, 'applications');
server/routes/analytics-dashboard.ts:185:      data: pipelineData
server/routes/analytics-dashboard.ts:189:    console.error('üìä [ANALYTICS] Pipeline activity error:', error);
server/routes/analytics-dashboard.ts:192:      error: 'Failed to fetch pipeline activity',
server/routes/analytics-dashboard.ts:292:    // Get applications in date range
server/routes/analytics-dashboard.ts:295:        id: applications.id,
server/routes/analytics-dashboard.ts:296:        status: applications.status,
server/routes/analytics-dashboard.ts:297:        stage: applications.stage,
server/routes/analytics-dashboard.ts:298:        createdAt: applications.createdAt,
server/routes/analytics-dashboard.ts:299:        submittedAt: applications.submittedAt
server/routes/analytics-dashboard.ts:301:      .from(applications)
server/routes/analytics-dashboard.ts:303:        gte(applications.createdAt, start),
server/routes/analytics-dashboard.ts:304:        lte(applications.createdAt, end)
server/routes/analytics-dashboard.ts:340:      totalApplications: allApps.length
server/routes/transcribe.ts:51:      "Content-Type": "application/json" 
server/routes/transcribe.ts:100:      applicationId: call.applicationId ?? undefined,
server/middleware/autoSmsApplicationTrigger.ts:2: * Automatic SMS Application Trigger Middleware
server/middleware/autoSmsApplicationTrigger.ts:4: * Automatically triggers SMS notifications for new applications without documents
server/middleware/autoSmsApplicationTrigger.ts:5: * This ensures every new application gets immediate SMS notification regardless of stage
server/middleware/autoSmsApplicationTrigger.ts:11: * Middleware to trigger automatic SMS for new applications without documents
server/middleware/autoSmsApplicationTrigger.ts:13:export function createAutoSmsApplicationTrigger() {
server/middleware/autoSmsApplicationTrigger.ts:19:      // Check if this was a successful application creation
server/middleware/autoSmsApplicationTrigger.ts:20:      if (body && body.success && body.application && body.application.id) {
server/middleware/autoSmsApplicationTrigger.ts:21:        const applicationId = body.application.id;
server/middleware/autoSmsApplicationTrigger.ts:23:        console.log(`üÜï [AUTO-SMS-TRIGGER] New application created: ${applicationId}`);
server/middleware/autoSmsApplicationTrigger.ts:25:        // Trigger automatic SMS check for new applications
server/middleware/autoSmsApplicationTrigger.ts:28:            console.log(`üì± [AUTO-SMS-TRIGGER] Checking if SMS needed for new application: ${applicationId}`);
server/middleware/autoSmsApplicationTrigger.ts:35:            // Count accepted documents for this application
server/middleware/autoSmsApplicationTrigger.ts:39:              .where(eq(documents.applicationId, applicationId));
server/middleware/autoSmsApplicationTrigger.ts:43:            console.log(`üìã [AUTO-SMS-TRIGGER] Application ${applicationId} has ${docCount} documents`);
server/middleware/autoSmsApplicationTrigger.ts:47:              console.log(`üì± [AUTO-SMS-TRIGGER] Sending missing docs SMS for new application: ${applicationId}`);
server/middleware/autoSmsApplicationTrigger.ts:50:              const result = await sendEnhancedSMS(applicationId, 'submission_no_docs');
server/middleware/autoSmsApplicationTrigger.ts:53:                console.log(`‚úÖ [AUTO-SMS-TRIGGER] Missing docs SMS sent successfully for ${applicationId}: ${result.smsId}`);
server/middleware/autoSmsApplicationTrigger.ts:55:                console.error(`‚ùå [AUTO-SMS-TRIGGER] Failed to send SMS for ${applicationId}:`, result.error);
server/middleware/autoSmsApplicationTrigger.ts:58:              console.log(`‚è≠Ô∏è [AUTO-SMS-TRIGGER] Application ${applicationId} has ${docCount} documents, no SMS needed`);
server/middleware/autoSmsApplicationTrigger.ts:62:            console.error(`‚ùå [AUTO-SMS-TRIGGER] Error processing new application ${applicationId}:`, error);
server/middleware/autoSmsApplicationTrigger.ts:64:        }, 2000); // 2-second delay to allow application to be fully saved
server/middleware/autoSmsApplicationTrigger.ts:84:      // Check if this involves application data with potential stage issues
server/middleware/autoSmsApplicationTrigger.ts:86:        // This looks like the applications list response
server/middleware/autoSmsApplicationTrigger.ts:87:        body.forEach((application: any) => {
server/middleware/autoSmsApplicationTrigger.ts:88:          const { id, stage, totalDocs } = application;
server/middleware/autoSmsApplicationTrigger.ts:94:            // Trigger pipeline evaluation and SMS
server/middleware/autoSmsApplicationTrigger.ts:97:                const { PipelineService } = await import('../services/pipelineService.js');
server/middleware/autoSmsApplicationTrigger.ts:98:                const result = await PipelineService.evaluateAndUpdateStage(id);
server/services/reminders-fixed.ts:7:    const applications = await q(`
server/services/reminders-fixed.ts:9:      FROM applications 
server/services/reminders-fixed.ts:15:    console.log(`[REMINDERS] Found ${applications.length} applications needing follow-up`);
server/services/reminders-fixed.ts:16:    return applications;
server/routes/lender_docs.ts:13:r.get("/applications/:id/requirements", async (req, res) => {
server/routes/lender_docs.ts:14:  // Resolve best product for this application (if set), else return union across lender's products
server/routes/lender_docs.ts:15:  const app = await db.applications.findUnique({ 
server/routes/aiTraining.ts:28:    const allowedTypes = ['application/pdf', 'text/plain', 'application/json', 'application/msword', 'application/vnd.openxmlformats-officedocument.wordprocessingml.document'];
server/routes/aiTraining.ts:43:      case 'application/pdf':
server/routes/aiTraining.ts:49:      case 'application/json':
server/routes/aiTraining.ts:52:      case 'application/msword':
server/routes/aiTraining.ts:53:      case 'application/vnd.openxmlformats-officedocument.wordprocessingml.document':
server/services/analytics.ts:8:      (SELECT COUNT(*) FROM applications WHERE DATE(created_at)=${dayISO}) AS apps_created,
server/services/analytics.ts:9:      (SELECT COUNT(*) FROM applications WHERE funded_at IS NOT NULL AND DATE(funded_at)=${dayISO}) AS apps_funded,
server/services/analytics.ts:10:      (SELECT COALESCE(SUM(amount_funded),0) FROM applications WHERE funded_at IS NOT NULL AND DATE(funded_at)=${dayISO}) AS funded_amount,
server/services/analytics.ts:53:      (SELECT COUNT(*) FROM applications WHERE status='pending') AS pending_apps,
server/services/analytics.ts:54:      (SELECT COUNT(*) FROM applications WHERE status='approved') AS approved_apps,
server/services/analytics.ts:55:      (SELECT COUNT(*) FROM applications WHERE status='funded') AS funded_apps,
server/middleware/deletionProtection.ts:92:      // Allow legitimate application deletions for staff workflow (including test route)
server/middleware/deletionProtection.ts:93:      const isApplicationDeletion = req.originalUrl.match(/^\/api\/applications\/[a-f0-9\-]{36}$/) ||
server/middleware/deletionProtection.ts:94:                                   req.originalUrl === '/api/applications/test-delete';
server/middleware/deletionProtection.ts:96:      // DEBUG: Check application deletion match
server/middleware/deletionProtection.ts:97:      console.log(`üîç [DEBUG] Checking isApplicationDeletion for: ${req.originalUrl}`);
server/middleware/deletionProtection.ts:98:      console.log(`üîç [DEBUG] UUID pattern match: ${!!req.originalUrl.match(/^\/api\/applications\/[a-f0-9\-]{36}$/)}`);
server/middleware/deletionProtection.ts:99:      console.log(`üîç [DEBUG] Test-delete match: ${req.originalUrl === '/api/applications/test-delete'}`);
server/middleware/deletionProtection.ts:100:      console.log(`üîç [DEBUG] Final isApplicationDeletion: ${!!isApplicationDeletion}`);
server/middleware/deletionProtection.ts:103:      const isAdminBypassable = isApplicationDeletion || 
server/middleware/deletionProtection.ts:122:        console.log(`üîç [BYPASS LOGIC] isAdminBypassable: ${isAdminBypassable}, isApplicationDeletion: ${!!isApplicationDeletion}, isAdmin: ${adminBypassResult.isAdmin}`);
server/middleware/deletionProtection.ts:128:        } else if (isApplicationDeletion) {
server/middleware/deletionProtection.ts:129:          // Allow application deletions for staff workflow (existing logic)
server/middleware/deletionProtection.ts:130:          console.log(`‚úÖ [AUTHORIZED DELETE] Application deletion allowed for staff workflow: ${req.originalUrl}`);
server/middleware/deletionProtection.ts:134:          console.log(`üîç [ACCESS DENIED] Reason: isApplicationDeletion=${!!isApplicationDeletion}, isAdmin=${adminBypassResult.isAdmin}`);
server/middleware/documentUploadStageUpdater.ts:3: * Automatically triggers pipeline evaluation when documents are uploaded
server/middleware/documentUploadStageUpdater.ts:9: * Middleware to trigger pipeline evaluation after document uploads
server/middleware/documentUploadStageUpdater.ts:18:      if (body && body.success && body.document && body.document.application_id) {
server/middleware/documentUploadStageUpdater.ts:19:        const applicationId = body.document.application_id;
server/middleware/documentUploadStageUpdater.ts:21:        console.log(`üìÑ [DOC-UPLOAD-STAGE] Document uploaded for application: ${applicationId}`);
server/middleware/documentUploadStageUpdater.ts:23:        // Trigger pipeline evaluation asynchronously (don't wait)
server/middleware/documentUploadStageUpdater.ts:24:        import('../services/pipelineService.js').then(({ PipelineService }) => {
server/middleware/documentUploadStageUpdater.ts:25:          PipelineService.evaluateAndUpdateStage(applicationId)
server/middleware/documentUploadStageUpdater.ts:28:                console.log(`‚úÖ [DOC-UPLOAD-STAGE] Stage updated after upload: ${applicationId} ‚Üí ${result.evaluation.suggestedStage}`);
server/middleware/documentUploadStageUpdater.ts:30:                console.log(`‚è≠Ô∏è [DOC-UPLOAD-STAGE] No stage change needed for: ${applicationId}`);
server/middleware/documentUploadStageUpdater.ts:34:              console.error(`‚ùå [DOC-UPLOAD-STAGE] Pipeline evaluation failed for ${applicationId}:`, error);
server/middleware/documentUploadStageUpdater.ts:37:          console.error(`‚ùå [DOC-UPLOAD-STAGE] Failed to import PipelineService:`, importError);
server/middleware/documentUploadStageUpdater.ts:60:        const applicationId = req.params.applicationId || body.applicationId;
server/middleware/documentUploadStageUpdater.ts:62:        if (applicationId) {
server/middleware/documentUploadStageUpdater.ts:63:          console.log(`üìã [DOC-ACCEPT-STAGE] Document acceptance/rejection for application: ${applicationId}`);
server/middleware/documentUploadStageUpdater.ts:65:          // Trigger pipeline evaluation asynchronously 
server/middleware/documentUploadStageUpdater.ts:67:            import('../services/pipelineService.js').then(({ PipelineService }) => {
server/middleware/documentUploadStageUpdater.ts:68:              PipelineService.evaluateAndUpdateStage(applicationId)
server/middleware/documentUploadStageUpdater.ts:71:                    console.log(`‚úÖ [DOC-ACCEPT-STAGE] Stage updated after document decision: ${applicationId} ‚Üí ${result.evaluation.suggestedStage}`);
server/middleware/documentUploadStageUpdater.ts:73:                    console.log(`‚è≠Ô∏è [DOC-ACCEPT-STAGE] No stage change needed for: ${applicationId}`);
server/middleware/documentUploadStageUpdater.ts:77:                  console.error(`‚ùå [DOC-ACCEPT-STAGE] Pipeline evaluation failed for ${applicationId}:`, error);
server/middleware/documentUploadStageUpdater.ts:80:              console.error(`‚ùå [DOC-ACCEPT-STAGE] Failed to import PipelineService:`, importError);
server/services/graphAuth.ts:1:import { ConfidentialClientApplication, Configuration } from "@azure/msal-node";
server/services/graphAuth.ts:13:const msal = new ConfidentialClientApplication(config);
server/middleware/autoDocumentProcessor.ts:20:export async function processDocument(documentId: string, applicationId: string, fileName: string, documentType: string): Promise<DocumentProcessingResult> {
server/middleware/autoDocumentProcessor.ts:38:          applicationId: applicationId,
server/middleware/autoDocumentProcessor.ts:55:            application_id,
server/middleware/autoDocumentProcessor.ts:63:            ${applicationId},
server/middleware/autoDocumentProcessor.ts:76:          const bankingResponse = await fetch(`http://localhost:5000/api/banking-analysis/${applicationId}`, {
server/middleware/autoDocumentProcessor.ts:79:              'Content-Type': 'application/json',
server/middleware/autoDocumentProcessor.ts:114: * Process all documents for an application
server/middleware/autoDocumentProcessor.ts:116:export async function processApplicationDocuments(applicationId: string): Promise<DocumentProcessingResult[]> {
server/middleware/autoDocumentProcessor.ts:118:    console.log(`üîÑ [AUTO-PROCESSOR] Processing all documents for application: ${applicationId}`);
server/middleware/autoDocumentProcessor.ts:120:    // Get all bank statement documents for the application
server/middleware/autoDocumentProcessor.ts:124:      WHERE application_id = ${applicationId}
server/middleware/autoDocumentProcessor.ts:130:      console.log(`üìÑ [AUTO-PROCESSOR] No bank statement documents found for application: ${applicationId}`);
server/middleware/autoDocumentProcessor.ts:140:      const result = await processDocument(doc.id, applicationId, doc.file_name, doc.document_type);
server/middleware/autoDocumentProcessor.ts:147:    console.log(`‚úÖ [AUTO-PROCESSOR] Application ${applicationId} processing complete: ${successCount} successful, ${errorCount} errors`);
server/middleware/autoDocumentProcessor.ts:152:    console.error(`‚ùå [AUTO-PROCESSOR] Application processing error:`, error);
server/middleware/autoDocumentProcessor.ts:167:      if (data && data.success && data.documentId && data.applicationId) {
server/middleware/autoDocumentProcessor.ts:175:              data.applicationId,
server/middleware/autoDocumentProcessor.ts:203:  processApplicationDocuments,
server/routes/adminReassignment.ts:55:    const { targetApplicationId } = req.body;
server/routes/adminReassignment.ts:57:    if (!targetApplicationId) {
server/routes/adminReassignment.ts:60:        error: 'Missing target application ID',
server/routes/adminReassignment.ts:61:        message: 'targetApplicationId is required in request body'
server/routes/adminReassignment.ts:67:    if (!uuidRegex.test(documentId) || !uuidRegex.test(targetApplicationId)) {
server/routes/adminReassignment.ts:71:        message: 'Both documentId and targetApplicationId must be valid UUIDs'
server/routes/adminReassignment.ts:90:    const originalApplicationId = document.applicationId;
server/routes/adminReassignment.ts:92:    // Reassign document to target application
server/routes/adminReassignment.ts:96:        applicationId: targetApplicationId,
server/routes/adminReassignment.ts:102:    console.log(`üìÑ [ADMIN REASSIGNMENT] Document ${documentId} moved from ${originalApplicationId} to ${targetApplicationId} by ${req.admin.email}`);
server/routes/adminReassignment.ts:109:        originalApplicationId,
server/routes/adminReassignment.ts:110:        newApplicationId: targetApplicationId,
server/routes/adminReassignment.ts:127:router.get('/documents/history/:applicationId', requireAdmin, async (req: any, res) => {
server/routes/adminReassignment.ts:129:    const { applicationId } = req.params;
server/routes/adminReassignment.ts:135:      .where(eq(documents.applicationId, applicationId));
server/routes/adminReassignment.ts:139:      applicationId,
server/routes/linkedin_audiences.ts:15: *     { "field":"application.status|lenderId|ownerId", "op":"eq|in", "value":"..."|["..."] },
server/routes/linkedin_audiences.ts:63:    const apps = await db.applications.findMany({ where: whereApps, select: { contact_id: true } });
server/routes/linkedin_audiences.ts:84:    const apps = await db.applications.findMany({ where: whereApps, select: { contact_id: true } });
server/routes/linkedin_audiences.ts:139:    } else if (entity === "application") {
server/routes/linkedin_audiences.ts:150:    } else if (entity === "application") {
server/routes/linkedin_audiences.ts:179:    case "status":   return { status: Array.isArray(val) ? isin(val) : eq(val) }; // for Application.status when used in appClauses
server/routes/linkedin_audiences.ts:180:    case "lenderId": return { lender_id: Array.isArray(val) ? isin(val) : eq(val) }; // for Application
server/routes/linkedin_audiences.ts:190:    const apps = await db.applications.findMany({ where: whereApps, select: { contact_id: true } });
server/middleware/pipelineTriggers.ts:2: * üéØ PIPELINE TRIGGER MIDDLEWARE
server/middleware/pipelineTriggers.ts:4: * Middleware to automatically trigger pipeline stage evaluation
server/middleware/pipelineTriggers.ts:8:import PipelineService from '../services/pipelineService';
server/middleware/pipelineTriggers.ts:10:export function triggerPipelineOnDocumentChange(changeType: 'upload' | 'status_change' | 'delete') {
server/middleware/pipelineTriggers.ts:17:      // Override response methods to trigger pipeline after successful response
server/middleware/pipelineTriggers.ts:20:        triggerPipelineAsync(req, changeType);
server/middleware/pipelineTriggers.ts:26:        triggerPipelineAsync(req, changeType);
server/middleware/pipelineTriggers.ts:33:      console.error('‚ùå [PIPELINE TRIGGER] Middleware error:', error);
server/middleware/pipelineTriggers.ts:39:async function triggerPipelineAsync(req: any, changeType: 'upload' | 'status_change' | 'delete') {
server/middleware/pipelineTriggers.ts:41:    // Extract application ID from various possible locations
server/middleware/pipelineTriggers.ts:42:    const applicationId = req.params.applicationId || 
server/middleware/pipelineTriggers.ts:44:                         req.body.applicationId || 
server/middleware/pipelineTriggers.ts:45:                         req.body.application_id;
server/middleware/pipelineTriggers.ts:47:    if (applicationId) {
server/middleware/pipelineTriggers.ts:48:      console.log(`üéØ [PIPELINE TRIGGER] Document ${changeType} detected for ${applicationId}`);
server/middleware/pipelineTriggers.ts:50:      // Trigger pipeline evaluation asynchronously (don't wait)
server/middleware/pipelineTriggers.ts:51:      PipelineService.onDocumentChange(applicationId, changeType).catch(error => {
server/middleware/pipelineTriggers.ts:52:        console.error('‚ùå [PIPELINE TRIGGER] Error in async processing:', error);
server/middleware/pipelineTriggers.ts:57:    console.error('‚ùå [PIPELINE TRIGGER] Error extracting application ID:', error);
server/middleware/pipelineTriggers.ts:62:  triggerPipelineOnDocumentChange
server/routes/approvals.ts:20:    const { contactId, applicationId, channel, action, toAddress, preview, body, meta } = req.body || {};
server/routes/approvals.ts:33:      applicationId, 
server/routes/approvals.ts:47:      applicationId: applicationId || undefined,
server/routes/approvals.ts:151:        applicationId: ar.applicationId || undefined,
server/routes/approvals.ts:168:          applicationId: ar.applicationId || undefined,
server/routes/approvals.ts:181:          applicationId: ar.applicationId || undefined,
server/routes/approvals.ts:196:        applicationId: ar.applicationId || undefined,
server/services/pipelineSms.ts:1:// SMS service for pipeline stage transitions
server/services/pipelineSms.ts:9:  //   body: `Your application has been updated to: ${stage}`,
server/middleware/deletionLogger.ts:4: * Logs all application deletions with comprehensive audit trail
server/middleware/deletionLogger.ts:5: * Prevents auto-deletion of fallback applications during cleanup
server/middleware/deletionLogger.ts:13:  application_id: string;
server/middleware/deletionLogger.ts:21:  application_data?: any;
server/middleware/deletionLogger.ts:24:export class ApplicationDeletionLogger {
server/middleware/deletionLogger.ts:29:        INSERT INTO application_deletion_log (
server/middleware/deletionLogger.ts:30:          application_id, user_id, user_email, source, deletion_reason,
server/middleware/deletionLogger.ts:31:          ip_address, user_agent, deleted_at, application_data
server/middleware/deletionLogger.ts:33:          ${entry.application_id}, ${entry.user_id || null}, ${entry.user_email || null}, 
server/middleware/deletionLogger.ts:35:          ${entry.user_agent || null}, ${entry.deleted_at}, ${JSON.stringify(entry.application_data) || null}
server/middleware/deletionLogger.ts:39:      console.log(`üóëÔ∏è [DELETION LOG] Application ${entry.application_id} deleted by ${entry.user_email || 'system'} via ${entry.source}`);
server/middleware/deletionLogger.ts:45:  static async preventFallbackDeletion(applicationId: string): Promise<boolean> {
server/middleware/deletionLogger.ts:46:    // Prevent deletion of fallback applications
server/middleware/deletionLogger.ts:47:    if (applicationId.startsWith('fallback_')) {
server/middleware/deletionLogger.ts:48:      console.log(`üõ°Ô∏è [DELETION PROTECTION] Preventing deletion of fallback application: ${applicationId}`);
server/middleware/deletionLogger.ts:52:    // Check if application has fallback documents
server/middleware/deletionLogger.ts:55:      WHERE application_id = ${applicationId} AND storage_status = 'fallback'
server/middleware/deletionLogger.ts:61:      console.log(`üõ°Ô∏è [DELETION PROTECTION] Preventing deletion of application with fallback documents: ${applicationId}`);
server/middleware/deletionLogger.ts:75:    if (req.method === 'DELETE' && req.route?.path?.includes('applications') && res.statusCode >= 200 && res.statusCode < 300) {
server/middleware/deletionLogger.ts:76:      const applicationId = req.params.id;
server/middleware/deletionLogger.ts:78:      if (applicationId) {
server/middleware/deletionLogger.ts:80:          application_id: applicationId,
server/middleware/deletionLogger.ts:88:          application_data: (req as any).deletedApplicationData
server/middleware/deletionLogger.ts:92:        ApplicationDeletionLogger.logDeletion(logEntry).catch(console.error);
server/routes/approvals_request.ts:12:    const { contactId, applicationId, channel, action, toAddress, preview, body, meta } = req.body || {};
server/routes/approvals_request.ts:25:      applicationId, 
server/routes/approvals_request.ts:39:      applicationId: applicationId || undefined,
server/routes/admin.disabled.ts:348:    // In a real application, you would send an email here
server/services/stageMachine.ts:1:import { smsOnStage, smsOnFundsDisbursed, createFollowUpTask, logStageTransition } from './pipelineSms';
server/services/stageMachine.ts:3:// Pipeline stage definitions
server/services/stageMachine.ts:4:export const PIPELINE_STAGES = [
server/services/stageMachine.ts:13:export type PipelineStage = typeof PIPELINE_STAGES[number];
server/services/stageMachine.ts:26:const VALID_TRANSITIONS: Record<PipelineStage, PipelineStage[]> = {
server/services/stageMachine.ts:35:interface Application {
server/services/stageMachine.ts:37:  currentStage: PipelineStage;
server/services/stageMachine.ts:51:  app: Application;
server/services/stageMachine.ts:53:  targetStage: PipelineStage;
server/services/stageMachine.ts:62:export function isTransitionAllowed(from: PipelineStage, to: PipelineStage): boolean {
server/services/stageMachine.ts:69:export function hasStagePermission(stage: PipelineStage, userRole: string): boolean {
server/services/stageMachine.ts:75: * Auto-evaluate stage transitions based on application state
server/services/stageMachine.ts:77:export function evaluateAutoTransitions(app: Application): { shouldMove: boolean; targetStage?: PipelineStage; reason?: string } {
server/services/stageMachine.ts:148:async function executeStageEntryActions(stage: PipelineStage, app: Application, contact: Contact): Promise<void> {
server/services/stageMachine.ts:191:async function startStageTimers(stage: PipelineStage, appId: string): Promise<void> {
server/middleware/inputValidation.ts:81:  // Application schemas
server/middleware/inputValidation.ts:82:  createApplication: {
server/middleware/inputValidation.ts:105:  updateApplication: {
server/middleware/inputValidation.ts:163:      applicationId: securitySchemas.uuid
server/middleware/inputValidation.ts:217:      applicationId: securitySchemas.uuid,
server/routes/approvals_sms_inbound.ts:89:        applicationId: ar.applicationId || undefined,
server/routes/approvals_sms_inbound.ts:106:          applicationId: ar.applicationId || undefined,
server/routes/approvals_sms_inbound.ts:119:          applicationId: ar.applicationId || undefined,
server/routes/approvals_sms_inbound.ts:134:        applicationId: ar.applicationId || undefined,
server/routes/data.ts:6:type Table = "lenders" | "lender_products" | "applications" | "users" | "contacts" | "ads_campaigns";
server/routes/data.ts:10:  applications:    { model: "applications",     defaultOrder: "-created_at",  expand: { businesses: true, users: true, lender: true } },
server/routes/data.ts:18:  lender: any; lenderProduct: any; applications: any; users: any; contacts: any; adsCampaign: any;
server/routes/data.ts:63:    case "applications": return "applications";
server/routes/data.ts:183:        relations: ["products", "applications"],
server/routes/data.ts:192:      applications: {
server/routes/data.ts:193:        table: "applications",
server/routes/data.ts:201:        relations: ["applications"],
server/routes/publicApi.ts:3:import { documents, applications, businesses, expectedDocuments } from '../../shared/schema';
server/routes/publicApi.ts:12:import type { InsertApplication } from '../../shared/schema';
server/routes/publicApi.ts:36:// Application metadata endpoint for upload page
server/routes/publicApi.ts:37:console.log('üîß [ROUTE-REGISTRATION] Registering /application/:id route');
server/routes/publicApi.ts:38:router.get('/application/:id', (req, res) => {
server/routes/publicApi.ts:40:  console.log(`üîç [PUBLIC-METADATA] Request for application: ${id}`);
server/routes/publicApi.ts:46:      error: 'Invalid application ID'
server/routes/publicApi.ts:53:    application: {
server/routes/publicApi.ts:72:      SELECT DISTINCT application_id
server/routes/publicApi.ts:85:    const uuid = result.rows[0].application_id;
server/routes/publicApi.ts:138:    const validTypes = ['bank_statements', 'financial_statements', 'tax_returns', 'signed_application', 'id_documents', 'business_license'];
server/routes/publicApi.ts:176:router.post('/s3-upload/:applicationId', 
server/routes/publicApi.ts:181:  const { applicationId } = req.params;
server/routes/publicApi.ts:185:  console.log(`[S3] Upload request for application ${applicationId}`);
server/routes/publicApi.ts:204:    // Verify application exists
server/routes/publicApi.ts:205:    const [application] = await db.select().from(applications).where(eq(applications.id, applicationId));
server/routes/publicApi.ts:206:    if (!application) {
server/routes/publicApi.ts:207:      console.log(`‚ùå [S3-UPLOAD] Application ${applicationId} not found in database`);
server/routes/publicApi.ts:210:        error: 'Application not found',
server/routes/publicApi.ts:211:        errorCode: 'APPLICATION_NOT_FOUND',
server/routes/publicApi.ts:212:        applicationId: applicationId,
server/routes/publicApi.ts:213:        message: `Application with ID ${applicationId} does not exist in the database`,
server/routes/publicApi.ts:215:        suggestion: 'Verify the application ID and ensure the application has been properly created'
server/routes/publicApi.ts:223:      applicationId,
server/routes/publicApi.ts:235:        const response = await fetch(`http://localhost:5000/api/ocr/application/${applicationId}`, {
server/routes/publicApi.ts:238:            'Content-Type': 'application/json',
server/routes/publicApi.ts:244:          console.log(`[OCR] OCR triggered successfully for application ${applicationId}`);
server/routes/publicApi.ts:328://   console.log(`‚úÖ Received file: ${file?.originalname || 'unknown'} for application ${id} as ${type}`);
server/routes/publicApi.ts:388://         const response = await fetch(`http://localhost:5000/api/ocr/application/${id}`, {
server/routes/publicApi.ts:391://             'Content-Type': 'application/json',
server/routes/publicApi.ts:397://           console.log(`‚úÖ [AUTO-OCR] OCR triggered successfully for application ${id}`);
server/routes/publicApi.ts:408://       const { PipelineAutomationService } = await import('../services/pipelineAutomation');
server/routes/publicApi.ts:409://       await PipelineAutomationService.notifyDocumentUpload(id, type, file.originalname);
server/routes/publicApi.ts:415://     // Required staff application response format
server/routes/publicApi.ts:433:// 2. Application Final Submission Endpoint - MOVED TO publicApplications.ts router
server/routes/publicApi.ts:434:// This endpoint is now handled by server/routes/applications/submit.ts via publicApplications router
server/routes/publicApi.ts:468:    const { id: applicationId } = req.params;
server/routes/publicApi.ts:474:      applicationId, 
server/routes/publicApi.ts:482:    if (!applicationId) {
server/routes/publicApi.ts:484:        error: 'Application ID is required'
server/routes/publicApi.ts:497:    // Verify application exists
server/routes/publicApi.ts:498:    const [application] = await db
server/routes/publicApi.ts:500:      .from(applications)
server/routes/publicApi.ts:501:      .where(eq(applications.id, applicationId));
server/routes/publicApi.ts:503:    if (!application) {
server/routes/publicApi.ts:505:        error: 'Application not found'
server/routes/publicApi.ts:516:      applicationId,
server/routes/publicApi.ts:538:          eq(expectedDocuments.applicationId, applicationId),
server/routes/publicApi.ts:679:// applicationsCreateRouter removed - integrated inline for simplicity
server/routes/publicApi.ts:686:// POST /api/public/applications/:id/documents
server/routes/publicApi.ts:687:router.post('/applications/:id/documents', s3Upload.single('document'), async (req: any, res) => {
server/routes/publicApi.ts:690:  console.log(`üì§ [Client Document Upload] Application ID: ${req.params.id}`);
server/routes/publicApi.ts:700:    const rawApplicationId = req.params.id;
server/routes/publicApi.ts:705:    const actualId = rawApplicationId.replace(/^test-/, '');
server/routes/publicApi.ts:707:    console.log(`üì§ [Client Document Upload] Application ID: ${rawApplicationId} ‚Üí ${actualId}`);
server/routes/publicApi.ts:710:    if (!rawApplicationId) {
server/routes/publicApi.ts:712:        error: 'Application ID is required'
server/routes/publicApi.ts:732:        error: 'Invalid application ID format'
server/routes/publicApi.ts:736:    console.log(`üîç [Client Document Upload] Validating application: ${actualId}`);
server/routes/publicApi.ts:738:    // Check if application exists
server/routes/publicApi.ts:739:    const applicationResult = await db.query.applications.findFirst({
server/routes/publicApi.ts:740:      where: (applications, { eq }) => eq(applications.id, actualId)
server/routes/publicApi.ts:743:    if (!applicationResult) {
server/routes/publicApi.ts:745:        error: 'Application not found',
server/routes/publicApi.ts:746:        details: `No application found with ID: ${actualId}`
server/routes/publicApi.ts:781:    console.log(`‚úÖ [Client Document Upload] Application: ${actualId}`);
server/routes/publicApi.ts:786:      applicationId: rawApplicationId,  // Return original ID with test- prefix
server/routes/publicApi.ts:803:// GET /api/public/applications/:id/documents
server/routes/publicApi.ts:804:// Returns S3-mapped documents for both UUID and app_ format application IDs
server/routes/publicApi.ts:805:router.get('/applications/:id/documents', async (req, res) => {
server/routes/publicApi.ts:807:    const rawApplicationId = req.params.id;
server/routes/publicApi.ts:808:    let actualId = rawApplicationId;
server/routes/publicApi.ts:811:    if (rawApplicationId.startsWith('test-')) {
server/routes/publicApi.ts:812:      actualId = rawApplicationId.replace(/^test-/, '');
server/routes/publicApi.ts:815:    console.log(`üìÑ [DUAL-FORMAT] Document request for: ${rawApplicationId} ‚Üí ${actualId}`);
server/routes/publicApi.ts:822:      console.error(`‚ùå [DUAL-FORMAT] Invalid application ID format: ${actualId}`);
server/routes/publicApi.ts:824:        error: 'Invalid application ID format',
server/routes/publicApi.ts:840:        SELECT DISTINCT application_id
server/routes/publicApi.ts:857:          applicationId: actualId,
server/routes/publicApi.ts:863:      dbId = storageResult.rows[0].application_id;
server/routes/publicApi.ts:867:      // For UUID format, verify application exists
server/routes/publicApi.ts:870:      const appResult = await pool.query('SELECT id FROM applications WHERE id = $1', [actualId]);
server/routes/publicApi.ts:872:        console.error(`‚ùå [DUAL-FORMAT] Application not found: ${actualId}`);
server/routes/publicApi.ts:874:          error: 'Application not found',
server/routes/publicApi.ts:875:          applicationId: actualId
server/routes/publicApi.ts:892:      WHERE application_id = $1 
server/routes/publicApi.ts:906:      applicationId: actualId,
server/routes/publicApi.ts:924:// Helper function to create application from client data
server/routes/publicApi.ts:925:async function createApplicationFromClient(data: any) {
server/routes/publicApi.ts:926:  console.log('üöÄ [APPLICATION CREATION] Starting application creation from client data');
server/routes/publicApi.ts:927:  console.log('üìÑ [APPLICATION CREATION] Raw payload:', JSON.stringify(data, null, 2));
server/routes/publicApi.ts:961:  // Create application data structure
server/routes/publicApi.ts:962:  const applicationData: InsertApplication = {
server/routes/publicApi.ts:1005:  console.log('üìã [APPLICATION CREATION] Processed application data:', JSON.stringify(applicationData, null, 2));
server/routes/publicApi.ts:1007:  const application = await storage.createApplication(applicationData);
server/routes/publicApi.ts:1008:  console.log('‚úÖ [APPLICATION CREATION] Successfully created application:', application.id);
server/routes/publicApi.ts:1010:  return application;
server/routes/publicApi.ts:1020:        'POST /api/public/applications - Create new application (step-based format)',
server/routes/publicApi.ts:1021:        'GET /api/public/application/:id - Get safe application metadata (unauthenticated)',
server/routes/publicApi.ts:1022:        'PATCH /api/public/applications/:id/finalize - Submit application',
server/routes/publicApi.ts:1023:        'POST /api/public/documents/:applicationId - Upload documents',
server/routes/publicApi.ts:1026:      application_routes: [
server/routes/publicApi.ts:1027:        'GET /api/applications - Get all applications',
server/routes/publicApi.ts:1028:        'GET /api/applications/:id - Get specific application',
server/routes/publicApi.ts:1029:        'PATCH /api/applications/:id - Update application',
server/routes/publicApi.ts:1030:        'DELETE /api/applications/:id - Delete application'
server/routes/publicApi.ts:1050:        application_creation: {
server/middleware/requireApproval.ts:22:    const { contactId, applicationId, channel, action, toAddress, preview, body, meta } = req.body || {};
server/middleware/requireApproval.ts:35:      applicationId,
server/services/pipelineRules.ts:1:import { PipelineStage, AppDocMeta } from "../domain/pipeline";
server/services/pipelineRules.ts:8:export function evaluateStage(current: PipelineStage, docs: AppDocMeta[]): PipelineStage {
server/routes/checklist_tasks.ts:21:r.post("/applications/:id/tasks/from-requirements", async (req, res) => {
server/routes/checklist_tasks.ts:23:  const app = await db.applications.findUnique({ 
server/routes/checklist_tasks.ts:26:  if (!app) return res.status(404).json({ ok: false, error: "application_not_found" });
server/routes/checklist_tasks.ts:51:        applicationId: app.id,
server/routes/checklist_tasks.ts:66:    applicationId: app.id,
server/routes/checklist_tasks.ts:76:  const cov = await fetch(`http://localhost:5000/api/docs/coverage?applicationId=${app.id}`)
server/routes/checklist_tasks.ts:89:        applicationId: app.id,
server/routes/docs_extract.ts:9: * body: { applicationId?, contactId?, docType, payload }
server/routes/docs_extract.ts:13:  const { applicationId, contactId, docType, payload } = req.body || {};
server/routes/docs_extract.ts:70:      applicationId: applicationId || null,
server/routes/docs_extract.ts:82: * GET /api/docs/coverage?applicationId=... 
server/routes/docs_extract.ts:86:  const { applicationId } = req.query as any;
server/routes/docs_extract.ts:87:  if (!applicationId) {
server/routes/docs_extract.ts:88:    return res.status(400).json({ ok: false, error: "applicationId_required" });
server/routes/docs_extract.ts:92:    where: { applicationId: String(applicationId) } 
server/services/graphMail.ts:10:      "Content-Type": "application/json" 
server/services/graphMail.ts:39:      "Content-Type": "application/json" 
server/routes/partnerReferral.ts:140: * GET /api/partner-referral/pipeline-view
server/routes/partnerReferral.ts:141: * Role-restricted pipeline view - shows different data based on user role
server/routes/partnerReferral.ts:143:router.get('/pipeline-view', async (req: any, res: any) => async (req, res) => {
server/routes/partnerReferral.ts:144:  console.log('üìã [PARTNER-REFERRAL] Pipeline view request');
server/routes/partnerReferral.ts:156:    // Get contacts and enrich with pipeline data
server/routes/partnerReferral.ts:159:    // Transform contacts for pipeline view
server/routes/partnerReferral.ts:160:    const pipelineData = contacts.map(contact => ({
server/routes/partnerReferral.ts:176:    let filteredPipeline = pipelineData;
server/routes/partnerReferral.ts:180:      filteredPipeline = pipelineData.filter(item => item.source === 'partner_referral');
server/routes/partnerReferral.ts:184:    filteredPipeline.sort((a, b) => {
server/routes/partnerReferral.ts:193:      pipeline: filteredPipeline,
server/routes/partnerReferral.ts:195:      count: filteredPipeline.length,
server/routes/partnerReferral.ts:204:    console.error('‚ùå [PARTNER-REFERRAL] Error fetching pipeline view:', error);
server/routes/partnerReferral.ts:207:      error: 'Failed to fetch pipeline view',
server/routes/partnerReferral.ts:214: * Helper function to determine pipeline stage from contact data
server/routes/partnerReferral.ts:273:      pipelineFiltering: true,
server/routes/partnerReferral.ts:281:      pipelineView: 'GET /api/partner-referral/pipeline-view',
server/routes/ads_negatives.ts:60:      "Content-Type": "application/json" 
server/services/siloRepo.ts:19:  pipeline: [
server/services/siloRepo.ts:50:  pipeline: {
server/services/siloRepo.ts:51:    async board(silo: string) { return withSilo("pipeline", silo); },
server/services/siloRepo.ts:53:      const rows = await withSilo("pipeline", silo); 
server/routes/pipeline-repair.ts:4:type AppCard = {
server/routes/pipeline-repair.ts:14:const demo: Record<StageId, AppCard[]> = {
server/routes/pipeline-repair.ts:31:/** Return a board: stages ‚Üí cards. */
server/routes/pipeline-repair.ts:49:/** Move a card to a different stage. */
server/routes/pipeline-repair.ts:56:  let card: AppCard | undefined;
server/routes/pipeline-repair.ts:60:      [card] = demo[s].splice(i, 1);
server/routes/pipeline-repair.ts:64:  if (!card) return res.status(404).json({ ok: false, error: "card not found" });
server/routes/pipeline-repair.ts:66:  card.status = target;
server/routes/pipeline-repair.ts:67:  card.updatedAt = new Date().toISOString();
server/routes/pipeline-repair.ts:68:  card.timeline = [{ ts: card.updatedAt, message: `Moved to ${target}` }, ...(card.timeline || [])];
server/routes/pipeline-repair.ts:69:  demo[target].unshift(card);
server/routes/pipeline-repair.ts:71:  res.json({ ok: true, card });
server/services/partnerReferralService.ts:7: * Handles incoming calls from dedicated Twilio lines and creates contact cards
server/services/partnerReferralService.ts:14:  '+17753146801': 'application',
server/services/partnerReferralService.ts:30: * Automatically creates Contact Card based on source mapping
server/services/partnerReferralService.ts:93:      // Create new contact card
server/services/partnerReferralService.ts:297:          sourceType: 'application',
server/middleware/observability.ts:19:    // long digit strings (cards/accounts)
server/routes/ocrEnhanced.ts:4:import { documents, applications, ocrResults } from '../../shared/schema.ts';
server/routes/ocrEnhanced.ts:81:router.get('/status/:applicationId', async (req: any, res: Response) => {
server/routes/ocrEnhanced.ts:83:    const { applicationId } = req.params;
server/routes/ocrEnhanced.ts:85:    // Get all documents for the application
server/routes/ocrEnhanced.ts:87:      .where(eq(documents.applicationId, applicationId));
server/routes/ocrEnhanced.ts:100:      applicationId,
server/routes/slf-contacts-new.ts:142:      const r = await fetch(u, { method: "PATCH", headers: authHeaders({ "Content-Type": "application/json" }) as any, body: JSON.stringify(req.body) });
server/services/notify.ts:55:      return `${ctx.firstName || "Applicant"}, we received your application for ${ctx.business || "your business"}. We'll review and update you shortly.`;
server/services/notify.ts:57:      return `We are now reviewing your application. We'll update you shortly.`;
server/services/notify.ts:63:      return `Your application has been sent to lenders. Expect 2‚Äì4 days for responses.`;
server/services/notify.ts:70:  const tab = ctx.tab || "application";
server/services/notify.ts:71:  return `/pipeline?silo=${ctx.silo}&appId=${ctx.appId}&tab=${tab}`;
server/middleware/lender.ts:11:  const r = await db.execute(sql`SELECT id, application_id, partner_id, perms, expires_at, revoked_at, disabled FROM app_lender_shares WHERE token=${token} LIMIT 1`);
server/middleware/lender.ts:17:  req.lender = { shareId: share.id, applicationId: share.application_id, partnerId: share.partner_id, perms: share.perms, token };
server/middleware/lender.ts:27:      INSERT INTO lender_activity(share_id, partner_id, application_id, event, meta, ip, ua)
server/middleware/lender.ts:28:      VALUES (${req.lender?.shareId || null}, ${req.lender?.partnerId || null}, ${req.lender?.applicationId || null}, ${event}, ${JSON.stringify(meta)}, ${ip}, ${ua})
server/services/bulletproofUploadService.ts:49:  const mimeType = mime.lookup(originalName) || 'application/octet-stream';
server/services/bulletproofUploadService.ts:106:  applicationId: string;
server/services/bulletproofUploadService.ts:121:      applicationId: data.applicationId,
server/services/bulletproofUploadService.ts:200:    const objectKey = `${document.applicationId}/${documentId}${path.extname(document.fileName)}`;
server/services/bulletproofUploadService.ts:209:      ContentType: document.mimeType || 'application/octet-stream',
server/services/bulletproofUploadService.ts:213:        applicationId: document.applicationId,
server/services/bulletproofUploadService.ts:292:        mimeType: document.mimeType || 'application/octet-stream'
server/services/bulletproofUploadService.ts:315:              mimeType: document.mimeType || 'application/octet-stream'
server/services/bulletproofUploadService.ts:341:  applicationId: string,
server/services/bulletproofUploadService.ts:349:  console.log(`üöÄ [BULLETPROOF] Application: ${applicationId}`);
server/services/bulletproofUploadService.ts:358:      applicationId,
server/routes/slf-contacts.ts:164:      const r = await fetch(u, { method: "PATCH", headers: authHeaders({ "Content-Type": "application/json" }) as any, body: JSON.stringify(req.body) });
server/routes/slf-ext.ts:12:  headers: { Authorization: token, Accept: "application/json" },
server/services/cronJobs.ts:61:              applicationId: notification.applicationId,
server/services/cronJobs.ts:68:                title: 'View Application'
server/routes/slf-sync.ts:22:    const b = buckets.get(email) || { email, name: row?.applicant_name || companyName, company: companyName, phone: row?.phone, applications: [] };
server/routes/slf-sync.ts:26:    b.applications.push({
server/services/applicationService.ts:1:// services/applicationService.ts
server/services/applicationService.ts:4:import { ApplicationInput } from '../types/ApplicationInput';
server/services/applicationService.ts:6:console.log('üìã [APPLICATION-SERVICE] Service loading...');
server/services/applicationService.ts:8:export async function getFullApplicationData(applicationId: string): Promise<ApplicationInput> {
server/services/applicationService.ts:10:    console.log(`üìã [APPLICATION-SERVICE] Fetching full data for application: ${applicationId}`);
server/services/applicationService.ts:12:    // Get application with form data
server/services/applicationService.ts:19:      FROM applications 
server/services/applicationService.ts:20:      WHERE id = ${applicationId}
server/services/applicationService.ts:25:      throw new Error(`Application not found: ${applicationId}`);
server/services/applicationService.ts:28:    const application = appResult.rows[0] as any;
server/services/applicationService.ts:29:    const formData = application.form_data || {};
server/services/applicationService.ts:38:      WHERE application_id = ${applicationId}
server/services/applicationService.ts:48:      WHERE application_id = ${applicationId}
server/services/applicationService.ts:58:      WHERE application_id = ${applicationId} 
server/services/applicationService.ts:78:    const applicationInput: ApplicationInput = {
server/services/applicationService.ts:99:    console.log(`üìã [APPLICATION-SERVICE] Successfully compiled data for ${applicationId}:`, {
server/services/applicationService.ts:100:      category: applicationInput.product_category,
server/services/applicationService.ts:101:      amount: applicationInput.requested_amount,
server/services/applicationService.ts:102:      documents: applicationInput.documents.length,
server/services/applicationService.ts:103:      hasBanking: !!applicationInput.banking,
server/services/applicationService.ts:104:      hasOCR: !!applicationInput.ocr
server/services/applicationService.ts:107:    return applicationInput;
server/services/applicationService.ts:110:    console.error(`üìã [APPLICATION-SERVICE] Error fetching application data for ${applicationId}:`, error);
server/services/applicationService.ts:140:console.log('üìã [APPLICATION-SERVICE] Service ready');
server/routes/voice-real.ts:36:      outgoingApplicationSid: TWIML_APP_SID, 
server/routes/smsTestEndpoint.ts:9:import { applications } from '../../shared/schema';
server/routes/smsTestEndpoint.ts:23:        'in_review': 'Application moved to review stage',
server/routes/smsTestEndpoint.ts:24:        'sent_to_lender': 'Application sent to lender',
server/routes/smsTestEndpoint.ts:29:        'closed_lost': 'Loan application closed'
server/routes/smsTestEndpoint.ts:38:        'loan_approved': 'Loan application approved',
server/routes/smsTestEndpoint.ts:39:        'loan_rejected': 'Loan application rejected',
server/routes/smsTestEndpoint.ts:62: * POST /api/sms-test/:applicationId/:trigger
server/routes/smsTestEndpoint.ts:63: * Test specific SMS trigger for an application
server/routes/smsTestEndpoint.ts:65:router.post('/:applicationId/:trigger', async (req: any, res: any) => {
server/routes/smsTestEndpoint.ts:67:    const { applicationId, trigger } = req.params;
server/routes/smsTestEndpoint.ts:70:    console.log(`üß™ [SMS-TEST] Testing trigger "${trigger}" for application ${applicationId}`);
server/routes/smsTestEndpoint.ts:72:    // Verify application exists
server/routes/smsTestEndpoint.ts:73:    const [application] = await db.select().from(applications).where(eq(applications.id, applicationId));
server/routes/smsTestEndpoint.ts:74:    if (!application) {
server/routes/smsTestEndpoint.ts:75:      return res.status(404).json({ error: 'Application not found' });
server/routes/smsTestEndpoint.ts:81:      if (application.formData && typeof application.formData === 'object') {
server/routes/smsTestEndpoint.ts:82:        const formData = application.formData as any;
server/routes/smsTestEndpoint.ts:92:      applicationId,
server/routes/smsTestEndpoint.ts:106:          applicationId,
server/routes/smsTestEndpoint.ts:111:          businessName: application.legalBusinessName || application.businessName,
server/routes/smsTestEndpoint.ts:122:          applicationId,
server/routes/smsTestEndpoint.ts:139: * GET /api/sms-test/:applicationId/phone
server/routes/smsTestEndpoint.ts:140: * Get phone number from application for SMS testing
server/routes/smsTestEndpoint.ts:142:router.get('/:applicationId/phone', async (req: any, res: any) => {
server/routes/smsTestEndpoint.ts:144:    const { applicationId } = req.params;
server/routes/smsTestEndpoint.ts:146:    // Get application data
server/routes/smsTestEndpoint.ts:147:    const [application] = await db.select().from(applications).where(eq(applications.id, applicationId));
server/routes/smsTestEndpoint.ts:148:    if (!application) {
server/routes/smsTestEndpoint.ts:149:      return res.status(404).json({ error: 'Application not found' });
server/routes/smsTestEndpoint.ts:156:      if (application.formData && typeof application.formData === 'object') {
server/routes/smsTestEndpoint.ts:157:        const formData = application.formData as any;
server/routes/smsTestEndpoint.ts:180:      applicationId,
server/routes/smsTestEndpoint.ts:181:      businessName: application.legalBusinessName || application.businessName,
server/routes/smsTestEndpoint.ts:185:      formDataStructure: application.formData ? Object.keys(application.formData as any) : []
server/routes/smsTestEndpoint.ts:196: * Test SMS trigger for multiple applications
server/routes/smsTestEndpoint.ts:201:    const { applicationIds, customMessage } = req.body;
server/routes/smsTestEndpoint.ts:203:    if (!applicationIds || !Array.isArray(applicationIds)) {
server/routes/smsTestEndpoint.ts:204:      return res.status(400).json({ error: 'applicationIds array is required' });
server/routes/smsTestEndpoint.ts:207:    console.log(`üöÄ [SMS-BULK] Testing trigger "${trigger}" for ${applicationIds.length} applications`);
server/routes/smsTestEndpoint.ts:211:    for (const applicationId of applicationIds) {
server/routes/smsTestEndpoint.ts:215:          applicationId,
server/routes/smsTestEndpoint.ts:222:          applicationId,
server/routes/smsTestEndpoint.ts:234:          applicationId,
server/routes/smsTestEndpoint.ts:250:      totalApplications: applicationIds.length,
server/config/allowed-namespaces.json:3:    "/api/pipeline",
server/config/allowed-namespaces.json:21:    "/api/applications"
server/services/lenderRecommendation.ts:4:import { ApplicationInput } from '../types/ApplicationInput';
server/services/lenderRecommendation.ts:16:  applicant: ApplicationInput,
server/routes/dialer.ts:74:    apps: a?.applications ?? b?.applications ?? [],
server/services/autoSmsService.ts:2: * Automatic SMS Service for New Applications
server/services/autoSmsService.ts:4: * Ensures all new applications without documents receive immediate SMS notifications
server/services/autoSmsService.ts:8:import { applications, documents } from '@shared/schema';
server/services/autoSmsService.ts:14:   * Check and send SMS for new application if no documents
server/services/autoSmsService.ts:16:  static async checkAndSendSmsForNewApplication(applicationId: string): Promise<void> {
server/services/autoSmsService.ts:18:      console.log(`üì± [AUTO-SMS-SERVICE] Checking application ${applicationId} for SMS trigger`);
server/services/autoSmsService.ts:20:      // Get application details
server/services/autoSmsService.ts:23:        .from(applications)
server/services/autoSmsService.ts:24:        .where(eq(applications.id, applicationId))
server/services/autoSmsService.ts:28:        console.log(`‚ö†Ô∏è [AUTO-SMS-SERVICE] Application ${applicationId} not found`);
server/services/autoSmsService.ts:32:      const application = appResult[0];
server/services/autoSmsService.ts:33:      console.log(`üìã [AUTO-SMS-SERVICE] Application found: ${(application.formData as any)?.step3?.businessName || 'Unknown'}`);
server/services/autoSmsService.ts:35:      // Count documents for this application
server/services/autoSmsService.ts:39:        .where(eq(documents.applicationId, applicationId));
server/services/autoSmsService.ts:42:      console.log(`üìÑ [AUTO-SMS-SERVICE] Application ${applicationId} has ${docCount} documents`);
server/services/autoSmsService.ts:46:        console.log(`üì± [AUTO-SMS-SERVICE] Sending missing docs SMS for ${applicationId}`);
server/services/autoSmsService.ts:49:        const result = await sendEnhancedSMS(applicationId, 'submission_no_docs');
server/services/autoSmsService.ts:57:        console.log(`‚è≠Ô∏è [AUTO-SMS-SERVICE] Application has ${docCount} documents, no SMS needed`);
server/services/autoSmsService.ts:61:      console.error(`‚ùå [AUTO-SMS-SERVICE] Error processing ${applicationId}:`, error);
server/services/autoSmsService.ts:66:   * Trigger automatic pipeline evaluation for applications with stage/document mismatches
server/services/autoSmsService.ts:68:  static async triggerPipelineEvaluationForStageMismatch(applicationId: string): Promise<void> {
server/services/autoSmsService.ts:70:      console.log(`üîß [AUTO-SMS-SERVICE] Triggering pipeline evaluation for ${applicationId}`);
server/services/autoSmsService.ts:72:      // Use pipeline service to evaluate and update stage
server/services/autoSmsService.ts:73:      const { PipelineService } = await import('./pipelineService.js');
server/services/autoSmsService.ts:74:      const result = await PipelineService.evaluateAndUpdateStage(applicationId);
server/services/autoSmsService.ts:77:        console.log(`‚úÖ [AUTO-SMS-SERVICE] Pipeline updated: ${result.evaluation.currentStage} ‚Üí ${result.evaluation.suggestedStage}`);
server/services/autoSmsService.ts:79:        console.log(`‚è≠Ô∏è [AUTO-SMS-SERVICE] No pipeline update needed for ${applicationId}`);
server/services/autoSmsService.ts:83:      console.error(`‚ùå [AUTO-SMS-SERVICE] Pipeline evaluation error for ${applicationId}:`, error);
server/services/autoSmsService.ts:88:   * Comprehensive check for new applications - triggers both SMS and pipeline evaluation
server/services/autoSmsService.ts:90:  static async processNewApplication(applicationId: string): Promise<void> {
server/services/autoSmsService.ts:92:      console.log(`üöÄ [AUTO-SMS-SERVICE] Processing new application: ${applicationId}`);
server/services/autoSmsService.ts:98:      await this.checkAndSendSmsForNewApplication(applicationId);
server/services/autoSmsService.ts:100:      // Trigger pipeline evaluation
server/services/autoSmsService.ts:101:      await this.triggerPipelineEvaluationForStageMismatch(applicationId);
server/services/autoSmsService.ts:103:      console.log(`‚úÖ [AUTO-SMS-SERVICE] New application processing completed: ${applicationId}`);
server/services/autoSmsService.ts:106:      console.error(`‚ùå [AUTO-SMS-SERVICE] Error processing new application ${applicationId}:`, error);
server/routes/contacts.diag.ts:15:    // Get all applications with contact emails
server/routes/contacts.diag.ts:20:      FROM applications a 
server/routes/contacts.diag.ts:44:        source: 'applications',
server/routes/loanDecisions.ts:9:import { applications } from '../../shared/schema';
server/routes/loanDecisions.ts:16: * POST /api/loan-decisions/:applicationId/approve
server/routes/loanDecisions.ts:19:router.post('/:applicationId/approve', async (req: any, res: any) => {
server/routes/loanDecisions.ts:21:    const { applicationId } = req.params;
server/routes/loanDecisions.ts:24:    console.log(`üí∞ [LOAN-APPROVAL] Processing approval SMS for application ${applicationId}`);
server/routes/loanDecisions.ts:26:    // Verify application exists
server/routes/loanDecisions.ts:27:    const [application] = await db.select().from(applications).where(eq(applications.id, applicationId));
server/routes/loanDecisions.ts:28:    if (!application) {
server/routes/loanDecisions.ts:29:      return res.status(404).json({ error: 'Application not found' });
server/routes/loanDecisions.ts:34:      applicationId,
server/routes/loanDecisions.ts:45:      console.log(`‚úÖ [LOAN-APPROVAL] SMS notification sent successfully for application ${applicationId}`);
server/routes/loanDecisions.ts:47:      // Optionally update application status
server/routes/loanDecisions.ts:48:      await db.update(applications)
server/routes/loanDecisions.ts:53:        .where(eq(applications.id, applicationId));
server/routes/loanDecisions.ts:76: * POST /api/loan-decisions/:applicationId/reject
server/routes/loanDecisions.ts:79:router.post('/:applicationId/reject', async (req: any, res: any) => {
server/routes/loanDecisions.ts:81:    const { applicationId } = req.params;
server/routes/loanDecisions.ts:84:    console.log(`‚ùå [LOAN-REJECTION] Processing rejection SMS for application ${applicationId}`);
server/routes/loanDecisions.ts:86:    // Verify application exists
server/routes/loanDecisions.ts:87:    const [application] = await db.select().from(applications).where(eq(applications.id, applicationId));
server/routes/loanDecisions.ts:88:    if (!application) {
server/routes/loanDecisions.ts:89:      return res.status(404).json({ error: 'Application not found' });
server/routes/loanDecisions.ts:94:      applicationId,
server/routes/loanDecisions.ts:103:      console.log(`‚úÖ [LOAN-REJECTION] SMS notification sent successfully for application ${applicationId}`);
server/routes/loanDecisions.ts:105:      // Optionally update application status
server/routes/loanDecisions.ts:106:      await db.update(applications)
server/routes/loanDecisions.ts:111:        .where(eq(applications.id, applicationId));
server/routes/loanDecisions.ts:134: * POST /api/loan-decisions/:applicationId/funded
server/routes/loanDecisions.ts:137:router.post('/:applicationId/funded', async (req: any, res: any) => {
server/routes/loanDecisions.ts:139:    const { applicationId } = req.params;
server/routes/loanDecisions.ts:142:    console.log(`üí∏ [LOAN-FUNDING] Processing funding SMS for application ${applicationId}`);
server/routes/loanDecisions.ts:144:    // Verify application exists
server/routes/loanDecisions.ts:145:    const [application] = await db.select().from(applications).where(eq(applications.id, applicationId));
server/routes/loanDecisions.ts:146:    if (!application) {
server/routes/loanDecisions.ts:147:      return res.status(404).json({ error: 'Application not found' });
server/routes/loanDecisions.ts:152:      applicationId,
server/routes/loanDecisions.ts:163:      console.log(`‚úÖ [LOAN-FUNDING] SMS notification sent successfully for application ${applicationId}`);
server/routes/loanDecisions.ts:165:      // Update application status to funded
server/routes/loanDecisions.ts:166:      await db.update(applications)
server/routes/loanDecisions.ts:171:        .where(eq(applications.id, applicationId));
server/routes/loanDecisions.ts:194: * POST /api/loan-decisions/:applicationId/custom
server/routes/loanDecisions.ts:197:router.post('/:applicationId/custom', async (req: any, res: any) => {
server/routes/loanDecisions.ts:199:    const { applicationId } = req.params;
server/routes/loanDecisions.ts:206:    console.log(`üì± [CUSTOM-SMS] Sending custom message for application ${applicationId}`);
server/routes/loanDecisions.ts:208:    // Verify application exists
server/routes/loanDecisions.ts:209:    const [application] = await db.select().from(applications).where(eq(applications.id, applicationId));
server/routes/loanDecisions.ts:210:    if (!application) {
server/routes/loanDecisions.ts:211:      return res.status(404).json({ error: 'Application not found' });
server/routes/loanDecisions.ts:216:      applicationId,
server/routes/loanDecisions.ts:222:      console.log(`‚úÖ [CUSTOM-SMS] Custom message sent successfully for application ${applicationId}`);
server/services/ocrInsightsService.ts:2:import { documents, applications } from '../../shared/schema';
server/services/ocrInsightsService.ts:56: * Process all documents for an application and extract structured OCR insights
server/services/ocrInsightsService.ts:58:export async function processOCRInsights(applicationId: string): Promise<OCRInsightsResult> {
server/services/ocrInsightsService.ts:59:  console.log(`üîç [OCR-INSIGHTS] Starting comprehensive OCR processing for application ${applicationId}`);
server/services/ocrInsightsService.ts:62:    // Get all documents for the application
server/services/ocrInsightsService.ts:66:      .where(eq(documents.applicationId, applicationId));
server/services/ocrInsightsService.ts:69:      throw new Error(`No documents found for application ${applicationId}`);
server/services/ocrInsightsService.ts:196:    console.log(`‚úÖ [OCR-INSIGHTS] Processing completed for application ${applicationId}`);
server/services/ocrInsightsService.ts:209:    console.error(`‚ùå [OCR-INSIGHTS] Failed to process application ${applicationId}:`, error);
server/services/ocrInsightsService.ts:293: * Run comprehensive OCR processing on all applications
server/services/ocrInsightsService.ts:296:  processedApplications: number;
server/services/ocrInsightsService.ts:301:  console.log(`üöÄ [COMPREHENSIVE-OCR] Starting comprehensive OCR analysis on all applications`);
server/services/ocrInsightsService.ts:304:    // Get all applications
server/services/ocrInsightsService.ts:305:    const allApplications = await db.select().from(applications);
server/services/ocrInsightsService.ts:307:    let processedApplications = 0;
server/services/ocrInsightsService.ts:312:    for (const app of allApplications) {
server/services/ocrInsightsService.ts:314:        console.log(`üîç [COMPREHENSIVE-OCR] Processing application ${app.id}`);
server/services/ocrInsightsService.ts:316:        // Get documents for this application
server/services/ocrInsightsService.ts:320:          .where(eq(documents.applicationId, app.id));
server/services/ocrInsightsService.ts:325:          console.log(`‚ö†Ô∏è [COMPREHENSIVE-OCR] No documents found for application ${app.id}`);
server/services/ocrInsightsService.ts:355:        processedApplications++;
server/services/ocrInsightsService.ts:358:        const errorMsg = `Failed to process application ${app.id}: ${appError.message}`;
server/services/ocrInsightsService.ts:365:      processedApplications,
server/services/ocrInsightsService.ts:372:      processedApplications,
server/config/s3ProductionConfig.ts:4: * Enables full S3 integration for staff application
server/config/s3ProductionConfig.ts:16:  generateStorageKey: (applicationId: string, fileName: string): string => {
server/config/s3ProductionConfig.ts:17:    return `${applicationId}/${fileName}`;
server/config/s3ProductionConfig.ts:26:    'application/pdf',
server/config/s3ProductionConfig.ts:27:    'application/msword',
server/config/s3ProductionConfig.ts:28:    'application/vnd.openxmlformats-officedocument.wordprocessingml.document',
server/config/s3ProductionConfig.ts:29:    'application/vnd.ms-excel',
server/config/s3ProductionConfig.ts:30:    'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet',
server/routes/diag.apps.ts:2:import { normalizeApp } from '../services/applications.adapter';
server/routes/diag.apps.ts:10:async function getApplications() {
server/routes/diag.apps.ts:16:    FROM applications a 
server/routes/diag.apps.ts:39:    const raw = await getApplications();
server/services/s3OcrService.ts:15:import { documents, applications } from "../../shared/schema";
server/services/s3OcrService.ts:85:          id, document_id, application_id, extracted_data, confidence, 
server/services/s3OcrService.ts:94:        document.applicationId,
server/services/s3OcrService.ts:529:      applicationId: document.applicationId,
server/services/s3OcrService.ts:571: * Process all documents for an application
server/services/s3OcrService.ts:573:export async function processApplicationDocuments(applicationId: string): Promise<void> {
server/services/s3OcrService.ts:575:    console.log(`üìã [BATCH-OCR] Processing all documents for application ${applicationId}`);
server/services/s3OcrService.ts:577:    // Get all documents for application
server/services/s3OcrService.ts:581:      .where(eq(documents.applicationId, applicationId));
server/services/s3OcrService.ts:599:    console.log(`‚úÖ [BATCH-OCR] Completed processing for application ${applicationId}`);
server/services/s3OcrService.ts:602:    console.error(`‚ùå [BATCH-OCR] Failed to process application documents:`, error);
server/config/s3Config.ts:33: * @param applicationId - Application ID for organization (optional)
server/config/s3Config.ts:40:  applicationId?: string
server/config/s3Config.ts:45:  const storageKey = applicationId 
server/config/s3Config.ts:46:    ? `${applicationId}/${fileName}`
server/config/s3Config.ts:73:      applicationId: applicationId || 'unknown'
server/services/smsNotificationService.ts:3: * Handles trigger-based SMS notifications for pipeline stage transitions
server/services/smsNotificationService.ts:10:  applicationId: string;
server/services/smsNotificationService.ts:11:  trigger: 'new_application' | 'in_review' | 'document_rejected' | 'all_documents_accepted' | 'sent_to_lender';
server/services/smsNotificationService.ts:19:  applicationId: string;
server/services/smsNotificationService.ts:33:    console.log(`üì± [SMS-NOTIFICATION] Processing trigger: ${data.trigger} for application: ${data.applicationId}`);
server/services/smsNotificationService.ts:35:    // Get application data and phone number
server/services/smsNotificationService.ts:36:    const applicationResult = await db.execute(sql`
server/services/smsNotificationService.ts:38:      FROM applications 
server/services/smsNotificationService.ts:39:      WHERE id = ${data.applicationId}
server/services/smsNotificationService.ts:43:    if (!applicationResult.rows.length) {
server/services/smsNotificationService.ts:44:      console.error(`‚ùå [SMS-NOTIFICATION] Application not found: ${data.applicationId}`);
server/services/smsNotificationService.ts:45:      return { success: false, error: 'Application not found' };
server/services/smsNotificationService.ts:48:    const application = applicationResult.rows[0] as any;
server/services/smsNotificationService.ts:49:    const formData = application.form_data;
server/services/smsNotificationService.ts:54:      console.log(`‚ö†Ô∏è [SMS-NOTIFICATION] No phone number found for application: ${data.applicationId}`);
server/services/smsNotificationService.ts:65:      WHERE application_id = ${data.applicationId} 
server/services/smsNotificationService.ts:72:      console.log(`‚ö†Ô∏è [SMS-NOTIFICATION] SMS already sent for trigger ${data.trigger} on application ${data.applicationId}`);
server/services/smsNotificationService.ts:96:      applicationId: data.applicationId,
server/services/smsNotificationService.ts:126:    case 'new_application':
server/services/smsNotificationService.ts:127:      return `${firstName}, we have received your application for funding for ${businessLegalName}. We will review it shortly and update you with the next steps.`;
server/services/smsNotificationService.ts:130:      return `We are now reviewing your application and will update you shortly.`;
server/services/smsNotificationService.ts:143:      return `We are happy to announce your application has been finalized and is now in the hands of the lenders who are the best match for your application and requirements. This will generally take 2‚Äì4 days before we hear a response. Please be patient and we will be reaching out soon.`;
server/services/smsNotificationService.ts:146:      return `Congratulations ${firstName}! Your loan application for ${businessLegalName} has been approved. We will contact you shortly with the next steps and funding details.`;
server/services/smsNotificationService.ts:149:      return `Dear ${firstName}, unfortunately we cannot approve your loan application for ${businessLegalName} at this time. You may be eligible to reapply in the future. Please contact us if you have questions.`;
server/services/smsNotificationService.ts:214:        application_id,
server/services/smsNotificationService.ts:228:        ${logEntry.applicationId},
server/services/smsNotificationService.ts:238:    console.log(`üìã [SMS-NOTIFICATION] SMS logged to database for application: ${logEntry.applicationId}`);
server/services/smsNotificationService.ts:248:export async function checkAllDocumentsAccepted(applicationId: string): Promise<boolean> {
server/services/smsNotificationService.ts:255:      WHERE application_id = ${applicationId} 
server/services/smsNotificationService.ts:263:    console.log(`üìã [SMS-NOTIFICATION] Document status for ${applicationId}: ${acceptedCount}/${totalRequired} accepted`);
server/services/smsNotificationService.ts:275:export async function checkAnalysisCompleted(applicationId: string): Promise<boolean> {
server/services/smsNotificationService.ts:281:      WHERE application_id = ${applicationId}
server/services/smsNotificationService.ts:288:      WHERE application_id = ${applicationId}
server/services/smsNotificationService.ts:294:    console.log(`üìã [SMS-NOTIFICATION] Analysis status for ${applicationId}: OCR=${ocrCount}, Banking=${bankingCount}`);
server/routes/diag.dupes.ts:11:    // Fetch applications data (same query as applications route)
server/routes/diag.dupes.ts:17:      FROM applications a 
server/config/s3Environment.ts:4: * Centralized S3 configuration management for Staff Application
server/services/documentRequirementsService.ts:131:    applicationId: string,
server/services/documentRequirementsService.ts:134:    applicationId: string;
server/services/documentRequirementsService.ts:149:          applicationId,
server/services/documentRequirementsService.ts:157:        applicationId: string;
server/services/documentRequirementsService.ts:166:   * Get default document requirements for generic applications
server/routes/pipeline-docs.ts:6:const timelineStore = new Map<string, TEvent[]>(); // cardId -> events
server/routes/pipeline-docs.ts:8:function pushEvent(cardId:string, e:TEvent){
server/routes/pipeline-docs.ts:9:  const arr = timelineStore.get(cardId) || [];
server/routes/pipeline-docs.ts:11:  timelineStore.set(cardId, arr.slice(0, 500)); // cap
server/routes/pipeline-docs.ts:18:export function pipelineDocsRoutes() {
server/routes/pipeline-docs.ts:20:  r.get("/api/pipeline/cards/:id/docs", (_req,res)=> {
server/routes/pipeline-docs.ts:26:  r.post("/api/pipeline/cards/:id/docs/:docId/approve", (_req,res)=> res.json({ok:true}));
server/routes/pipeline-docs.ts:27:  r.post("/api/pipeline/cards/:id/docs/:docId/reject",  (_req,res)=> res.json({ok:true}));
server/routes/pipeline-docs.ts:28:  r.post("/api/pipeline/cards/:id/docs/:docId/delete",  (_req,res)=> res.json({ok:true}));
server/routes/pipeline-docs.ts:29:  r.post("/api/pipeline/cards/:id/docs/:docId/replace", upload.single('file'), (req,res)=> {
server/routes/pipeline-docs.ts:37:  r.post("/api/pipeline/cards/:id/timeline", (req, res) => {
server/routes/pipeline-docs.ts:44:  r.get("/api/pipeline/cards/:id/timeline", (req, res) => {
server/routes/pipeline-docs.ts:50:  r.get("/api/pipeline/config", (_req, res) => res.json({ ok:true, wip: WIP }));
server/routes/pipeline-docs.ts:52:  // Card details endpoint
server/routes/pipeline-docs.ts:53:  r.get("/api/pipeline/cards/:id", (req, res) => {
server/routes/pipeline-docs.ts:55:    const cards = (global as any).cards || [];
server/routes/pipeline-docs.ts:56:    const card = cards.find((c:any) => c.id === id);
server/routes/pipeline-docs.ts:57:    if (card) {
server/routes/pipeline-docs.ts:58:      res.json({ ok:true, item: card });
server/routes/pipeline-docs.ts:65:  r.post("/api/pipeline/_seed/:id", (req, res) => {
server/routes/pipeline-timeline.ts:12:const store: Record<string, Event[]> = (global as any).PIPELINE_TL ??= {};
server/routes/pipeline-timeline.ts:14:export function mountPipelineTimeline(app: Express) {
server/routes/pipeline-timeline.ts:15:  // get timeline for card
server/routes/pipeline-timeline.ts:16:  app.get("/api/pipeline/cards/:id/timeline", (req: Request, res: Response) => {
server/routes/pipeline-timeline.ts:22:  app.post("/api/pipeline/cards/:id/timeline", (req: Request, res: Response) => {
server/routes/pipeline-timeline.ts:38:  app.get("/api/pipeline/metrics", (_req: Request, res: Response) => {
server/routes/pipeline-timeline.ts:40:      const cards: any[] = (global as any).cards ?? [];
server/routes/pipeline-timeline.ts:41:      const count = cards.length;
server/routes/pipeline-timeline.ts:42:      const value = cards.reduce((s, c) => s + (Number(c.amount) || 0), 0);
server/routes/pipeline-timeline.ts:43:      const accepted = cards.filter(c => c.status === "accepted").length;
server/routes/pipeline-timeline.ts:46:      res.json({ ok: true, items: { applications: count, pipelineValue: value, conversion30d, avgCycleDays: null } });
server/routes/pipeline-timeline.ts:48:      res.json({ ok: true, items: { applications: 0, pipelineValue: 0, conversion30d: 0, avgCycleDays: null } });
server/utils/openai.ts:21:You are a senior credit analyst writing a comprehensive credit summary. Analyze the following application data and create a professional credit write-up:
server/utils/openai.ts:58:As a senior credit risk analyst, assess the risk level for this loan application. Consider all available data:
server/utils/openai.ts:86:You are an experienced loan processor reviewing this application. Based on the current status and available information, suggest the most logical next step:
server/utils/openai.ts:88:APPLICATION STATUS: ${data.status || 'New'}
server/utils/openai.ts:147:Create a comprehensive summary of all uploaded documents for this loan application:
server/routes/documentManagement.ts:12:import { documents, applications } from '../../shared/schema';
server/routes/documentManagement.ts:14:import { PipelineAutomationService } from '../services/pipelineAutomation';
server/routes/documentManagement.ts:32:import { generateBusinessPdf, getApplicationDataForPdf } from '../utils/generateBusinessPdf.js';
server/routes/documentManagement.ts:62:      'application/pdf',
server/routes/documentManagement.ts:63:      'application/x-pdf',
server/routes/documentManagement.ts:64:      'application/octet-stream', // fallback for PDFs in Replit
server/routes/documentManagement.ts:69:      'application/vnd.openxmlformats-officedocument.wordprocessingml.document', // DOCX
server/routes/documentManagement.ts:70:      'application/msword', // DOC
server/routes/documentManagement.ts:114:// POST /api/documents/staff-upload/:applicationId - S3-FIRST Staff Upload
server/routes/documentManagement.ts:115:router.post('/staff-upload/:applicationId', async (req: any, res: any) => upload.single('file'), async (req: RBACRequest, res) => {
server/routes/documentManagement.ts:117:    const { applicationId } = req.params;
server/routes/documentManagement.ts:121:    console.log(`üöÄ [S3 STAFF UPLOAD] Starting S3-first upload for application: ${applicationId}`);
server/routes/documentManagement.ts:130:    const storageKey = `${applicationId}/${file.originalname}`;
server/routes/documentManagement.ts:161:        id, application_id, file_name, file_path, file_type, file_size, 
server/routes/documentManagement.ts:170:      applicationId,
server/routes/documentManagement.ts:199:        const response = await fetch(`http://localhost:5000/api/ocr/application/${applicationId}`, {
server/routes/documentManagement.ts:202:            'Content-Type': 'application/json',
server/routes/documentManagement.ts:208:          console.log(`‚úÖ [AUTO-OCR] OCR triggered successfully for staff upload application ${applicationId}`);
server/routes/documentManagement.ts:213:        console.error(`‚ùå [AUTO-OCR] Failed to auto-trigger OCR for staff upload ${applicationId}:`, err.message);
server/routes/documentManagement.ts:478:    const mimeType = mime.lookup(filePath) || 'application/octet-stream';
server/routes/documentManagement.ts:591:            res.setHeader('Content-Type', document.file_type || 'application/octet-stream');
server/routes/documentManagement.ts:650:    const mimeType = mime.lookup(filePath) || 'application/octet-stream';
server/routes/documentManagement.ts:797:    // Get application ID for this document
server/routes/documentManagement.ts:798:    const appQuery = 'SELECT application_id FROM documents WHERE id = $1';
server/routes/documentManagement.ts:802:      const applicationId = appResult.rows[0].application_id;
server/routes/documentManagement.ts:807:          applicationId,
server/routes/documentManagement.ts:812:          console.log(`üì± [DOCUMENT-SMS] Document acceptance notification sent for application ${applicationId}`);
server/routes/documentManagement.ts:824:        const [application] = await db.select().from(applications).where(eq(applications.id, applicationId));
server/routes/documentManagement.ts:825:        if (application && application.legalBusinessName?.toLowerCase().includes('test')) {
server/routes/documentManagement.ts:826:          console.log(`üö´ [AUTO] Skipping lender table check for test application: ${application.legalBusinessName}`);
server/routes/documentManagement.ts:829:          const allDocsQuery = 'SELECT COUNT(*) as total, COUNT(CASE WHEN is_verified = true THEN 1 END) as verified FROM documents WHERE application_id = $1';
server/routes/documentManagement.ts:830:          const allDocsResult = await pool.query(allDocsQuery, [applicationId]);
server/routes/documentManagement.ts:837:              await db.update(applications)
server/routes/documentManagement.ts:839:                .where(eq(applications.id, applicationId));
server/routes/documentManagement.ts:841:              console.log(`ü§ñ [AUTO] Lender UI unlocked for application ${applicationId}`);
server/routes/documentManagement.ts:846:                const recommendations = await lenderScoringService.recommendLenders(applicationId, 10);
server/routes/documentManagement.ts:847:                console.log(`üèÜ [AUTO] Generated ${recommendations.length} lender recommendations for application ${applicationId}`);
server/routes/documentManagement.ts:850:                console.warn(`‚ö†Ô∏è [AUTO] Lender scoring failed for application ${applicationId}:`, scoringError);
server/routes/documentManagement.ts:853:              console.log(`üìä [AUTO] Document check: ${verified}/${total} documents accepted for app ${applicationId}`);
server/routes/documentManagement.ts:858:        console.warn(`‚ö†Ô∏è [AUTO] Lender table check failed for application ${applicationId}:`, lenderError);
server/routes/documentManagement.ts:869:          console.log(`ü§ñ [AUTO-TRIGGER] Document type: ${documentType} for application ${applicationId}`);
server/routes/documentManagement.ts:873:            console.log(`üè¶ [AUTO-TRIGGER] Starting banking analysis for application ${applicationId}`);
server/routes/documentManagement.ts:875:              const response = await fetch(`http://localhost:5000/api/banking-analysis/${applicationId}`, {
server/routes/documentManagement.ts:877:                headers: { 'Content-Type': 'application/json' },
server/routes/documentManagement.ts:889:            console.log(`üìä [AUTO-TRIGGER] Starting OCR analysis for application ${applicationId}`);
server/routes/documentManagement.ts:891:              const response = await fetch(`http://localhost:5000/api/ocr/${applicationId}`, {
server/routes/documentManagement.ts:893:                headers: { 'Content-Type': 'application/json' },
server/routes/documentManagement.ts:906:      // Trigger automated pipeline check
server/routes/documentManagement.ts:907:      const automationResult = await PipelineAutomationService.checkDocumentCompletionStatus(applicationId);
server/routes/documentManagement.ts:908:      console.log(`üîÑ Automation result for ${applicationId}:`, automationResult);
server/routes/documentManagement.ts:934:    // Check if document exists and get application info
server/routes/documentManagement.ts:936:      SELECT d.id, d.application_id, a.legal_business_name as businessname, a.contact_email as email, a.contact_phone as phone 
server/routes/documentManagement.ts:938:      JOIN applications a ON d.application_id = a.id 
server/routes/documentManagement.ts:947:    const applicationId = row.application_id;
server/routes/documentManagement.ts:976:        applicationId,
server/routes/documentManagement.ts:982:        console.log(`üì± [DOCUMENT-SMS] Document rejection notification sent for application ${applicationId}`);
server/routes/documentManagement.ts:1004:// GET /api/documents/applications/:appId/zip - Download all documents as ZIP
server/routes/documentManagement.ts:1005:router.get('/applications/:appId/zip', async (req: any, res: any) => {
server/routes/documentManagement.ts:1010:      return res.status(400).json({ error: 'Invalid application ID' });
server/routes/documentManagement.ts:1013:    // Get all documents for this application
server/routes/documentManagement.ts:1014:    const docsQuery = 'SELECT id, file_name, file_path, file_type FROM documents WHERE application_id = $1';
server/routes/documentManagement.ts:1018:      return res.status(404).json({ error: 'No documents found for this application' });
server/routes/documentManagement.ts:1024:    res.setHeader('Content-Type', 'application/zip');
server/routes/documentManagement.ts:1027:    console.log(`üì¶ Creating ZIP with ${documents.length} documents for application ${appId} by ${req.user?.email}`);
server/routes/documentManagement.ts:1065:// POST /api/lender/send - Send application to lender (document validation removed)
server/routes/documentManagement.ts:1068:    const { applicationId, lenderId, message } = req.body;
server/routes/documentManagement.ts:1070:    if (!applicationId || !lenderId) {
server/routes/documentManagement.ts:1071:      return res.status(400).json({ error: 'Application ID and Lender ID are required' });
server/routes/documentManagement.ts:1074:    const [application] = await db
server/routes/documentManagement.ts:1076:      .from(applications)
server/routes/documentManagement.ts:1077:      .where(eq(applications.id, applicationId))
server/routes/documentManagement.ts:1080:    if (!application) {
server/routes/documentManagement.ts:1081:      return res.status(404).json({ error: 'Application not found' });
server/routes/documentManagement.ts:1084:    // Check if application has documents (for logging only, not blocking)
server/routes/documentManagement.ts:1085:    const appDocuments = await db.select().from(documents).where(eq(documents.applicationId, applicationId));
server/routes/documentManagement.ts:1087:      console.warn(`‚ö†Ô∏è [LENDER SEND] Application ${applicationId} sent to lender without documents`);
server/routes/documentManagement.ts:1089:      console.log(`üìÑ [LENDER SEND] Application ${applicationId} sent to lender with ${appDocuments.length} documents`);
server/routes/documentManagement.ts:1092:    // Update application status to sent to lender
server/routes/documentManagement.ts:1094:      .update(applications)
server/routes/documentManagement.ts:1101:      .where(eq(applications.id, applicationId));
server/routes/documentManagement.ts:1103:    console.log(`üì§ Application ${applicationId} sent to lender ${lenderId} by ${req.user?.email}`);
server/routes/documentManagement.ts:1107:      message: 'Application sent to lender successfully',
server/routes/documentManagement.ts:1108:      applicationId: applicationId,
server/routes/documentManagement.ts:1112:    console.error('Error sending application to lender:', error);
server/routes/documentManagement.ts:1113:    res.status(500).json({ error: 'Failed to send application to lender' });
server/routes/documentManagement.ts:1143:// GET /api/documents/audit/application/:id - Audit documents for specific application
server/routes/documentManagement.ts:1144:router.get('/audit/application/:id', async (req: any, res: any) => {
server/routes/documentManagement.ts:1148:    console.log(`üîç Application document audit requested for ${id} by ${req.user?.email}`);
server/routes/documentManagement.ts:1155:      applicationId: id,
server/routes/documentManagement.ts:1167:    console.error('Error auditing application documents:', error);
server/routes/documentManagement.ts:1168:    res.status(500).json({ error: 'Failed to audit application documents' });
server/routes/documentManagement.ts:1173:router.get('/:applicationId/download-all', async (req: Request, res) => {
server/routes/documentManagement.ts:1174:  const { applicationId } = req.params;
server/routes/documentManagement.ts:1177:  console.log(`üì¶ [ZIP-DOWNLOAD] Starting ZIP download for application: ${applicationId}`);
server/routes/documentManagement.ts:1180:    // Get all accepted documents for the application
server/routes/documentManagement.ts:1181:    console.log(`üì¶ [ZIP-DOWNLOAD] Querying documents for application: ${applicationId}`);
server/routes/documentManagement.ts:1188:        application_id, 
server/routes/documentManagement.ts:1192:      WHERE application_id = $1
server/routes/documentManagement.ts:1199:    const docsResult = await pool.query(docsQuery, [applicationId]);
server/routes/documentManagement.ts:1211:      console.log(`‚ö†Ô∏è [ZIP-DOWNLOAD] No accepted documents found for application: ${applicationId}`);
server/routes/documentManagement.ts:1213:        error: 'No accepted documents found for this application',
server/routes/documentManagement.ts:1214:        applicationId: applicationId,
server/routes/documentManagement.ts:1219:    // Get application business name for ZIP filename
server/routes/documentManagement.ts:1220:    const appQuery = 'SELECT form_data FROM applications WHERE id = $1 LIMIT 1';
server/routes/documentManagement.ts:1221:    const appResult = await pool.query(appQuery, [applicationId]);
server/routes/documentManagement.ts:1223:    let businessName = `Application_${applicationId.substring(0, 8)}`;
server/routes/documentManagement.ts:1241:    res.setHeader('Content-Type', 'application/zip');
server/routes/documentManagement.ts:1299:    console.log(`üìä [AUDIT] ZIP download: ${applicationId} by ${userId} - ${successCount} files, ${errorCount} errors`);
server/routes/documentManagement.ts:1306:          applicationId: applicationId 
server/routes/pipeline-safe.ts:2:export function pipelineSafe() {
server/routes/pipeline-safe.ts:5:  // PATCH card (status change / lightweight updates)
server/routes/pipeline-safe.ts:6:  r.patch("/api/pipeline/cards/:id", (req, res) => {
server/routes/contactsCommunications.ts:27:        subject: 'Your Application Status',
server/routes/contactsCommunications.ts:28:        content: 'Thank you for your loan application...',
server/routes/pipeline.docs.ts:1:// server/routes/pipeline.docs.ts
server/routes/pipeline.docs.ts:12:  const result = { ok:true, cardId:id, docId, action, at:Date.now() };
server/utils/route-deduper.ts:1:import type { Application } from "express";
server/utils/route-deduper.ts:36:  const appProto = (express() as Application);
server/routes/contacts.adapter.ts:7:    // Forward to applications endpoint with same auth
server/routes/contacts.adapter.ts:8:    const appResponse = await fetch(`http://localhost:5000/api/applications`, {
server/routes/contacts.adapter.ts:11:        'Content-Type': 'application/json'
server/services/releases/jobs.ts:9:  "recompute-pipeline-counters": async (_a)=>{
server/utils/uploadRetryQueue.ts:20:  applicationId: string,
server/utils/uploadRetryQueue.ts:37:      application_id: applicationId,
server/utils/uploadRetryQueue.ts:130:          applicationId: item.application_id,
server/routes/contacts.fallback.ts:4:// Derive "contacts" from applications until real contacts table exists.
server/routes/contacts.fallback.ts:7:    // Use existing applications API endpoint logic
server/routes/contacts.fallback.ts:8:    const response = await fetch(`${req.protocol}://${req.get('host')}/api/applications`, {
server/routes/contacts.fallback.ts:13:      return res.json({ ok: true, items: [], count: 0, note: 'applications fallback failed' });
server/services/billing/core.ts:15:      headers: { 'Content-Type': 'application/json' },
server/utils/simplifiedUploadHandler.ts:15:  applicationId: string;
server/utils/simplifiedUploadHandler.ts:30:  const { file, applicationId, documentType, uploadedBy } = options;
server/utils/simplifiedUploadHandler.ts:93:        id, application_id, file_name, file_path, file_size, 
server/utils/simplifiedUploadHandler.ts:102:      applicationId,
server/utils/simplifiedUploadHandler.ts:114:    await logUploadValidation(documentId, fileName, validation, applicationId);
server/utils/safeFileWriter.ts:78:export function enqueueRecoveryAlert(applicationId: string, fileName: string) {
server/utils/safeFileWriter.ts:80:    applicationId,
server/utils/pdfGenerator.ts:2: * PDF Generator for Signed Applications
server/utils/pdfGenerator.ts:3: * Generates PDF documents for completed loan applications
server/utils/pdfGenerator.ts:8:import { applications, businesses, documents } from '../../shared/schema.js';
server/utils/pdfGenerator.ts:11:interface ApplicationData {
server/utils/pdfGenerator.ts:26:export async function generateSignedApplicationPDF(applicationId: string): Promise<string> {
server/utils/pdfGenerator.ts:28:    console.log(`üîß [PDF GENERATOR] Starting PDF generation for application: ${applicationId}`);
server/utils/pdfGenerator.ts:30:    // Fetch application data
server/utils/pdfGenerator.ts:31:    const applicationResults = await db
server/utils/pdfGenerator.ts:33:        id: applications.id,
server/utils/pdfGenerator.ts:35:        requested_amount: applications.requested_amount,
server/utils/pdfGenerator.ts:36:        use_of_funds: applications.use_of_funds,
server/utils/pdfGenerator.ts:37:        status: applications.status,
server/utils/pdfGenerator.ts:38:        created_at: applications.created_at
server/utils/pdfGenerator.ts:40:      .from(applications)
server/utils/pdfGenerator.ts:41:      .leftJoin(businesses, eq(applications.business_id, businesses.id))
server/utils/pdfGenerator.ts:42:      .where(eq(applications.id, applicationId));
server/utils/pdfGenerator.ts:44:    if (applicationResults.length === 0) {
server/utils/pdfGenerator.ts:45:      throw new Error(`Application ${applicationId} not found`);
server/utils/pdfGenerator.ts:48:    const application = applicationResults[0];
server/utils/pdfGenerator.ts:51:    const applicationDocuments = await db
server/utils/pdfGenerator.ts:59:      .where(eq(documents.application_id, applicationId));
server/utils/pdfGenerator.ts:61:    console.log(`üìÑ [PDF GENERATOR] Found ${applicationDocuments.length} documents for application`);
server/utils/pdfGenerator.ts:68:    doc.text('SIGNED LOAN APPLICATION', 20, 30);
server/utils/pdfGenerator.ts:70:    // Application Details
server/utils/pdfGenerator.ts:72:    doc.text(`Application ID: ${application.id}`, 20, 50);
server/utils/pdfGenerator.ts:73:    doc.text(`Business Name: ${application.business_name || 'N/A'}`, 20, 60);
server/utils/pdfGenerator.ts:74:    doc.text(`Requested Amount: $${application.requested_amount?.toLocaleString() || 'N/A'}`, 20, 70);
server/utils/pdfGenerator.ts:75:    doc.text(`Use of Funds: ${application.use_of_funds || 'N/A'}`, 20, 80);
server/utils/pdfGenerator.ts:76:    doc.text(`Status: ${application.status}`, 20, 90);
server/utils/pdfGenerator.ts:77:    doc.text(`Submitted: ${application.created_at?.toLocaleDateString() || 'N/A'}`, 20, 100);
server/utils/pdfGenerator.ts:83:    if (applicationDocuments.length > 0) {
server/utils/pdfGenerator.ts:84:      applicationDocuments.forEach((doc_item, index) => {
server/utils/pdfGenerator.ts:96:    doc.text('By submitting this application, I confirm that all information', 20, yPos + 10);
server/utils/pdfGenerator.ts:110:    const pdfFileName = `signed_application_${applicationId}.pdf`;
server/utils/pdfGenerator.ts:126:        application_id: applicationId,
server/utils/pdfGenerator.ts:130:        document_type: 'signed_application',
server/utils/pdfGenerator.ts:145:    console.error(`‚ùå [PDF GENERATOR] Error generating PDF for ${applicationId}:`, error);
server/utils/pdfGenerator.ts:150:export async function generatePDFForApplication(applicationId: string): Promise<{ success: boolean; documentId?: string; error?: string }> {
server/utils/pdfGenerator.ts:152:    const documentId = await generateSignedApplicationPDF(applicationId);
server/utils/pdfGenerator.ts:162:export async function regenerateSignedApplicationPDF(applicationId: string): Promise<string> {
server/utils/pdfGenerator.ts:163:  // First remove any existing signed application PDF
server/utils/pdfGenerator.ts:170:      eq(documents.application_id, applicationId),
server/utils/pdfGenerator.ts:171:      eq(documents.document_type, 'signed_application')
server/utils/pdfGenerator.ts:176:  return await generateSignedApplicationPDF(applicationId);
server/utils/pdfGenerator.ts:179:export async function hasSignedApplicationPDF(applicationId: string): Promise<boolean> {
server/utils/pdfGenerator.ts:188:        eq(documents.application_id, applicationId),
server/utils/pdfGenerator.ts:189:        eq(documents.document_type, 'signed_application')
server/utils/hardenedDocumentStorage.ts:33:  applicationId: string;
server/utils/hardenedDocumentStorage.ts:71:        document_id, application_id, file_name, upload_attempted_at,
server/utils/hardenedDocumentStorage.ts:79:      auditData.applicationId,
server/utils/hardenedDocumentStorage.ts:98:async function attemptS3Backup(content: Buffer, fileName: string, documentId: string, applicationId: string): Promise<{success: boolean, storageKey?: string, error?: string}> {
server/utils/hardenedDocumentStorage.ts:107:    const storageKey = await s3Storage.set(content, fileName, applicationId);
server/utils/hardenedDocumentStorage.ts:123:  applicationId: string,
server/utils/hardenedDocumentStorage.ts:138:    applicationId,
server/utils/hardenedDocumentStorage.ts:186:    const storageKey = await s3Storage.set(fileContent, originalFileName, applicationId);
server/utils/hardenedDocumentStorage.ts:200:      applicationId,
server/utils/hardenedDocumentStorage.ts:271:      applicationId: row.application_id,
server/routes/pipeline.recs.ts:8:r.post('/api/pipeline/cards/:id/recommendations', (req, res)=>{
server/routes/pipeline.recs.ts:17:// list recommendations for a card
server/routes/pipeline.recs.ts:18:r.get('/api/pipeline/cards/:id/recommendations', (req,res)=>{
server/routes/pipeline.recs.ts:34:  // TODO: if funded ‚Üí move pipeline card to Accepted; if all declined ‚Üí Declined
server/services/rtbf/purge.ts:23:    // 2. Delete/anonymize applications
server/services/rtbf/purge.ts:25:      // First get applications for this contact
server/services/rtbf/purge.ts:27:        SELECT id FROM applications WHERE contact_id = ${contactId}
server/services/rtbf/purge.ts:31:      results.applications_found = appIds.length;
server/services/rtbf/purge.ts:35:        await db.execute(sql`DELETE FROM documents WHERE application_id = ANY(${appIds})`);
server/services/rtbf/purge.ts:36:        await db.execute(sql`DELETE FROM lender_activity WHERE application_id = ANY(${appIds})`);
server/services/rtbf/purge.ts:37:        await db.execute(sql`DELETE FROM decision_traces WHERE application_id = ANY(${appIds})`);
server/services/rtbf/purge.ts:39:        // Anonymize applications instead of deleting (for compliance)
server/services/rtbf/purge.ts:41:          UPDATE applications SET
server/services/rtbf/purge.ts:55:        results.anonymized.applications = anonResult.rowsAffected || 0;
server/services/rtbf/purge.ts:65:      results.errors.push(`applications: ${(error as Error).message}`);
server/services/rtbf/purge.ts:88: * Purge data for a specific application (RTBF compliance)
server/services/rtbf/purge.ts:90:export async function purgeApplicationData(applicationId: string) {
server/services/rtbf/purge.ts:91:  console.log(`[RTBF] Starting data purge for application ${applicationId}`);
server/services/rtbf/purge.ts:99:        DELETE FROM documents WHERE application_id = ${applicationId}
server/services/rtbf/purge.ts:109:        DELETE FROM comm_messages WHERE application_id = ${applicationId}
server/services/rtbf/purge.ts:119:        DELETE FROM lender_activity WHERE application_id = ${applicationId}
server/services/rtbf/purge.ts:129:        DELETE FROM decision_traces WHERE application_id = ${applicationId}
server/services/rtbf/purge.ts:136:    // 5. Anonymize the application instead of deleting
server/services/rtbf/purge.ts:139:        UPDATE applications SET
server/services/rtbf/purge.ts:151:        WHERE id = ${applicationId}
server/services/rtbf/purge.ts:153:      results.anonymized.applications = appResult.rowsAffected || 0;
server/services/rtbf/purge.ts:155:      results.errors.push(`application_anonymization: ${(error as Error).message}`);
server/services/rtbf/purge.ts:161:        DELETE FROM audit_log WHERE entity_id = ${applicationId} OR data::text LIKE '%${applicationId}%'
server/services/rtbf/purge.ts:168:    console.log(`[RTBF] Application ${applicationId} purge completed:`, results);
server/services/rtbf/purge.ts:172:    console.error(`[RTBF] Application purge failed for ${applicationId}:`, error);
server/utils/fileRecoveryService.ts:29:        LEFT JOIN applications a ON d.application_id = a.id 
server/utils/fileRecoveryService.ts:43:        () => this.recoverFromApplicationFolder(documentId, doc.application_id, doc.file_name),
server/utils/fileRecoveryService.ts:56:            doc.application_id,
server/utils/fileRecoveryService.ts:82:        doc.application_id,
server/utils/fileRecoveryService.ts:139:   * Method 2: Look in application-specific folders
server/utils/fileRecoveryService.ts:141:  private async recoverFromApplicationFolder(documentId: string, applicationId: string, fileName: string): Promise<{
server/utils/fileRecoveryService.ts:148:        `uploads/applications/${applicationId}/${fileName}`,
server/utils/fileRecoveryService.ts:149:        `uploads/${applicationId}/${fileName}`,
server/utils/fileRecoveryService.ts:150:        `uploads/documents/${applicationId}/${fileName}`
server/utils/fileRecoveryService.ts:162:            console.log(`üîÑ [FILE RECOVERY] Recovered from application folder: ${possiblePath} -> ${targetPath}`);
server/utils/fileRecoveryService.ts:165:              recoveryMethod: 'application_folder_recovery',
server/utils/fileRecoveryService.ts:177:      console.log(`‚ùå [FILE RECOVERY] Application folder recovery failed: ${error.message}`);
server/routes/documentWorkflow.ts:8:import { applications } from "../../shared/schema";
server/routes/documentWorkflow.ts:14: * POST /api/applications/:id/nudge-documents
server/routes/documentWorkflow.ts:15: * Mark application as having missing documents
server/routes/documentWorkflow.ts:17:router.post("/api/applications/:id/nudge-documents", bearerAuth, async (req, res) => {
server/routes/documentWorkflow.ts:21:    // Update application to mark missing documents
server/routes/documentWorkflow.ts:23:      .update(applications)
server/routes/documentWorkflow.ts:28:      .where(eq(applications.id, id));
server/routes/documentWorkflow.ts:30:    console.log(`üìã Application ${id} marked with missing documents`);
server/routes/documentWorkflow.ts:34:      message: "Application marked as having missing documents",
server/routes/documentWorkflow.ts:35:      applicationId: id
server/routes/documentWorkflow.ts:49: * GET /api/public/applications/:id/required-docs
server/routes/documentWorkflow.ts:50: * Public endpoint to retrieve required document rules for an application
server/routes/documentWorkflow.ts:52:router.get("/api/public/applications/:id/required-docs", async (req, res) => {
server/routes/documentWorkflow.ts:56:    // Get application details
server/routes/documentWorkflow.ts:57:    const application = await db
server/routes/documentWorkflow.ts:59:        id: applications.id,
server/routes/documentWorkflow.ts:60:        productCategory: applications.productCategory,
server/routes/documentWorkflow.ts:61:        requestedAmount: applications.requestedAmount,
server/routes/documentWorkflow.ts:62:        formData: applications.formData
server/routes/documentWorkflow.ts:64:      .from(applications)
server/routes/documentWorkflow.ts:65:      .where(eq(applications.id, id))
server/routes/documentWorkflow.ts:68:    if (application.length === 0) {
server/routes/documentWorkflow.ts:71:        error: 'Application not found'
server/routes/documentWorkflow.ts:75:    const app = application[0];
server/routes/documentWorkflow.ts:77:    // Compute required documents based on application details
server/routes/documentWorkflow.ts:80:    console.log(`üìÑ Retrieved document requirements for application ${id}`);
server/routes/documentWorkflow.ts:85:      applicationId: id,
server/routes/documentWorkflow.ts:101: * Compute required documents based on application details
server/routes/documentWorkflow.ts:103:async function computeRequiredDocs(application: any) {
server/routes/documentWorkflow.ts:104:  const { productCategory, requestedAmount, formData } = application;
server/routes/documentWorkflow.ts:106:  // Base required documents for all applications
server/utils/bulletproofDocumentStorage.ts:10:  applicationId: string;
server/utils/bulletproofDocumentStorage.ts:30:    applicationId,
server/utils/bulletproofDocumentStorage.ts:71:      storageKey = `${applicationId}/${fileName}`;
server/utils/bulletproofDocumentStorage.ts:76:        applicationId: applicationId
server/utils/bulletproofDocumentStorage.ts:90:      application_id: applicationId,
server/routes/twilio.voice.ts:31:      outgoingApplicationSid: TWILIO_TWIML_APP_SID!,
server/services/alerts/slack.ts:7:      headers:{ "Content-Type":"application/json" },
server/utils/alertSystem.ts:18:  applicationId?: string;
server/routes/documentWebhooks.ts:76:      'Content-Type': 'application/json',
server/routes/documentWebhooks.ts:110:      applicationId: "test-application-id",
server/routes/ops.health.ts:12:    const appsCount = await db.execute("SELECT COUNT(*) as count FROM applications");
server/routes/documentReupload.ts:17:      'application/pdf',
server/routes/documentReupload.ts:21:      'application/msword',
server/routes/documentReupload.ts:22:      'application/vnd.openxmlformats-officedocument.wordprocessingml.document',
server/routes/ops.fullAudit.ts:19:    const body = ct.includes("application/json") ? await res.json().catch(()=>null) : await res.text().catch(()=>null);
server/routes/ops.fullAudit.ts:95:      name: "Sales Pipeline",
server/routes/ops.fullAudit.ts:97:        { key:"/sales-pipeline page renders SPA", check: ui("/sales-pipeline") },
server/routes/ops.fullAudit.ts:98:        { key:"/api/pipeline responds", check: apiOK("/api/pipeline","items") },
server/routes/ops.fullAudit.ts:99:        { key:"applications table schema", check: tableHas(["id","stage","created_at"], "applications") }
server/utils/twilioService.ts:4: * Integrates 6 Twilio products for Staff Application:
server/services/backup/runner.ts:5:import { PassThrough, pipeline } from "stream";
server/services/backup/runner.ts:23:    const put = s3.send(new PutObjectCommand({ Bucket: bucket, Key: key, Body: pass, ContentType: "application/gzip" }));
server/services/backup/runner.ts:43:      pipeline(cp.stdout, gzip, pass, (err)=>{ if (err) console.error("pipeline error", err); });
server/services/backup/runner.ts:55:    const put2 = s3.send(new PutObjectCommand({ Bucket: bucket, Key: key2, Body: pass2, ContentType: "application/gzip" }));
server/services/backup/runner.ts:57:    pipeline(gz2, pass2, (err)=>{ if (err) console.error("gz pipeline err", err); });
server/routes/documentResync.ts:4: * Emergency resync system for fixing document-application associations
server/routes/documentResync.ts:5: * Fixes the A10 application document synchronization issue
server/routes/documentResync.ts:17: * Fix orphaned documents by associating them with correct applications
server/routes/documentResync.ts:23:    // Get all applications and their expected document count
server/routes/documentResync.ts:24:    const applicationsQuery = `
server/routes/documentResync.ts:31:        (SELECT COUNT(*) FROM documents d WHERE d.application_id = a.id) as doc_count
server/routes/documentResync.ts:32:      FROM applications a
server/routes/documentResync.ts:37:    const applicationsResult = await pool.query(applicationsQuery);
server/routes/documentResync.ts:38:    const applications = applicationsResult.rows;
server/routes/documentResync.ts:40:    console.log(`üìä [DOC RESYNC] Found ${applications.length} applications`);
server/routes/documentResync.ts:51:      LEFT JOIN applications a ON d.application_id = a.id
server/routes/documentResync.ts:65:    // Try to associate orphaned documents with recent applications
server/routes/documentResync.ts:69:      // Find the most recent application that has no documents
server/routes/documentResync.ts:70:      const applicationWithoutDocs = applications.find(app => 
server/routes/documentResync.ts:75:      if (applicationWithoutDocs) {
server/routes/documentResync.ts:76:        console.log(`üîß [DOC RESYNC] Linking document ${doc.id} to application ${applicationWithoutDocs.id} (${applicationWithoutDocs.business_name})`);
server/routes/documentResync.ts:80:          SET application_id = $1 
server/routes/documentResync.ts:84:        await pool.query(updateQuery, [applicationWithoutDocs.id, doc.id]);
server/routes/documentResync.ts:88:        const appIndex = applications.findIndex(app => app.id === applicationWithoutDocs.id);
server/routes/documentResync.ts:90:          applications[appIndex].doc_count++;
server/routes/documentResync.ts:101:        COUNT(CASE WHEN application_id IS NOT NULL THEN 1 END) as linked_docs,
server/routes/documentResync.ts:102:        COUNT(CASE WHEN application_id IS NULL THEN 1 END) as orphaned_docs
server/routes/documentResync.ts:113:        totalApplications: applications.length,
server/routes/documentResync.ts:119:      applications: applications.map(app => ({
server/routes/documentResync.ts:146:    // Get application document counts
server/routes/documentResync.ts:155:      FROM applications a
server/routes/documentResync.ts:157:      LEFT JOIN documents d ON d.application_id = a.id
server/routes/documentResync.ts:163:    const applications = result.rows;
server/routes/documentResync.ts:169:      LEFT JOIN applications a ON d.application_id = a.id
server/routes/documentResync.ts:179:        totalApplications: applications.length,
server/routes/documentResync.ts:180:        applicationsWithoutDocuments: applications.filter(app => app.document_count === 0).length,
server/routes/documentResync.ts:182:        totalDocuments: applications.reduce((sum, app) => sum + parseInt(app.document_count), 0) + orphanedCount
server/routes/documentResync.ts:184:      applications: applications.map(app => ({
server/utils/s3.ts:2: * üöÄ S3 PRODUCTION UTILITY FOR STAFF APPLICATION
server/utils/s3.ts:50:   * @param applicationId - Application ID for organization
server/utils/s3.ts:53:  async set(buffer: Buffer, fileName: string, applicationId?: string): Promise<string> {
server/utils/s3.ts:55:      // Generate storage key with application organization
server/utils/s3.ts:57:      const storageKey = applicationId 
server/utils/s3.ts:58:        ? `${applicationId}/${fileName}`
server/utils/s3.ts:83:          applicationId: applicationId || 'unknown'
server/utils/s3.ts:288:      'pdf': 'application/pdf',
server/utils/s3.ts:289:      'doc': 'application/msword',
server/utils/s3.ts:290:      'docx': 'application/vnd.openxmlformats-officedocument.wordprocessingml.document',
server/utils/s3.ts:291:      'xls': 'application/vnd.ms-excel',
server/utils/s3.ts:292:      'xlsx': 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet',
server/utils/s3.ts:300:    return contentTypes[ext || ''] || 'application/octet-stream';
server/utils/s3.ts:311:export async function uploadToStorage(buffer: Buffer, fileName: string, applicationId?: string): Promise<string> {
server/utils/s3.ts:312:  return s3Storage.set(buffer, fileName, applicationId);
server/routes/ops.kill-sw.ts:6:  res.setHeader("Content-Type", "application/javascript");
server/utils/s3Upload.ts:15:export async function uploadToS3(applicationId: string, file: Express.Multer.File) {
server/utils/s3Upload.ts:16:  const storageKey = `${applicationId}/${file.originalname}`;
server/utils/s3Upload.ts:38:  applicationId: string,
server/utils/s3Upload.ts:45:  const storageKey = `${applicationId}/${Date.now()}-${options.fileName}`;
server/utils/s3Upload.ts:52:    ContentType: "application/pdf",
server/services/engine/v11.ts:60:export async function runEngine11(applicationId: string, variant="prod"){
server/services/engine/v11.ts:63:    FROM applications a WHERE a.id=${applicationId} LIMIT 1
server/services/engine/v11.ts:65:  if (!a) throw new Error("application not found");
server/services/engine/v11.ts:71:    WHERE scope IN ('global', 'application:${applicationId}')
server/services/engine/v11.ts:97:    const scopes = ["global", `product:${p.key}`, `application:${a.id}`];
server/services/engine/v11.ts:127:    INSERT INTO decision_traces(application_id, variant, results, rules_applied, inputs)
server/services/engine/v11.ts:128:    VALUES (${applicationId}, ${variant}, ${JSON.stringify(ranked)}, ${JSON.stringify(rulesApplied)}, ${JSON.stringify(inputs)})
server/services/engine/v11.ts:131:  return { applicationId, variant, weights, top: ranked.slice(0,5), all: results, rulesApplied, inputs };
server/routes/documentRestoration.ts:9:router.post('/restore-actual-documents/:applicationId', async (req, res) => {
server/routes/documentRestoration.ts:11:    const { applicationId } = req.params;
server/routes/documentRestoration.ts:12:    console.log(`üîÑ [DOCUMENT RESTORATION] Starting actual document restoration for: ${applicationId}`);
server/routes/documentRestoration.ts:14:    // Get all placeholder documents (.txt files) for this application
server/routes/documentRestoration.ts:18:      WHERE application_id = $1 
server/routes/documentRestoration.ts:21:    const placeholderResult = await db.query(placeholderQuery, [applicationId]);
server/routes/documentRestoration.ts:72:          let mimeType = 'application/octet-stream';
server/routes/documentRestoration.ts:75:            case '.pdf': mimeType = 'application/pdf'; break;
server/routes/documentRestoration.ts:76:            case '.xlsx': mimeType = 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet'; break;
server/routes/documentRestoration.ts:77:            case '.docx': mimeType = 'application/vnd.openxmlformats-officedocument.wordprocessingml.document'; break;
server/routes/documentRestoration.ts:155:        applicationId,
server/routes/documentRestoration.ts:176:// üîç GET: Check restoration status for application
server/routes/documentRestoration.ts:177:router.get('/status/:applicationId', async (req, res) => {
server/routes/documentRestoration.ts:179:    const { applicationId } = req.params;
server/routes/documentRestoration.ts:188:      WHERE application_id = $1
server/routes/documentRestoration.ts:191:    const result = await pool.query(statusQuery, [applicationId]);
server/routes/documentRestoration.ts:196:      applicationId,
server/utils/s3PreSignedUrls.ts:50:  contentType: string = 'application/pdf',
server/services/lender/jwt.ts:4:export function signShareToken(payload: { shareId: string; applicationId: string; partnerId: string; perms: string[]; exp: number }) {
server/services/lender/jwt.ts:9:export function verifyShareToken(token: string): { shareId: string; applicationId: string; partnerId: string; perms: string[] } | null {
server/services/lender/jwt.ts:12:    return { shareId: d.shareId, applicationId: d.applicationId, partnerId: d.partnerId, perms: d.perms || [] };
server/routes/documentReprocessing.ts:39:    const ocrResult = await processOCR(document.filePath || "", documentId, document.applicationId);
server/routes/documentReprocessing.ts:86:    const analysisResult = await analyzeBankingDocument(ocrResult.extractedData, document.applicationId);
server/utils/pureS3Upload.ts:36:  applicationId: string;
server/utils/pureS3Upload.ts:46:  const { applicationId, fileBuffer, fileName, documentType, mimeType } = params;
server/utils/pureS3Upload.ts:52:  const storageKey = `${applicationId}/${fileName}`;
server/utils/pureS3Upload.ts:58:  console.log(`[S3] Application: ${applicationId}`);
server/utils/pureS3Upload.ts:74:        applicationId: applicationId,
server/utils/pureS3Upload.ts:89:      application_id: applicationId,
server/services/analyticsPdf.tsx:9:  card: { border: "1pt solid #ddd", padding: 8, marginBottom: 6 }
server/services/analyticsPdf.tsx:24:        <View style={styles.card}>
server/services/analyticsPdf.tsx:25:          <View style={styles.row}><Text>Applications (period)</Text><Text>{activity.apps_this_period || 0}</Text></View>
server/services/analyticsPdf.tsx:34:        <View style={styles.card}>
server/services/analyticsPdf.tsx:43:        <View style={styles.card}>
server/services/analyticsPdf.tsx:50:        <View style={styles.card}>
server/services/analyticsPdf.tsx:60:        <View style={styles.card}>
server/services/analyticsPdf.tsx:70:        <View style={styles.card}>
server/services/pipelineStages.js:1:// Canonical pipeline stages (order matters)
server/services/pipelineStages.js:52:function validateStageTransition(currentStage, targetStage, userRole, applicationData) {
server/services/pipelineStages.js:55:    return { valid: false, reason: "Only admin and staff can change pipeline stages" };
server/services/pipelineStages.js:84:      if (!applicationData[field]) {
server/services/pipelineStages.js:96:function getNextAllowedStages(currentStage, userRole, applicationData) {
server/services/pipelineStages.js:101:    const validation = validateStageTransition(currentStage, targetStage, userRole, applicationData);
server/utils/s3Test.ts:38:    const testContent = Buffer.from('S3 test file from Staff Application');
server/routes/ops.sw-kill.ts:6:  res.setHeader("Content-Type", "application/javascript");
server/routes/documentRecoveryUI.ts:9:import { documents, applications } from '../../shared/schema';
server/routes/documentRecoveryUI.ts:33:// Get application documents with missing file status
server/routes/documentRecoveryUI.ts:34:router.get('/application/:applicationId/documents', async (req, res) => {
server/routes/documentRecoveryUI.ts:36:    const { applicationId } = req.params;
server/routes/documentRecoveryUI.ts:37:    console.log(`üîÑ [RECOVERY-UI] Fetching documents for application: ${applicationId}`);
server/routes/documentRecoveryUI.ts:44:      SELECT id, application_id, file_name, file_path, file_size, file_type, 
server/routes/documentRecoveryUI.ts:47:      WHERE application_id = $1
server/routes/documentRecoveryUI.ts:51:    const docsResult = await sql(documentsQuery, [applicationId]);
server/routes/documentRecoveryUI.ts:53:    // Get application info  
server/routes/documentRecoveryUI.ts:56:      FROM applications 
server/routes/documentRecoveryUI.ts:60:    const appResult = await sql(appQuery, [applicationId]);
server/routes/documentRecoveryUI.ts:112:      applicationId,
server/routes/documentRecoveryUI.ts:156:    const applicationId = doc.applicationId;
server/routes/documentRecoveryUI.ts:165:      applicationId,
server/routes/documentRecoveryUI.ts:190:        storageKey: `documents/${applicationId}/${result.documentId}.${fileExtension}`
server/routes/documentRecoveryUI.ts:222:// Bulk recovery status check for multiple applications
server/routes/documentRecoveryUI.ts:225:    const { applicationIds } = req.body;
server/routes/documentRecoveryUI.ts:227:    if (!Array.isArray(applicationIds)) {
server/routes/documentRecoveryUI.ts:228:      return res.status(400).json({ error: 'applicationIds must be an array' });
server/routes/documentRecoveryUI.ts:234:    for (const appId of applicationIds) {
server/routes/documentRecoveryUI.ts:238:        .where(eq(documents.applicationId, appId));
server/routes/documentRecoveryUI.ts:252:        applicationId: appId,
server/routes/documentRecoveryUI.ts:262:      applications: bulkStatus,
server/routes/documentRecoveryUI.ts:264:        totalApplications: applicationIds.length,
server/routes/documentRecoveryUI.ts:265:        applicationsNeedingRecovery: bulkStatus.filter(a => a.needsRecovery).length,
server/utils/documentStorage.ts:25: * No more applicationId folders - centralized storage
server/utils/documentStorage.ts:44:  applicationId: string,
server/utils/documentStorage.ts:59:    'purchase_orders', 'sba_forms', 'signed_application', 'supplier_agreement', 'tax_returns', 'void_pad'
server/utils/documentStorage.ts:142:        id, application_id, file_name, file_path, file_size, 
server/utils/documentStorage.ts:150:      applicationId,
server/utils/documentStorage.ts:179:    enqueueRecoveryAlert(applicationId, originalFileName);
server/utils/documentStorage.ts:214: * SAFETY NET 2: Validate application has documents before submission
server/utils/documentStorage.ts:216:export async function validateApplicationHasDocuments(applicationId: string): Promise<boolean> {
server/utils/documentStorage.ts:218:    const appDocuments = await db.select().from(documents).where(eq(documents.applicationId, applicationId));
server/utils/documentStorage.ts:221:    console.log(`üìä [Document Validation] Application ${applicationId}: ${appDocuments.length} documents`);
server/utils/documentStorage.ts:224:      console.warn(`‚ö†Ô∏è [Document Validation] Application ${applicationId} has no documents!`);
server/utils/documentStorage.ts:229:    console.error(`‚ùå [Document Validation] Error checking documents for app ${applicationId}:`, error);
server/utils/documentStorage.ts:235: * SAFETY NET 3: Prevent application deletion if documents exist
server/utils/documentStorage.ts:237:export async function checkDocumentsBeforeAppDeletion(applicationId: string): Promise<{ canDelete: boolean; documentCount: number }> {
server/utils/documentStorage.ts:239:    const appDocuments = await db.select().from(documents).where(eq(documents.applicationId, applicationId));
server/utils/documentStorage.ts:243:      console.warn(`üõë [Deletion Protection] Application ${applicationId} has ${documentCount} documents - deletion blocked`);
server/utils/documentStorage.ts:247:    console.log(`‚úÖ [Deletion Protection] Application ${applicationId} safe to delete - no documents`);
server/utils/documentStorage.ts:250:    console.error(`‚ùå [Deletion Protection] Error checking documents for app ${applicationId}:`, error);
server/utils/documentStorage.ts:309:    // Alternative paths to search (including application-specific folders)
server/utils/documentStorage.ts:313:      path.join(BASE_DIR, 'uploads', 'applications', documentId, `${documentId}${extension}`),
server/utils/documentStorage.ts:317:    // Search all application folders for the document
server/utils/documentStorage.ts:324:          // Try to find any file that contains the document ID in application folders
server/utils/documentStorage.ts:436:  SIGNED_APPLICATION: 'signed_application',
server/utils/documentHealthDashboard.ts:15:  applicationId: string;
server/utils/documentHealthDashboard.ts:80:    const renderableTypes = ['application/pdf', 'image/jpeg', 'image/png', 'text/plain'];
server/utils/documentHealthDashboard.ts:105:      applicationId: document.applicationId,
server/utils/documentHealthDashboard.ts:121:      applicationId: '',
server/utils/documentHealthDashboard.ts:169:          applicationId: doc.applicationId,
server/utils/documentHealthDashboard.ts:258: * Get health report for specific application
server/utils/documentHealthDashboard.ts:260:export async function getApplicationHealthReport(applicationId: string): Promise<{
server/utils/documentHealthDashboard.ts:261:  applicationId: string;
server/utils/documentHealthDashboard.ts:270:  console.log(`üè• [HEALTH] Generating health report for application: ${applicationId}`);
server/utils/documentHealthDashboard.ts:273:    // Get documents for this application
server/utils/documentHealthDashboard.ts:277:      .where(eq(documents.applicationId, applicationId));
server/utils/documentHealthDashboard.ts:279:    console.log(`üìã [HEALTH] Found ${appDocuments.length} documents for application`);
server/utils/documentHealthDashboard.ts:295:      applicationId,
server/utils/documentHealthDashboard.ts:306:    console.error(`‚ùå [HEALTH] Error generating application health report:`, error);
server/utils/documentHealthDashboard.ts:308:      applicationId,
server/utils/documentHealthDashboard.ts:324:    'Application ID',
server/utils/documentHealthDashboard.ts:339:    doc.applicationId,
server/test-crm-twilio-integration.js:36:          'Content-Type': 'application/json'
server/test-crm-twilio-integration.js:60:          'Content-Type': 'application/json'
server/test-crm-twilio-integration.js:87:          'Content-Type': 'application/json'
server/test-crm-twilio-integration.js:111:          'Content-Type': 'application/json'
server/test-crm-twilio-integration.js:135:          'Content-Type': 'application/json'
server/routes/documentReassignment.ts:11: * Allows administrators to reassign documents between applications
server/routes/documentReassignment.ts:45:    const { documentIds, targetApplicationId, reason } = req.body;
server/routes/documentReassignment.ts:54:    if (!targetApplicationId) {
server/routes/documentReassignment.ts:57:        error: 'Target application ID is required'
server/routes/documentReassignment.ts:61:    console.log(`üîÑ [DOC-REASSIGN] Admin ${decoded.email} reassigning ${documentIds.length} documents to ${targetApplicationId}`);
server/routes/documentReassignment.ts:71:            application_id: targetApplicationId,
server/routes/documentReassignment.ts:84:    console.log(`üìã [DOC-REASSIGN] AUDIT: Admin ${decoded.email} reassigned ${reassignedCount}/${documentIds.length} documents to application ${targetApplicationId} - Reason: ${reason || 'Not specified'}`);
server/routes/documentReassignment.ts:90:      targetApplicationId,
server/routes/ops.healthFull.ts:32:  const tables = ["users","contacts","applications","documents","lenders"];
server/routes/ops.healthFull.ts:74:  const apis = ["/api/contacts","/api/pipeline","/api/lenders","/api/documents"];
server/routes/crmContactCard.ts:2: * Enhanced CRM Contact Card API Routes
server/routes/crmContactCard.ts:16:  applications 
server/routes/crmContactCard.ts:30:    console.log(`üîç [CRM-CONTACT-CARD] Fetching contact details for: ${id}`);
server/routes/crmContactCard.ts:32:    // Get contact with associated application data using existing schema
server/routes/crmContactCard.ts:40:        c.application_id,
server/routes/crmContactCard.ts:46:        a.status as application_status,
server/routes/crmContactCard.ts:51:      LEFT JOIN applications a ON c.application_id = a.id
server/routes/crmContactCard.ts:74:      applicationId: contactRow.application_id,
server/routes/crmContactCard.ts:76:      source: 'application',
server/routes/crmContactCard.ts:82:    const application = contactRow.app_id ? {
server/routes/crmContactCard.ts:85:      status: contactRow.application_status,
server/routes/crmContactCard.ts:91:    console.log(`‚úÖ [CRM-CONTACT-CARD] Contact found: ${contact.name}`);
server/routes/crmContactCard.ts:96:      application,
server/routes/crmContactCard.ts:101:    console.error('‚ùå [CRM-CONTACT-CARD] Failed to fetch contact:', error);
server/routes/crmContactCard.ts:352: * GET /api/crm/contacts/:id/applications
server/routes/crmContactCard.ts:353: * Get all applications associated with this contact
server/routes/crmContactCard.ts:355:router.get('/:id/applications', async (req, res) => {
server/routes/crmContactCard.ts:359:    console.log(`üîç [CRM-APPLICATIONS] Fetching applications for contact: ${id}`);
server/routes/crmContactCard.ts:361:    const contactApplications = await db
server/routes/crmContactCard.ts:363:      .from(applications)
server/routes/crmContactCard.ts:364:      .where(eq(applications.id, sql`(SELECT application_id FROM contacts WHERE id = ${id})`))
server/routes/crmContactCard.ts:365:      .orderBy(desc(applications.createdAt));
server/routes/crmContactCard.ts:367:    console.log(`‚úÖ [CRM-APPLICATIONS] Found ${contactApplications.length} applications`);
server/routes/crmContactCard.ts:371:      applications: contactApplications,
server/routes/crmContactCard.ts:376:    console.error('‚ùå [CRM-APPLICATIONS] Failed to fetch applications:', error);
server/routes/crmContactCard.ts:379:      error: 'Failed to fetch applications'
server/routes/crmContactCard.ts:391:    service: 'CRM Contact Card Service',
server/routes/crmContactCard.ts:397: * GET /api/crm/contact-card (no ID) - Health check fallback
server/routes/crmContactCard.ts:403:    service: 'CRM Contact Card Service',
server/routes/crmContactCard.ts:410:console.log('üîç [CRM-CONTACT-CARD] Router created with', router.stack?.length || 0, 'routes');
server/utils/s3DirectStorage.ts:27:  applicationId: string
server/utils/s3DirectStorage.ts:34:    const storageKey = `${applicationId}/${fileName}`;
server/utils/s3DirectStorage.ts:48:        'application-id': applicationId,
server/routes/conflicts.ts:12:/** GET /api/conflicts/:applicationId
server/routes/conflicts.ts:17:  res.type('application/json'); // <- ensure JSON, not HTML
server/routes/conflicts.ts:20:    { column: 'req_business_address', value: '1234 Jasper Avenue, Ste 900', sourceType: 'client', sourceId: 'client_profile', label: 'Client Application' },
server/routes/conflicts.ts:28:router.get('/:applicationId', async (req, res, next) => {
server/routes/conflicts.ts:30:    const appId = req.params.applicationId;
server/utils/s3Diagnostic.ts:4: * Comprehensive S3 testing and validation for Staff Application
server/routes/conference.ts:73:      headers: { Authorization: auth, 'Content-Type':'application/x-www-form-urlencoded' },
server/routes/ops.routeInspector.ts:53:  const targets = ["/","/contacts","/pipeline","/lenders","/analytics/roi","/productivity/tasks"];
server/utils/documentVersioning.ts:28:  // Create versioned storage key: applicationId/documentId-hash.ext
server/utils/documentVersioning.ts:87:  applicationId: string,
server/utils/documentVersioning.ts:104:      applicationId: applicationId,
server/utils/uploadGuard.ts:2:import { applications } from '../../shared/schema';
server/utils/uploadGuard.ts:6: * Upload Guard - Prevents uploads to invalid or submitted applications
server/utils/uploadGuard.ts:8:export async function validateApplicationForUpload(applicationId: string): Promise<{ valid: boolean; error?: string }> {
server/utils/uploadGuard.ts:10:    console.log(`üîç [UPLOAD GUARD] Validating application: ${applicationId}`);
server/utils/uploadGuard.ts:12:    // Check if application exists and get status
server/utils/uploadGuard.ts:13:    const application = await db
server/utils/uploadGuard.ts:14:      .select({ id: applications.id, status: applications.status })
server/utils/uploadGuard.ts:15:      .from(applications)
server/utils/uploadGuard.ts:16:      .where(eq(applications.id, applicationId))
server/utils/uploadGuard.ts:19:    if (!application || application.length === 0) {
server/utils/uploadGuard.ts:20:      console.log(`‚ùå [UPLOAD GUARD] Application not found: ${applicationId}`);
server/utils/uploadGuard.ts:21:      return { valid: false, error: 'Application not found' };
server/utils/uploadGuard.ts:24:    const app = application[0];
server/utils/uploadGuard.ts:25:    console.log(`üìã [UPLOAD GUARD] Application status: ${app.status}`);
server/utils/uploadGuard.ts:27:    // Allow uploads to draft and submitted applications
server/utils/uploadGuard.ts:28:    // Block uploads to completed, rejected, or archived applications
server/utils/uploadGuard.ts:35:        error: `Cannot upload to ${app.status} application. Only draft and submitted applications accept uploads.` 
server/utils/uploadGuard.ts:51:export async function auditUploadMismatch(applicationId: string, documentCount: number): Promise<void> {
server/utils/uploadGuard.ts:53:    console.log(`üìä [UPLOAD AUDIT] Application ${applicationId} now has ${documentCount} documents`);
server/utils/uploadGuard.ts:55:    // Check if application status and document count seem mismatched
server/utils/uploadGuard.ts:56:    const application = await db
server/utils/uploadGuard.ts:57:      .select({ status: applications.status, createdAt: applications.createdAt })
server/utils/uploadGuard.ts:58:      .from(applications)
server/utils/uploadGuard.ts:59:      .where(eq(applications.id, applicationId))
server/utils/uploadGuard.ts:62:    if (application && application.length > 0) {
server/utils/uploadGuard.ts:63:      const app = application[0];
server/utils/uploadGuard.ts:68:        console.log(`‚ö†Ô∏è [UPLOAD AUDIT] Stale draft application: ${applicationId} (${daysSinceCreated} days old)`);
server/utils/uploadGuard.ts:72:        console.log(`‚ö†Ô∏è [UPLOAD AUDIT] Submitted application with no documents: ${applicationId}`);
server/utils/uploadGuard.ts:76:        console.log(`‚ö†Ô∏è [UPLOAD AUDIT] High document count: ${applicationId} has ${documentCount} documents`);
server/utils/productNormalization.ts:5: * by the client application.
server/routes/documentBackupStatus.ts:37:        applicationId: doc.applicationId,
server/routes/communication.ts:45:        lastMessage: 'Application submitted successfully',
server/routes/communication.ts:77:        content: 'Hi! I wanted to check on my loan application status.',
server/routes/communication.ts:85:        content: 'Thanks for reaching out! Your application is currently being reviewed by our underwriting team. We\'ll have an update for you within 2-3 business days.',
server/routes/communication.ts:227:        subject: 'Loan Application Follow-up',
server/routes/communication.ts:228:        preview: 'Thank you for submitting your loan application. We have received...',
server/routes/communication.ts:238:        preview: 'We need some additional documents to complete your application...',
server/routes/communication.ts:248:        preview: 'Congratulations! Your loan application has been approved...',
server/routes/communication.ts:283:        subject: 'Loan Application Follow-up',
server/routes/communication.ts:284:        body: 'Thank you for submitting your loan application. We have received all your documents and our team is currently reviewing your application. We will get back to you within 2-3 business days with an update.',
server/routes/communication.ts:295:        subject: 'Re: Loan Application Follow-up',
server/routes/communication.ts:307:        subject: 'Re: Loan Application Follow-up',
server/routes/communication.ts:342:        content: 'Hi {{firstName}}! Welcome to Boreal Financial. Your loan application for {{loanAmount}} has been received. We\'ll be in touch soon!',
server/routes/communication.ts:353:        content: 'Dear {{firstName}},\n\nThank you for your loan application with {{businessName}}. To proceed with your application for {{loanAmount}}, we need the following documents:\n\n- Bank statements (last 3 months)\n- Tax returns (last 2 years)\n- Financial statements\n\nPlease upload these documents through your portal or reply to this email.\n\nBest regards,\nBoreal Financial Team',
server/routes/communication.ts:364:        content: 'Congratulations {{firstName}}! Your loan application for {{loanAmount}} has been APPROVED. We\'ll send the loan documents shortly. Contact us if you have any questions.',
server/routes/communication.ts:374:        content: 'Hi {{firstName}}, just checking in on your loan application. Need any help? Reply STOP to opt out.',
server/routes/documentAudit.ts:11:  application_id: string;
server/routes/documentAudit.ts:55:        applicationId: doc.application_id,
server/routes/documentAuditTrail.ts:124:        applicationId: document.applicationId,
server/routes/documentAuditTrail.ts:151:    const { applicationId } = req.query;
server/routes/documentAuditTrail.ts:155:    if (applicationId) {
server/routes/documentAuditTrail.ts:156:      query = query.where(eq(documents.applicationId, applicationId as string));
server/routes/documentAuditTrail.ts:176:        applicationId: doc.applicationId,
server/routes/chatSessions.ts:23:        applicationId: chatSessions.applicationId,
server/routes/o365.todo.ts:8:  const rsp = await fetch(`https://graph.microsoft.com/v1.0${path}`, { ...init, headers: { Authorization:`Bearer ${token}`, "Content-Type":"application/json" }});
server/routes/calendar-tasks-real.ts:21:        description: 'Review loan application and discuss terms',
server/routes/calendar-tasks-real.ts:112:        title: 'Review bank statements for Application #12345',
server/routes/calendar-tasks-real.ts:119:        applicationId: 'APP_12345',
server/routes/calendar-tasks-real.ts:124:        title: 'Follow up with lender on Application #12344',
server/routes/calendar-tasks-real.ts:125:        description: 'Check status of submitted application',
server/routes/calendar-tasks-real.ts:131:        applicationId: 'APP_12344',
server/routes/calendar-tasks-real.ts:136:        title: 'Send rejection notice to Application #12343',
server/routes/calendar-tasks-real.ts:143:        applicationId: 'APP_12343',
server/routes/calendar-tasks-real.ts:168:    const { title, description, priority = 'medium', dueDate, category, applicationId } = req.body;
server/routes/calendar-tasks-real.ts:182:      applicationId,
server/routes/analytics.roi.map.ts:6:// 1) gclid match: applications.gclid == GA4/Ads row-day window (¬±30d)
server/routes/analytics.roi.map.ts:7:// 2) email match: GA4 event params (email) -> contacts.email -> applications.contact_id
server/routes/analytics.roi.map.ts:8:// 3) campaign_id match: Ads campaign id -> applications.ad_campaign_id (last-touch)
server/routes/analytics.roi.map.ts:11:  // Map Google Ads -> applications by campaign_id first (cheap baseline)
server/routes/analytics.roi.map.ts:16:      select id, contact_id from applications where ad_platform='google_ads' and ad_campaign_id=${String(a.campaign_id||'')}
server/routes/analytics.roi.map.ts:20:        insert into roi_mappings(application_id, contact_id, source, campaign_id, day, cost_micros, conversions)
server/routes/analytics.roi.map.ts:27:  // Map GA4 events -> applications via gclid (best-effort; uses ga4_conversions.event_name as event)
server/routes/analytics.roi.map.ts:31:    const apps = (await db.execute(sql`select id, contact_id from applications where gclid is not null and created_at between ${g.day}::date - 30 and ${g.day}::date + 30`)).rows;
server/routes/analytics.roi.map.ts:34:        insert into roi_mappings(application_id, contact_id, source, event_name, day, revenue_cents)
server/routes/analytics.roi.map.ts:53:    left join applications a on a.id = m.application_id
server/routes/bulletproofUpload.ts:33:      'application/pdf',
server/routes/bulletproofUpload.ts:34:      'application/msword',
server/routes/bulletproofUpload.ts:35:      'application/vnd.openxmlformats-officedocument.wordprocessingml.document',
server/routes/bulletproofUpload.ts:40:      'application/vnd.ms-excel',
server/routes/bulletproofUpload.ts:41:      'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet'
server/routes/bulletproofUpload.ts:53: * POST /api/bulletproof/upload/:applicationId
server/routes/bulletproofUpload.ts:56:router.post('/upload/:applicationId', upload.single('document'), async (req, res) => {
server/routes/bulletproofUpload.ts:57:  console.log(`üöÄ [BULLETPROOF API] Upload request for application: ${req.params.applicationId}`);
server/routes/bulletproofUpload.ts:60:    const { applicationId } = req.params;
server/routes/bulletproofUpload.ts:99:      applicationId,
server/utils/regenerateStorageKey.ts:13:export async function regenerateStorageKey(applicationId: string, fileName: string): Promise<boolean> {
server/utils/regenerateStorageKey.ts:15:    console.log(`üîß [REGENERATE] Regenerating storage key for ${applicationId}/${fileName}`);
server/utils/regenerateStorageKey.ts:18:    const storageKey = `${applicationId}/${fileName}`;
server/utils/regenerateStorageKey.ts:24:      WHERE application_id = $2 AND file_name = $3 AND storage_key IS NULL
server/utils/regenerateStorageKey.ts:28:    const result = await pool.query(updateQuery, [storageKey, applicationId, fileName]);
server/utils/regenerateStorageKey.ts:34:      console.log(`‚ö†Ô∏è [REGENERATE] No documents updated for ${applicationId}/${fileName}`);
server/utils/regenerateStorageKey.ts:45: * Regenerates storage keys for all documents in an application
server/utils/regenerateStorageKey.ts:47:export async function regenerateAllStorageKeys(applicationId: string): Promise<number> {
server/utils/regenerateStorageKey.ts:49:    console.log(`üîß [REGENERATE-ALL] Processing all documents for application ${applicationId}`);
server/utils/regenerateStorageKey.ts:54:      WHERE application_id = $1 AND storage_key IS NULL
server/utils/regenerateStorageKey.ts:57:    const result = await pool.query(selectQuery, [applicationId]);
server/utils/regenerateStorageKey.ts:65:      const success = await regenerateStorageKey(applicationId, doc.file_name);
server/utils/regenerateStorageKey.ts:71:    console.log(`‚úÖ [REGENERATE-ALL] Updated ${updatedCount} storage keys for application ${applicationId}`);
server/routes/ops.db.health.ts:7:const TABLES = ["users","lenders","lender_products","contacts","applications"];
server/routes/ops.db.health.ts:110:      await db.execute(sql`insert into applications(contact_id, business_name, amount, stage, country, category, industry, months_in_business) values(${cid}, 'Test Application', 50000, 'new','CA','TermLoan','Services', 18)`);
server/routes/dataIntegrity.ts:4:import { applications, documents } from '../../shared/schema';
server/routes/dataIntegrity.ts:19:        applications: 'unknown',
server/routes/dataIntegrity.ts:24:        totalApplications: 0,
server/routes/dataIntegrity.ts:27:        incompleteApplications: 0
server/routes/dataIntegrity.ts:38:      const [appResult] = await db.select({ count: count() }).from(applications);
server/routes/dataIntegrity.ts:42:      integrityStatus.checks.applications = 'operational';
server/routes/dataIntegrity.ts:44:      integrityStatus.metrics.totalApplications = appResult.count;
server/routes/dataIntegrity.ts:47:      console.log(`‚úÖ [DATA INTEGRITY] Database: ${appResult.count} applications, ${docResult.count} documents`);
server/routes/dataIntegrity.ts:54:    // 2. Check for orphaned documents (documents without valid applications)
server/routes/dataIntegrity.ts:60:        LEFT JOIN applications a ON d.application_id = a.id
server/routes/dataIntegrity.ts:80:    // 3. Check for incomplete applications (missing form_data or critical fields)
server/routes/dataIntegrity.ts:85:        FROM applications 
server/routes/dataIntegrity.ts:93:      integrityStatus.metrics.incompleteApplications = incompleteCount;
server/routes/dataIntegrity.ts:96:        integrityStatus.recovery.recommendedActions.push(`Review ${incompleteCount} incomplete applications`);
server/routes/dataIntegrity.ts:99:      console.log(`‚úÖ [DATA INTEGRITY] Incomplete applications: ${incompleteCount}`);
server/routes/dataIntegrity.ts:101:      console.error('‚ùå [DATA INTEGRITY] Incomplete applications check failed:', incompleteError);
server/routes/dataIntegrity.ts:148:          WHERE application_id NOT IN (SELECT id FROM applications)
server/routes/dataIntegrity.ts:158:      case 'incomplete-applications':
server/routes/dataIntegrity.ts:161:          action: 'incomplete-applications-review',
server/routes/dataIntegrity.ts:162:          message: 'Incomplete applications flagged for manual review',
server/routes/dataIntegrity.ts:170:          availableTypes: ['orphaned-documents', 'incomplete-applications']
server/utils/dataIntegrityValidator.ts:9:import { applications, documents } from '../../shared/schema';
server/utils/dataIntegrityValidator.ts:24:export async function validateApplicationSubmission(applicationId: string): Promise<DataIntegrityResult> {
server/utils/dataIntegrityValidator.ts:38:    // Get application with documents
server/utils/dataIntegrityValidator.ts:39:    const [application] = await db.select().from(applications).where(eq(applications.id, applicationId));
server/utils/dataIntegrityValidator.ts:41:    if (!application) {
server/utils/dataIntegrityValidator.ts:43:      result.errors.push(`Application ${applicationId} not found`);
server/utils/dataIntegrityValidator.ts:48:    const formData = application.formData || {};
server/utils/dataIntegrityValidator.ts:54:      result.errors.push('Application form_data is empty or missing');
server/utils/dataIntegrityValidator.ts:58:    const applicationDocuments = await db.select()
server/utils/dataIntegrityValidator.ts:60:      .where(eq(documents.applicationId, applicationId));
server/utils/dataIntegrityValidator.ts:62:    result.stats.documentCount = applicationDocuments.length;
server/utils/dataIntegrityValidator.ts:72:    const uploadedCategories = applicationDocuments.map(doc => doc.documentType);
server/utils/dataIntegrityValidator.ts:80:    console.log(`üõ°Ô∏è [DATA INTEGRITY] Application ${applicationId} validation:`, result);
server/utils/dataIntegrityValidator.ts:134:    // Check for submitted applications with missing data
server/utils/dataIntegrityValidator.ts:135:    const submittedApps = await db.select().from(applications).where(eq(applications.status, 'submitted'));
server/utils/dataIntegrityValidator.ts:140:        violations.push(`CRITICAL: Submitted application ${app.id} has empty form_data`);
server/utils/dataIntegrityValidator.ts:143:      const appDocs = await db.select().from(documents).where(eq(documents.applicationId, app.id));
server/utils/dataIntegrityValidator.ts:145:        violations.push(`CRITICAL: Submitted application ${app.id} has only ${appDocs.length} documents`);
server/utils/dataIntegrityValidator.ts:149:    // Check for orphaned documents (documents without applications)
server/utils/dataIntegrityValidator.ts:152:      const [app] = await db.select().from(applications).where(eq(applications.id, doc.applicationId));
server/utils/dataIntegrityValidator.ts:154:        warnings.push(`Orphaned document found: ${doc.id} references non-existent application ${doc.applicationId}`);
server/utils/dataIntegrityValidator.ts:178:    // Get submitted applications count
server/utils/dataIntegrityValidator.ts:179:    const submittedApps = await db.select().from(applications).where(eq(applications.status, 'submitted'));
server/utils/dataIntegrityValidator.ts:186:        : `All ${submittedApps.length} submitted applications pass integrity checks`;
server/utils/dataIntegrityValidator.ts:192:        submittedApplications: submittedApps.length,
server/routes/documentAnalytics.ts:4:import { documents, applications } from "../../shared/schema.js";
server/routes/documentAnalytics.ts:81:    // Application completion rates
server/routes/documentAnalytics.ts:82:    const applicationStats = await db
server/routes/documentAnalytics.ts:84:        status: applications.status,
server/routes/documentAnalytics.ts:87:      .from(applications)
server/routes/documentAnalytics.ts:88:      .where(gte(applications.createdAt, startDate))
server/routes/documentAnalytics.ts:89:      .groupBy(applications.status);
server/routes/documentAnalytics.ts:120:      applications: {
server/routes/documentAnalytics.ts:121:        byStatus: applicationStats,
server/routes/documentAnalytics.ts:122:        completionRate: applicationStats.length > 0 
server/routes/documentAnalytics.ts:123:          ? Math.round(((applicationStats.find(s => s.status === 'submitted')?.count || 0) / 
server/routes/documentAnalytics.ts:124:              applicationStats.reduce((sum, s) => sum + s.count, 0)) * 100)
server/routes/documentAnalytics.ts:139:    const { documentType, applicationId } = req.query;
server/routes/documentAnalytics.ts:147:    if (applicationId) {
server/routes/documentAnalytics.ts:148:      query = query.where(eq(documents.applicationId, applicationId as string));
server/routes/documentAnalytics.ts:222:        ['Document ID', 'File Name', 'Type', 'Size', 'Status', 'Created At', 'Application ID'],
server/routes/documentAnalytics.ts:230:          doc.applicationId
server/routes/documentAnalytics.ts:243:      res.setHeader('Content-Type', 'application/json');
server/routes/ops.schedules.ts:45:      headers: { "Content-Type": "application/json" }
server/routes/ops.schedules.ts:70:            headers: { "Content-Type": "application/json" }, 
server/routes/ops.schedules.ts:85:            headers: { "Content-Type": "application/json" }, 
server/routes/crmPublic.ts:17:      replacement: "/api/contacts with autoCreateContactsFromApplication() service",
server/routes/crmPublic.ts:22:    const { name, email, phone, firstName, lastName, source = "client_portal", applicationId } = req.body;
server/routes/crmPublic.ts:58:    // Log activity if applicationId provided
server/routes/crmPublic.ts:59:    if (applicationId) {
server/routes/crmPublic.ts:60:      console.log(`[CRM PUBLIC] Contact linked to application: ${applicationId}`);
server/routes/debug.ts:3: * Created for STAFF APPLICATION TASK: Dump All Lender Products
server/routes/debug.ts:8:import { applications } from "../../shared/schema";
server/utils/documentRecovery.ts:168:  // Strategy 3: Match by application ID in path
server/utils/documentRecovery.ts:170:    if (filePath.includes(doc.application_id)) {
server/routes/notifications.ts:4:import { scheduledNotifications, users, applications } from '../../shared/schema';
server/routes/notifications.ts:189:        // Users with pending applications
server/routes/notifications.ts:196:        .innerJoin(applications, eq(applications.userId, users.id))
server/routes/notifications.ts:197:        .where(sql`applications.status IN ('pending', 'processing')`);
server/routes/notifications.ts:326:    const { applicationId, type, payload, delayMinutes } = req.body;
server/routes/notifications.ts:328:    if (!applicationId || !type || !payload) {
server/routes/notifications.ts:331:        error: 'applicationId, type, and payload are required'
server/routes/notifications.ts:339:        applicationId,
server/routes/notifications.ts:453:        // Get application owner (assuming userId is in payload or can be derived)
server/routes/notifications.ts:461:              applicationId: notification.applicationId,
server/routes/notifications.ts:468:                title: 'View Application'
server/routes/notifications.ts:530:      .where(eq(scheduledNotifications.applicationId, userId))
server/utils/uuidValidator.ts:54: * Validates and normalizes an application ID
server/utils/uuidValidator.ts:60:    throw new Error('Invalid application ID: must be a non-empty string');
server/utils/uuidValidator.ts:80:  throw new Error(`Invalid application ID format: ${id} (cleaned: ${cleanId})`);
server/utils/uuidValidator.ts:84: * Detects the format of an application ID
server/routes/monitoring.ts:8:import { applications, documents } from '../../shared/schema';
server/routes/monitoring.ts:30:        activeApplications: await getActiveApplicationCount(),
server/routes/monitoring.ts:105:    const result = await db.select({ count: count() }).from(applications);
server/routes/monitoring.ts:175:async function getActiveApplicationCount() {
server/routes/monitoring.ts:179:      .from(applications)
server/routes/monitoring.ts:220:        status: applications.status,
server/routes/monitoring.ts:223:      .from(applications)
server/routes/monitoring.ts:225:      .groupBy(applications.status);
server/routes/monitoring.ts:238:    // Get all application IDs from database
server/routes/monitoring.ts:239:    const dbApplications = await db
server/routes/monitoring.ts:240:      .select({ id: applications.id })
server/routes/monitoring.ts:241:      .from(applications);
server/routes/monitoring.ts:243:    const dbIds = new Set(dbApplications.map(app => `app_prod_${app.id}`));
server/routes/retryUploadHandler.ts:11:router.post("/upload/:applicationId", upload.single("document"), async (req, res) => {
server/routes/retryUploadHandler.ts:12:  const { applicationId } = req.params;
server/routes/retryUploadHandler.ts:16:  if (!file || !documentType || !applicationId) {
server/routes/retryUploadHandler.ts:17:    return res.status(400).json({ success: false, message: "Missing file, type, or applicationId" });
server/routes/retryUploadHandler.ts:22:    const s3Result = await uploadToS3(applicationId, file); // must throw if S3 fails
server/routes/retryUploadHandler.ts:37:      applicationId,
server/utils/autoRecoveryTrigger.ts:13:  applicationId: string;
server/utils/autoRecoveryTrigger.ts:42:    const query = 'SELECT id, file_name, file_path, application_id, file_size, created_at FROM documents';
server/utils/autoRecoveryTrigger.ts:63:          applicationId: doc.application_id || '',
server/utils/autoRecoveryTrigger.ts:75:        console.log(`   ‚îî‚îÄ Application: Unknown Business (${doc.application_id})`);
server/utils/autoRecoveryTrigger.ts:98: * AUTO-TRIGGER 2: Get missing documents for specific application
server/utils/autoRecoveryTrigger.ts:100:export async function getMissingDocumentsForApplication(applicationId: string): Promise<MissingDocumentAlert[]> {
server/utils/autoRecoveryTrigger.ts:101:  console.log(`üîç [AUTO-RECOVERY 1] Checking missing documents for application: ${applicationId}`);
server/utils/autoRecoveryTrigger.ts:106:    // Get all documents for the application using connection pool
server/utils/autoRecoveryTrigger.ts:107:    const query = 'SELECT id, file_name, file_path, application_id, created_at FROM documents WHERE application_id = $1';
server/utils/autoRecoveryTrigger.ts:108:    const dbResult = await pool.query(query, [applicationId]);
server/utils/autoRecoveryTrigger.ts:120:          applicationId: doc.application_id || '',
server/utils/autoRecoveryTrigger.ts:121:          businessName: 'Application Documents',
server/utils/autoRecoveryTrigger.ts:127:        console.log(`üìã [AUTO-RECOVERY 1] Missing in app ${applicationId}: ${doc.file_name}`);
server/utils/autoRecoveryTrigger.ts:134:    console.error(`‚ùå [AUTO-RECOVERY 1] Application scan failed:`, error);
server/routes/ai.ocr.ui.ts:10:r.get("/ai/ocr/:applicationId/groups", async (req, res) => {
server/routes/ai.ocr.ui.ts:12:    const appId = req.params.applicationId;
server/routes/ai.ocr.ui.ts:17:      WHERE application_id=${appId}
server/routes/ai.ocr.ui.ts:29:r.get("/ai/ocr/:applicationId/conflicts", async (req, res) => {
server/routes/ai.ocr.ui.ts:31:    const appId = req.params.applicationId;
server/routes/ai.ocr.ui.ts:36:      WHERE f.application_id=${appId}
server/routes/ai.ocr.ui.ts:43:      WHERE application_id=${appId}
server/routes/microsoftGraphContactCard.ts:2: * Microsoft Graph/Office 365 Integration for CRM Contact Card
server/routes/microsoftGraphContactCard.ts:103:        'Content-Type': 'application/x-www-form-urlencoded'
server/routes/microsoftGraphContactCard.ts:256:        'Content-Type': 'application/json'
server/routes/microsoftGraphContactCard.ts:511:    service: 'Microsoft Graph Contact Card Integration',
server/utils/documentValidator.ts:1:// Document validation utility for staff application
server/utils/documentValidator.ts:7: * Validates if all required documents are uploaded for an application
server/utils/documentValidator.ts:8: * @param appDocs - Array of uploaded documents for the application
server/utils/documentValidator.ts:18: * Checks if application has all required documents
server/utils/documentValidator.ts:19: * @param appDocs - Array of uploaded documents for the application
server/utils/documentValidator.ts:30: * @param appDocs - Array of uploaded documents for the application
server/routes/marketing-reports.ts:120:      res.setHeader('Content-Type', 'application/pdf');
server/routes/marketing-campaigns.ts:103:      { stage: 'Application Started', users: 3240, dropoffRate: 63.7 },
server/routes/marketing-campaigns.ts:105:      { stage: 'Application Submitted', users: 1456, dropoffRate: 23.0 },
server/routes/marketing-campaigns.ts:129:      { path: 'Google Ads ‚Üí Landing Page ‚Üí Application', conversions: 234, value: 15600 },
server/routes/marketing-campaigns.ts:131:      { path: 'Facebook Ads ‚Üí Homepage ‚Üí Application', conversions: 156, value: 11200 },
server/routes/marketing-campaigns.ts:132:      { path: 'Email Campaign ‚Üí Product Page ‚Üí Application', conversions: 134, value: 9800 },
server/routes/marketing-campaigns.ts:133:      { path: 'LinkedIn Ads ‚Üí Demo Request ‚Üí Application', conversions: 98, value: 8900 },
server/routes/marketing-campaigns.ts:134:      { path: 'Direct ‚Üí Homepage ‚Üí Application', conversions: 87, value: 7600 },
server/routes/marketing-campaigns.ts:135:      { path: 'YouTube Ads ‚Üí Video ‚Üí Application', conversions: 76, value: 6400 },
server/routes/marketing-campaigns.ts:136:      { path: 'Referral ‚Üí Homepage ‚Üí Application', conversions: 45, value: 4200 },
server/routes/marketing-campaigns.ts:137:      { path: 'Instagram Ads ‚Üí Landing Page ‚Üí Application', conversions: 34, value: 3100 },
server/routes/marketing-campaigns.ts:138:      { path: 'Bing Ads ‚Üí Product Page ‚Üí Application', conversions: 23, value: 2800 }
server/routes/pipeline.bulk.ts:9:// Bulk update applications
server/routes/pipeline.bulk.ts:10:r.patch("/pipeline/bulk", async (req: any, res) => {
server/routes/pipeline.bulk.ts:18:      await db.execute(sql`UPDATE applications SET stage=${to} WHERE id = ANY(${ids})`);
server/routes/pipeline.bulk.ts:21:      await db.execute(sql`UPDATE applications SET owner_id=${owner} WHERE id = ANY(${ids})`);
server/routes/pipeline.bulk.ts:30:// Bulk SMS to applications
server/routes/pipeline.bulk.ts:31:r.post("/pipeline/bulk/sms", async (req: any, res) => {
server/routes/pipeline.bulk.ts:38:      FROM applications a 
server/routes/pipeline.bulk.ts:50:            headers: { "Content-Type": "application/json" },
server/utils/startupAuditSafe.ts:43:            applicationId: doc.applicationId
server/utils/startupAuditSafe.ts:52:            applicationId: doc.applicationId,
server/utils/startupAuditSafe.ts:83:      applicationId: 'SYSTEM',
server/routes/audit.export.ts:10:r.get("/audit/application/:id/export.zip", async (req, res) => {
server/routes/audit.export.ts:13:    const app = await db.execute(sql`SELECT * FROM applications WHERE id=${appId} LIMIT 1`);
server/routes/audit.export.ts:19:      WHERE application_id=${appId} 
server/routes/audit.export.ts:26:      WHERE application_id=${appId} 
server/routes/audit.export.ts:32:      WHERE application_id=${appId} 
server/routes/audit.export.ts:36:    res.setHeader("Content-Type", "application/zip");
server/routes/audit.export.ts:46:    archive.append(JSON.stringify(app.rows[0], null, 2), { name: "application.json" });
server/utils/generateBusinessPdf.ts:7:export async function generateBusinessPdf(documentData: any, applicationData: any): Promise<Buffer> {
server/utils/generateBusinessPdf.ts:46:  if (applicationData) {
server/utils/generateBusinessPdf.ts:57:      ['Business Name:', applicationData.legal_business_name || 'N/A'],
server/utils/generateBusinessPdf.ts:58:      ['Contact Name:', `${applicationData.contact_first_name || ''} ${applicationData.contact_last_name || ''}`.trim()],
server/utils/generateBusinessPdf.ts:59:      ['Email:', applicationData.contact_email || 'N/A'],
server/utils/generateBusinessPdf.ts:60:      ['Phone:', applicationData.contact_phone || 'N/A'],
server/utils/generateBusinessPdf.ts:61:      ['Business Type:', applicationData.business_entity_type || 'N/A'],
server/utils/generateBusinessPdf.ts:62:      ['Requested Amount:', applicationData.requested_amount ? `$${applicationData.requested_amount.toLocaleString()}` : 'N/A'],
server/utils/generateBusinessPdf.ts:63:      ['Use of Funds:', applicationData.use_of_funds || 'N/A']
server/utils/generateBusinessPdf.ts:144:  page.drawText('This document was automatically regenerated from stored application data.', {
server/utils/generateBusinessPdf.ts:157: * Get application data for PDF generation
server/utils/generateBusinessPdf.ts:159:export async function getApplicationDataForPdf(applicationId: string): Promise<any> {
server/utils/generateBusinessPdf.ts:170:      FROM applications 
server/utils/generateBusinessPdf.ts:172:    `, [applicationId]);
server/utils/generateBusinessPdf.ts:176:    console.error('‚ùå [PDF GENERATION] Failed to get application data:', error);
server/routes/marketing-abtests.ts:69:            name: 'Control - "Your Loan Application Update"',
server/routes/marketing-abtests.ts:96:        name: 'Application Form Length Test',
server/routes/o365.mailbox.ts:11:    headers["Content-Type"] = "application/json";
server/utils/documentBuffer.ts:28:export async function uploadDocumentBuffer(documentId: string, buffer: Buffer, contentType: string = 'application/pdf'): Promise<string> {
server/utils/uploadPersistenceValidator.ts:106:  applicationId: string
server/utils/uploadPersistenceValidator.ts:111:  const logEntry = `${timestamp} | ${status} | VALIDATION | DocumentID: ${documentId}, File: ${fileName}, Application: ${applicationId}, Size: ${validation.actualSize}, Checksum: ${validation.checksumVerified}, Disk: ${validation.diskAccessible}, Error: ${validation.error || 'None'}\n`;
server/routes/reports.pdf.ts:108:    res.setHeader('Content-Type', 'application/pdf');
server/routes/reports.pdf.ts:146:        <tr><th>Application ID</th><th>Document Type</th><th>Status</th><th>Uploaded</th></tr>
server/routes/reports.pdf.ts:159:    res.setHeader('Content-Type', 'application/pdf');
server/routes/reports.pdf.ts:192:        <div class="action">Updated application APP-001 status to "In Review"</div>
server/routes/reports.pdf.ts:213:    res.setHeader('Content-Type', 'application/pdf');
server/utils/documentAccessibility.ts:7: * @param applicationId - The application ID to help locate the file
server/utils/documentAccessibility.ts:11:export async function checkDocumentAccessible(filePath: string, applicationId?: string, fileName?: string): Promise<boolean> {
server/utils/documentAccessibility.ts:21:    // Try application-specific directory structure which is the main storage pattern
server/utils/documentAccessibility.ts:24:    // Extract potential application ID from file path or use provided applicationId
server/utils/documentAccessibility.ts:26:    const possibleAppId = applicationId || pathParts.find(part => 
server/utils/documentAccessibility.ts:31:      // Primary pattern: uploads/{applicationId}/{filename} - this is where files actually are
server/utils/documentAccessibility.ts:33:      // Search for files that start with applicationId (prefixed filenames)
server/utils/documentAccessibility.ts:37:      filePath.replace('uploads/documents/', 'uploads/applications/'),
server/utils/documentAccessibility.ts:42:      // Applications subdirectory  
server/utils/documentAccessibility.ts:43:      possibleAppId ? `uploads/applications/${possibleAppId}/${fileBaseName}` : null
server/utils/documentAccessibility.ts:111:        doc.applicationId || doc.application_id,
server/routes/publicApplications.ts:4:// Import all application route handlers
server/routes/publicApplications.ts:5:import applicationsCreateRouter from './applications/create';
server/routes/publicApplications.ts:6:import applicationsSubmitRouter from './applications/submit';
server/routes/publicApplications.ts:7:import applicationsUploadRouter from './applications/upload';
server/routes/publicApplications.ts:9:import applicationsCompleteRouter from './applications/complete';
server/routes/publicApplications.ts:17:  console.log(`üîç PUBLIC APPLICATIONS ROUTER: ${req.method} ${req.originalUrl} - Base: ${req.baseUrl}, Path: ${req.path}`);
server/routes/publicApplications.ts:29:// Mount create application route (handles POST /) with enhanced debugging
server/routes/publicApplications.ts:30:console.log('üöÄ Mounting applications create router...');
server/routes/publicApplications.ts:31:router.use('/', applicationsCreateRouter);
server/routes/publicApplications.ts:32:router.use('/test', applicationsCreateRouter);
server/routes/publicApplications.ts:33:console.log('‚úÖ Applications create router mounted successfully');
server/routes/publicApplications.ts:35:// Mount submit application route
server/routes/publicApplications.ts:36:router.use('/', applicationsSubmitRouter);
server/routes/publicApplications.ts:38:// Mount upload route (note: this goes to /upload path, not /applications)
server/routes/publicApplications.ts:39:router.use('/upload', applicationsUploadRouter);
server/routes/publicApplications.ts:43:// Mount complete application route
server/routes/publicApplications.ts:44:router.use('/', applicationsCompleteRouter);
server/routes/publicApplications.ts:46:// Mount finalize application route (for lender matching transition)
server/routes/publicApplications.ts:47:import applicationsFinalizeRouter from './applications/finalize';
server/routes/publicApplications.ts:48:router.use('/', applicationsFinalizeRouter);
server/routes/publicApplications.ts:55:router.get('/debug/applications/:id', async (req, res) => {
server/routes/publicApplications.ts:66:    const { applications } = await import('../../shared/schema');
server/routes/publicApplications.ts:71:      .from(applications)
server/routes/publicApplications.ts:72:      .where(eq(applications.id, id))
server/routes/publicApplications.ts:76:      return res.status(404).json({ error: 'Application not found' });
server/routes/publicApplications.ts:81:      applicationId: app.id,
server/routes/publicApplications.ts:91:// Add missing GET /:id endpoint for application retrieval
server/routes/publicApplications.ts:101:        error: 'Invalid application ID format'
server/routes/publicApplications.ts:105:    // Fetch application from database
server/routes/publicApplications.ts:107:    const { applications, businesses } = await import('../../shared/schema');
server/routes/publicApplications.ts:110:    const [application] = await db
server/routes/publicApplications.ts:112:      .from(applications)
server/routes/publicApplications.ts:113:      .where(eq(applications.id, id))
server/routes/publicApplications.ts:116:    if (!application) {
server/routes/publicApplications.ts:119:        error: 'Application not found'
server/routes/publicApplications.ts:125:    if (application.businessId) {
server/routes/publicApplications.ts:129:        .where(eq(businesses.id, application.businessId))
server/routes/publicApplications.ts:138:        id: application.id,
server/routes/publicApplications.ts:139:        status: application.status,
server/routes/publicApplications.ts:140:        contactEmail: application.contactEmail,
server/routes/publicApplications.ts:141:        requestedAmount: application.requestedAmount,
server/routes/publicApplications.ts:142:        loanPurpose: application.loanPurpose,
server/routes/publicApplications.ts:150:        createdAt: application.createdAt,
server/routes/publicApplications.ts:151:        updatedAt: application.updatedAt
server/routes/publicApplications.ts:163:    console.error('Error fetching public application:', error);
server/routes/industry-benchmarking.ts:40: * POST /api/benchmarking/analyze/:applicationId
server/routes/industry-benchmarking.ts:41: * Run comprehensive industry benchmarking analysis for an application
server/routes/industry-benchmarking.ts:43:router.post('/analyze/:applicationId', simpleAuth, async (req, res) => {
server/routes/industry-benchmarking.ts:47:    const applicationId = req.params.applicationId;
server/routes/industry-benchmarking.ts:48:    console.log(`üîç Starting industry benchmarking analysis for application: ${applicationId}`);
server/routes/industry-benchmarking.ts:50:    // Get application data from database
server/routes/industry-benchmarking.ts:51:    const applicationResult = await pool.query(`
server/routes/industry-benchmarking.ts:55:      FROM business_loan_applications 
server/routes/industry-benchmarking.ts:57:    `, [applicationId]);
server/routes/industry-benchmarking.ts:59:    if (applicationResult.rows.length === 0) {
server/routes/industry-benchmarking.ts:62:        error: 'Application not found' 
server/routes/industry-benchmarking.ts:66:    const application = applicationResult.rows[0];
server/routes/industry-benchmarking.ts:72:      WHERE application_id = $1
server/routes/industry-benchmarking.ts:75:    `, [applicationId]);
server/routes/industry-benchmarking.ts:81:      monthlyRevenue: (application.annual_revenue || 0) / 12,
server/routes/industry-benchmarking.ts:82:      monthlyExpenses: (application.annual_expenses || (application.annual_revenue * 0.8)) / 12,
server/routes/industry-benchmarking.ts:84:                   ((application.annual_revenue - (application.annual_expenses || 0)) / application.annual_revenue),
server/routes/industry-benchmarking.ts:86:      debtToRevenueRatio: (application.existing_debt || 0) / (application.annual_revenue || 1),
server/routes/industry-benchmarking.ts:88:      businessAge: application.years_in_business || 1,
server/routes/industry-benchmarking.ts:89:      employeeCount: application.employee_count || 5
server/routes/industry-benchmarking.ts:95:      application.industry || 'general'
server/routes/industry-benchmarking.ts:101:        application_id, industry, applicant_monthly_revenue, applicant_monthly_expenses,
server/routes/industry-benchmarking.ts:118:      ) ON CONFLICT (application_id) DO UPDATE SET
server/routes/industry-benchmarking.ts:126:      applicationId, benchmarkResult.industryBenchmark.industry,
server/routes/industry-benchmarking.ts:186: * GET /api/benchmarking/results/:applicationId
server/routes/industry-benchmarking.ts:187: * Get stored benchmark comparison results for an application
server/routes/industry-benchmarking.ts:189:router.get('/results/:applicationId', simpleAuth, async (req, res) => {
server/routes/industry-benchmarking.ts:191:    const applicationId = req.params.applicationId;
server/routes/industry-benchmarking.ts:195:      WHERE application_id = $1
server/routes/industry-benchmarking.ts:198:    `, [applicationId]);
server/routes/industry-benchmarking.ts:203:        message: 'No benchmark analysis found for this application',
server/routes/industry-benchmarking.ts:425:          COUNT(*) as applications,
server/routes/industry-benchmarking.ts:469: * Analyze multiple applications in bulk
server/routes/industry-benchmarking.ts:473:    const { applicationIds } = req.body;
server/routes/industry-benchmarking.ts:475:    if (!Array.isArray(applicationIds) || applicationIds.length === 0) {
server/routes/industry-benchmarking.ts:478:        error: 'applicationIds array is required'
server/routes/industry-benchmarking.ts:482:    if (applicationIds.length > 50) {
server/routes/industry-benchmarking.ts:485:        error: 'Maximum 50 applications can be analyzed in bulk'
server/routes/industry-benchmarking.ts:492:    for (const applicationId of applicationIds) {
server/routes/industry-benchmarking.ts:495:        const response = await fetch(`http://localhost:5000/api/benchmarking/analyze/${applicationId}`, {
server/routes/industry-benchmarking.ts:498:            'Content-Type': 'application/json',
server/routes/industry-benchmarking.ts:506:            applicationId,
server/routes/industry-benchmarking.ts:513:            applicationId,
server/routes/industry-benchmarking.ts:519:          applicationId,
server/routes/industry-benchmarking.ts:534:        totalRequested: applicationIds.length,
server/routes/industry-benchmarking.ts:535:        successRate: (results.length / applicationIds.length) * 100,
server/routes/industry-benchmarking.ts:550: * POST /api/benchmarking/generate-report/:applicationId
server/routes/industry-benchmarking.ts:553:router.post('/generate-report/:applicationId', simpleAuth, async (req, res) => {
server/routes/industry-benchmarking.ts:555:    const applicationId = req.params.applicationId;
server/routes/industry-benchmarking.ts:558:    const resultsResponse = await fetch(`http://localhost:5000/api/benchmarking/results/${applicationId}`, {
server/routes/industry-benchmarking.ts:576:      applicationId,
server/routes/webhooks.graph.ts:13:  // TODO: pull /me/messages delta or events; existing inbox pipeline can consume
server/routes/healthCheck.ts:4:import { applications, documents } from '../../shared/schema';
server/routes/healthCheck.ts:26:        applicationCount: 0,
server/routes/healthCheck.ts:34:      const [appResult] = await db.select({ count: count() }).from(applications);
server/routes/healthCheck.ts:38:      healthStatus.metrics.applicationCount = appResult.count;
server/routes/healthCheck.ts:41:      console.log(`‚úÖ [HEALTH] Database: ${appResult.count} applications, ${docResult.count} documents`);
server/routes/healthCheck.ts:115:        'backup_applications_20250125',
server/utils/uiRecoveryValidator.ts:128: * AUTO-RECOVERY 3: Validate UI for all documents in an application
server/utils/uiRecoveryValidator.ts:130:export async function validateApplicationDocumentsUI(applicationId: string): Promise<RecoveryUIStatus> {
server/utils/uiRecoveryValidator.ts:131:  console.log(`üìã [AUTO-RECOVERY 3] Validating UI for all documents in application: ${applicationId}`);
server/utils/uiRecoveryValidator.ts:141:    // Get all documents for the application
server/utils/uiRecoveryValidator.ts:145:      .where(eq(documents.application_id, applicationId));
server/utils/uiRecoveryValidator.ts:163:    console.log(`‚úÖ [AUTO-RECOVERY 3] Application ${applicationId} validation complete:`);
server/utils/uiRecoveryValidator.ts:171:    console.error(`‚ùå [AUTO-RECOVERY 3] Application validation failed:`, error);
server/routes/pipelineBoard.ts:5:// Mock data for BF pipeline board (until database is properly connected)
server/routes/pipelineBoard.ts:6:const mockBfApplications = [
server/routes/pipelineBoard.ts:55: * GET /api/pipeline/board
server/routes/pipelineBoard.ts:56: * Get all applications formatted for pipeline board view (BF silo)
server/routes/pipelineBoard.ts:60:    console.log('üìã [PIPELINE-BOARD] Fetching BF applications for pipeline board...');
server/routes/pipelineBoard.ts:63:    const boardData = mockBfApplications.map(app => ({
server/routes/pipelineBoard.ts:72:    console.log(`üìã [PIPELINE-BOARD] Returning ${boardData.length} BF applications`);
server/routes/pipelineBoard.ts:76:    console.error('‚ùå [PIPELINE-BOARD] Error fetching board data:', error);
server/routes/pipelineBoard.ts:79:      error: 'Failed to load pipeline board'
server/routes/pipelineBoard.ts:85: * GET /api/pipeline/board/summary
server/routes/pipelineBoard.ts:86: * Get pipeline stage summary counts (BF silo)
server/routes/pipelineBoard.ts:90:    console.log('üìä [PIPELINE-BOARD] Fetching stage summary...');
server/routes/pipelineBoard.ts:94:    for (const app of mockBfApplications) {
server/routes/pipelineBoard.ts:105:    console.log('üìä [PIPELINE-BOARD] Stage summary:', summary);
server/routes/pipelineBoard.ts:109:    console.error('‚ùå [PIPELINE-BOARD] Error fetching summary:', error);
server/routes/pipelineBoard.ts:112:      error: 'Failed to load pipeline summary'
server/routes/fraud-detection.ts:76: * POST /api/fraud/cross-application/:applicationId
server/routes/fraud-detection.ts:77: * Run cross-application fraud analysis
server/routes/fraud-detection.ts:79:router.post('/cross-application/:applicationId', simpleAuth, async (req, res) => {
server/routes/fraud-detection.ts:83:    const { applicationId } = req.params;
server/routes/fraud-detection.ts:85:    console.log(`üîç Starting cross-application fraud analysis for ${applicationId}`);
server/routes/fraud-detection.ts:87:    const result = await fraudService.analyzeApplication(applicationId);
server/routes/fraud-detection.ts:89:    console.log(`‚úÖ Application ${applicationId} fraud analysis completed: ${result.overallFraudScore}/100 score`);
server/routes/fraud-detection.ts:105:    console.error(`‚ùå Error analyzing application ${req.params.applicationId}:`, error);
server/routes/fraud-detection.ts:110:        applicationId: req.params.applicationId,
server/routes/fraud-detection.ts:190: * Get flagged applications requiring manual review
server/routes/fraud-detection.ts:194:    console.log('üö© Retrieving flagged applications');
server/routes/fraud-detection.ts:196:    const flagged = await fraudService.getFlaggedApplications();
server/routes/fraud-detection.ts:208:    console.error('‚ùå Error getting flagged applications:', error);
server/utils/security.ts:60:  applicationId: z.string().uuid('Invalid application ID'),
server/utils/security.ts:65:      'application/pdf',
server/utils/security.ts:69:      'application/msword',
server/utils/security.ts:70:      'application/vnd.openxmlformats-officedocument.wordprocessingml.document',
server/utils/security.ts:71:      'application/vnd.ms-excel',
server/utils/security.ts:72:      'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet'
server/routes/pipelineAutomation.ts:2: * üöÄ PIPELINE AUTOMATION ENDPOINTS
server/routes/pipelineAutomation.ts:3: * Manual triggers for testing the enhanced pipeline service and SMS integration
server/routes/pipelineAutomation.ts:7:import { PipelineService } from '../services/pipelineService';
server/routes/pipelineAutomation.ts:13: * POST /api/pipeline-automation/evaluate/:applicationId
server/routes/pipelineAutomation.ts:14: * Manually trigger pipeline evaluation for an application
server/routes/pipelineAutomation.ts:16:router.post('/evaluate/:applicationId', async (req, res) => {
server/routes/pipelineAutomation.ts:18:    const { applicationId } = req.params;
server/routes/pipelineAutomation.ts:20:    console.log(`üîÑ [PIPELINE-AUTO] Manual evaluation trigger for application: ${applicationId}`);
server/routes/pipelineAutomation.ts:22:    const evaluation = await PipelineService.evaluateApplicationStage(applicationId);
server/routes/pipelineAutomation.ts:27:      message: 'Pipeline evaluation completed'
server/routes/pipelineAutomation.ts:31:    console.error('‚ùå [PIPELINE-AUTO] Evaluation error:', error);
server/routes/pipelineAutomation.ts:34:      error: error instanceof Error ? error.message : 'Failed to evaluate application'
server/routes/pipelineAutomation.ts:40: * POST /api/pipeline-automation/apply/:applicationId
server/routes/pipelineAutomation.ts:41: * Apply pipeline evaluation and update stage
server/routes/pipelineAutomation.ts:43:router.post('/apply/:applicationId', async (req, res) => {
server/routes/pipelineAutomation.ts:45:    const { applicationId } = req.params;
server/routes/pipelineAutomation.ts:47:    console.log(`üîÑ [PIPELINE-AUTO] Applying pipeline fix for application: ${applicationId}`);
server/routes/pipelineAutomation.ts:49:    const result = await PipelineService.evaluateAndUpdateStage(applicationId);
server/routes/pipelineAutomation.ts:54:      message: result.stageUpdated ? 'Pipeline stage updated successfully' : 'No stage update needed'
server/routes/pipelineAutomation.ts:58:    console.error('‚ùå [PIPELINE-AUTO] Apply error:', error);
server/routes/pipelineAutomation.ts:61:      error: error instanceof Error ? error.message : 'Failed to apply pipeline changes'
server/routes/pipelineAutomation.ts:67: * POST /api/pipeline-automation/batch-fix
server/routes/pipelineAutomation.ts:68: * Fix all misclassified applications
server/routes/pipelineAutomation.ts:72:    console.log(`üîÑ [PIPELINE-AUTO] Starting batch pipeline fix for all applications`);
server/routes/pipelineAutomation.ts:74:    await PipelineService.processAllApplications();
server/routes/pipelineAutomation.ts:78:      message: 'Batch pipeline fix completed successfully'
server/routes/pipelineAutomation.ts:82:    console.error('‚ùå [PIPELINE-AUTO] Batch fix error:', error);
server/routes/pipelineAutomation.ts:91: * POST /api/pipeline-automation/update/:applicationId
server/routes/pipelineAutomation.ts:92: * Manually trigger pipeline update (evaluate + update if needed)
server/routes/pipelineAutomation.ts:94:router.post('/update/:applicationId', async (req, res) => {
server/routes/pipelineAutomation.ts:96:    const { applicationId } = req.params;
server/routes/pipelineAutomation.ts:98:    console.log(`üîÑ [PIPELINE-AUTO] Manual pipeline update for application: ${applicationId}`);
server/routes/pipelineAutomation.ts:100:    await PipelineService.evaluateAndUpdateStage(applicationId);
server/routes/pipelineAutomation.ts:104:      message: 'Pipeline update completed successfully'
server/routes/pipelineAutomation.ts:108:    console.error('‚ùå [PIPELINE-AUTO] Update error:', error);
server/routes/pipelineAutomation.ts:111:      error: error instanceof Error ? error.message : 'Failed to update application pipeline'
server/routes/pipelineAutomation.ts:117: * POST /api/pipeline-automation/test-sms/:applicationId
server/routes/pipelineAutomation.ts:120:router.post('/test-sms/:applicationId', async (req, res) => {
server/routes/pipelineAutomation.ts:122:    const { applicationId } = req.params;
server/routes/pipelineAutomation.ts:132:    console.log(`üì± [PIPELINE-AUTO] Testing SMS template: ${templateType} for application: ${applicationId}`);
server/routes/pipelineAutomation.ts:134:    const result = await sendEnhancedSMS(applicationId, templateType, customData);
server/routes/pipelineAutomation.ts:139:    console.error('‚ùå [PIPELINE-AUTO] SMS test error:', error);
server/routes/pipelineAutomation.ts:148: * POST /api/pipeline-automation/simulate-stage-change
server/routes/pipelineAutomation.ts:153:    const { applicationId, fromStage, toStage } = req.body;
server/routes/pipelineAutomation.ts:155:    if (!applicationId || !toStage) {
server/routes/pipelineAutomation.ts:158:        error: 'applicationId and toStage are required'
server/routes/pipelineAutomation.ts:162:    console.log(`üé≠ [PIPELINE-AUTO] Simulating stage change: ${applicationId} from ${fromStage} to ${toStage}`);
server/routes/pipelineAutomation.ts:183:    const smsResult = await sendEnhancedSMS(applicationId, templateType);
server/routes/pipelineAutomation.ts:194:    console.error('‚ùå [PIPELINE-AUTO] Simulation error:', error);
server/routes/ocrManualTrigger.ts:3: * For processing existing applications that missed auto-trigger
server/routes/ocrManualTrigger.ts:13: * POST /api/ocr-trigger/application/:applicationId
server/routes/ocrManualTrigger.ts:14: * Manual trigger for OCR processing on all bank statements for an application
server/routes/ocrManualTrigger.ts:16:router.post('/application/:applicationId', async (req, res) => {
server/routes/ocrManualTrigger.ts:18:    const { applicationId } = req.params;
server/routes/ocrManualTrigger.ts:20:    console.log(`üîç [OCR-TRIGGER] Starting manual OCR processing for application: ${applicationId}`);
server/routes/ocrManualTrigger.ts:22:    // Get all bank statement documents for the application
server/routes/ocrManualTrigger.ts:26:      WHERE application_id = ${applicationId}
server/routes/ocrManualTrigger.ts:34:        error: 'No bank statement documents found for this application'
server/routes/ocrManualTrigger.ts:52:          applicationId: applicationId,
server/routes/ocrManualTrigger.ts:64:            application_id,
server/routes/ocrManualTrigger.ts:72:            ${applicationId},
server/routes/ocrManualTrigger.ts:105:        console.log(`üè¶ [OCR-TRIGGER] Triggering banking analysis for application: ${applicationId}`);
server/routes/ocrManualTrigger.ts:108:        const bankingResponse = await fetch(`http://localhost:5000/api/banking-analysis/${applicationId}`, {
server/routes/ocrManualTrigger.ts:111:            'Content-Type': 'application/json',
server/routes/ocrManualTrigger.ts:129:      applicationId,
server/routes/ocrManualTrigger.ts:146: * POST /api/ocr-trigger/banking-analysis/:applicationId
server/routes/ocrManualTrigger.ts:149:router.post('/banking-analysis/:applicationId', async (req, res) => {
server/routes/ocrManualTrigger.ts:151:    const { applicationId } = req.params;
server/routes/ocrManualTrigger.ts:153:    console.log(`üè¶ [BANKING-TRIGGER] Starting manual banking analysis for application: ${applicationId}`);
server/routes/ocrManualTrigger.ts:159:      WHERE application_id = ${applicationId}
server/routes/ocrManualTrigger.ts:172:    const bankingResponse = await fetch(`http://localhost:5000/api/banking-analysis/${applicationId}`, {
server/routes/ocrManualTrigger.ts:175:        'Content-Type': 'application/json',
server/routes/ocrManualTrigger.ts:185:      applicationId,
server/routes/ocrManualTrigger.ts:200: * GET /api/ocr-trigger/status/:applicationId
server/routes/ocrManualTrigger.ts:201: * Check OCR and banking analysis status for an application
server/routes/ocrManualTrigger.ts:203:router.get('/status/:applicationId', async (req, res) => {
server/routes/ocrManualTrigger.ts:205:    const { applicationId } = req.params;
server/routes/ocrManualTrigger.ts:211:      WHERE application_id = ${applicationId}
server/routes/ocrManualTrigger.ts:218:      WHERE application_id = ${applicationId}
server/routes/ocrManualTrigger.ts:226:      WHERE application_id = ${applicationId}
server/routes/ocrManualTrigger.ts:230:      applicationId,
server/routes/schedule.ts:34:    method:"POST", headers:{ Authorization:`Bearer ${token}`, "Content-Type":"application/json" },
server/routes/schedule.ts:92:    method:"POST", headers:{ Authorization:`Bearer ${token}`, "Content-Type":"application/json" },
server/routes/persistenceValidation.ts:31:    const { applicationId, documentType, uploadedBy } = req.body;
server/routes/persistenceValidation.ts:46:      applicationId,
server/routes/persistenceValidation.ts:59:          applicationId,
server/utils/documentAudit.ts:19:    applicationId: string;
server/utils/documentAudit.ts:50:          applicationId: doc.application_id,
server/utils/documentAudit.ts:144: * Audit documents for a specific application
server/utils/documentAudit.ts:146:export async function auditApplicationDocuments(applicationId: string): Promise<DocumentAuditResult> {
server/utils/documentAudit.ts:147:  console.log(`üîç Auditing documents for application: ${applicationId}`);
server/utils/documentAudit.ts:150:    // Get documents for this application
server/utils/documentAudit.ts:153:      .where(eq(documents.application_id, applicationId));
server/utils/documentAudit.ts:167:          applicationId: doc.application_id,
server/utils/documentAudit.ts:178:      orphanedFiles: [], // Not applicable for single application audit
server/utils/documentAudit.ts:179:      summary: `Application ${applicationId}: ${filesFound}/${appDocuments.length} files found, ${missingDocuments.length} missing`
server/utils/documentAudit.ts:186:    console.error(`‚ùå Application document audit failed for ${applicationId}:`, error);
server/routes/ocrInsights.ts:20: * GET /api/ocr-insights/:applicationId
server/routes/ocrInsights.ts:21: * Get comprehensive OCR insights for an application
server/routes/ocrInsights.ts:23:router.get('/:applicationId', async (req, res) => {
server/routes/ocrInsights.ts:25:    const { applicationId } = req.params;
server/routes/ocrInsights.ts:27:    console.log(`üîç [OCR-INSIGHTS-API] Fetching OCR insights for application ${applicationId}`);
server/routes/ocrInsights.ts:29:    const insights = await processOCRInsights(applicationId);
server/routes/ocrInsights.ts:33:      applicationId,
server/routes/ocrInsights.ts:39:    console.error(`‚ùå [OCR-INSIGHTS-API] Failed to get insights for ${req.params.applicationId}:`, error);
server/routes/ocrInsights.ts:50: * Run comprehensive OCR analysis on all applications
server/routes/ocrInsights.ts:76: * POST /api/ocr-insights/reprocess/:applicationId
server/routes/ocrInsights.ts:77: * Force reprocessing of OCR insights for an application
server/routes/ocrInsights.ts:79:router.post('/reprocess/:applicationId', async (req, res) => {
server/routes/ocrInsights.ts:81:    const { applicationId } = req.params;
server/routes/ocrInsights.ts:83:    console.log(`üîÑ [OCR-INSIGHTS-API] Reprocessing OCR insights for application ${applicationId}`);
server/routes/ocrInsights.ts:86:    const insights = await processOCRInsights(applicationId);
server/routes/ocrInsights.ts:91:      applicationId,
server/routes/ocrInsights.ts:97:    console.error(`‚ùå [OCR-INSIGHTS-API] Failed to reprocess ${req.params.applicationId}:`, error);
server/routes/twilio.disabled.ts:4: * Staff Application endpoints for all Twilio communications:
server/routes/twilio.disabled.ts:273:    const message = req.body.message || 'Hello from Boreal Financial Staff Application. This is a test call.';
server/routes/pdfGeneration.ts:2:import { generateSignedApplicationPdf } from '../services/simplePdfGenerator';
server/routes/pdfGeneration.ts:6:// POST /api/applications/:id/generate-pdf - Generate signed application PDF
server/routes/pdfGeneration.ts:9:    const { id: applicationId } = req.params;
server/routes/pdfGeneration.ts:11:    console.log(`üìÑ [PDF API] Generating PDF for application: ${applicationId}`);
server/routes/pdfGeneration.ts:13:    if (!applicationId) {
server/routes/pdfGeneration.ts:16:        error: 'Application ID is required'
server/routes/pdfGeneration.ts:20:    const result = await generateSignedApplicationPdf(applicationId);
server/routes/pdfGeneration.ts:22:    console.log(`‚úÖ [PDF API] PDF generation completed for: ${applicationId}`);
server/routes/twilioDebug.ts:128:      'Restart/redeploy application after adding secrets',
server/routes/adminUploadDashboard.ts:61:        d.application_id,
server/routes/adminUploadDashboard.ts:191:      SELECT id, application_id, file_name, file_path, storage_status
server/routes/ai.banking.ts:7:// Time-series banking metrics for an application
server/routes/ai.banking.ts:8:r.get("/ai/banking/:applicationId/series", async (req, res) => {
server/routes/ai.banking.ts:9:  const appId = req.params.applicationId;
server/routes/ai.banking.ts:18:    where application_id=${appId} and posted_at>=${since}
server/routes/twilioContactCard.ts:2: * Twilio Integration for CRM Contact Card
server/routes/twilioContactCard.ts:24: * POST /api/twilio/contact-card/call
server/routes/twilioContactCard.ts:43:      url: getCallbackUrl('/api/twilio/contact-card/twiml', req),
server/routes/twilioContactCard.ts:47:      statusCallback: getCallbackUrl('/api/twilio/contact-card/call-status', req),
server/routes/twilioContactCard.ts:108: * POST /api/twilio/contact-card/twiml
server/routes/twilioContactCard.ts:125:    recordingStatusCallback: getCallbackUrl('/api/twilio/contact-card/recording-status', req)
server/routes/twilioContactCard.ts:133: * POST /api/twilio/contact-card/call-status
server/routes/twilioContactCard.ts:192: * POST /api/twilio/contact-card/sms/send
server/routes/twilioContactCard.ts:221:      statusCallback: getCallbackUrl('/api/twilio/contact-card/sms-status', req)
server/routes/twilioContactCard.ts:281: * POST /api/twilio/contact-card/sms-status
server/routes/twilioContactCard.ts:310: * POST /api/twilio/contact-card/sms-inbound
server/routes/twilioContactCard.ts:392: * GET /api/twilio/contact-card/sms/conversations/:contactId
server/routes/twilioContactCard.ts:434:    service: 'Twilio Contact Card Integration',
server/utils/idHelpers.ts:10:export function normalizeToUUID(applicationId: string): string {
server/utils/idHelpers.ts:11:  return applicationId.replace(/^app_(fallback|prod|dev)_/, "");
server/utils/idHelpers.ts:26:export function validateAndNormalizeUUID(applicationId: string): string {
server/utils/idHelpers.ts:27:  const rawId = normalizeToUUID(applicationId);
server/routes/contacts.deals.ts:9:// List deals (pipeline applications) for a contact
server/routes/contacts.deals.ts:13:    from applications
server/routes/contacts.deals.ts:20:// Create a new deal (application) quick-add
server/routes/contacts.deals.ts:24:    insert into applications(contact_id, full_name, amount, stage)
server/routes/unifiedComms.ts:36:        message: "Thank you for your application. We'll be in touch soon.",
server/routes/lenderApps.ts:26:  // Enhanced triggers with pipeline SMS service
server/routes/lenderApps.ts:28:    const { smsOnFundsDisbursed } = await import("../services/pipelineSms");
server/routes/lenderApps.ts:38:  audit.log({ actor: req.user?.email, action: "pipeline:accepted", details: { appId, amount: updated.fundedAmount } });
server/routes/lenderApps.ts:54:    console.log(`[SMS] Application declined to ${app.contactPhone}`);
server/routes/lenderApps.ts:63:  audit.log({ actor: req.user?.email, action: "pipeline:declined", details: { appId } });
server/routes/test-applications.ts:7:  console.log('üß™ TEST ROUTE: /api/applications working!');
server/routes/test-applications.ts:10:    message: 'Test applications route is working!',
server/utils/securityValidator.ts:39:  applicationId: z.string().uuid('Invalid application ID format'),
server/utils/securityValidator.ts:74:  // Escape SQL LIKE wildcards
server/utils/securityValidator.ts:130:    'application/pdf',
server/utils/securityValidator.ts:134:    'application/msword',
server/utils/securityValidator.ts:135:    'application/vnd.openxmlformats-officedocument.wordprocessingml.document',
server/routes/marketing.linkedin.ts:39:    headers: { "Content-Type": "application/x-www-form-urlencoded" }, 
server/routes/marketing.linkedin.ts:68:    headers: { Authorization: `Bearer ${tk}`, "Content-Type": "application/json" }, 
server/routes/testAcceptDocuments.ts:7:// Accept all documents for a given application (for testing ZIP download)
server/routes/testAcceptDocuments.ts:8:router.post('/accept-all/:applicationId', async (req, res) => {
server/routes/testAcceptDocuments.ts:9:  const { applicationId } = req.params;
server/routes/testAcceptDocuments.ts:12:    console.log(`üß™ [TEST] Accepting all documents for application: ${applicationId}`);
server/routes/testAcceptDocuments.ts:18:      WHERE application_id = $1 
server/routes/testAcceptDocuments.ts:24:    const result = await pool.query(updateQuery, [applicationId]);
server/routes/marketing.reports.ts:110:    res.setHeader('Content-Type', 'application/pdf');
server/utils/documentIntegrity.ts:11:    applicationId: string;
server/utils/documentIntegrity.ts:40:      SELECT id, file_name, file_path, application_id, created_at 
server/utils/documentIntegrity.ts:56:          applicationId: doc.application_id,
server/utils/documentIntegrity.ts:74:          applicationId: doc.application_id,
server/utils/documentIntegrity.ts:121:      console.log(`   - ${doc.id}: ${doc.fileName} (App: ${doc.applicationId})`);
server/utils/documentIntegrity.ts:129: * Get document integrity status for a specific application
server/utils/documentIntegrity.ts:131:export async function getApplicationDocumentIntegrity(applicationId: string): Promise<DocumentIntegrityReport> {
server/utils/documentIntegrity.ts:145:      SELECT id, file_name, file_path, application_id, created_at 
server/utils/documentIntegrity.ts:147:      WHERE application_id = $1
server/utils/documentIntegrity.ts:150:    const documentsResult = await pool.query(documentsQuery, [applicationId]);
server/utils/documentIntegrity.ts:161:          applicationId: doc.application_id,
server/utils/documentIntegrity.ts:179:          applicationId: doc.application_id,
server/utils/documentIntegrity.ts:188:    console.error('Error checking application document integrity:', error);
server/routes/o365.meeting.ts:15:    headers:{ Authorization:`Bearer ${token}`, "Content-Type":"application/json" },
server/routes/smsStageNotifications.ts:3: * Comprehensive SMS notification system for loan application stage transitions
server/routes/smsStageNotifications.ts:22:async function sendStageTransitionSMS(applicationId: string, fromStage: string, toStage: string): Promise<{ success: boolean; message?: string; error?: string }> {
server/routes/smsStageNotifications.ts:24:    console.log(`üì± [SMS-STAGE] Processing stage transition: ${fromStage} ‚Üí ${toStage} for application ${applicationId}`);
server/routes/smsStageNotifications.ts:26:    // Get application data and phone number
server/routes/smsStageNotifications.ts:27:    const applicationResult = await db.execute(sql`
server/routes/smsStageNotifications.ts:29:      FROM applications 
server/routes/smsStageNotifications.ts:30:      WHERE id = ${applicationId}
server/routes/smsStageNotifications.ts:34:    if (!applicationResult.rows.length) {
server/routes/smsStageNotifications.ts:35:      console.error(`‚ùå [SMS-STAGE] Application not found: ${applicationId}`);
server/routes/smsStageNotifications.ts:36:      return { success: false, error: 'Application not found' };
server/routes/smsStageNotifications.ts:39:    const application = applicationResult.rows[0] as any;
server/routes/smsStageNotifications.ts:40:    const formData = application.form_data;
server/routes/smsStageNotifications.ts:45:      console.log(`‚ö†Ô∏è [SMS-STAGE] No phone number found for application: ${applicationId}`);
server/routes/smsStageNotifications.ts:58:      message = `Hi ${firstName}, your loan application for ${businessName} is now under review. We'll contact you within 24-48 hours with updates. Reference: ${applicationId.slice(-6)}`;
server/routes/smsStageNotifications.ts:60:      message = `Great news ${firstName}! Your loan application for ${businessName} has been approved. Our team will contact you shortly to finalize terms. Reference: ${applicationId.slice(-6)}`;
server/routes/smsStageNotifications.ts:62:      message = `Hi ${firstName}, after careful review, we're unable to approve your loan application for ${businessName} at this time. Our team will call you to discuss alternatives. Reference: ${applicationId.slice(-6)}`;
server/routes/smsStageNotifications.ts:64:      message = `Hi ${firstName}, good news! Your application for ${businessName} has been sent to our lending partners for final approval. You should hear back within 2-3 business days. Reference: ${applicationId.slice(-6)}`;
server/routes/smsStageNotifications.ts:66:      message = `Hi ${firstName}, we're reviewing your application for ${businessName} and need additional documentation. Please check your portal and upload the required documents. Reference: ${applicationId.slice(-6)}`;
server/routes/smsStageNotifications.ts:88:        application_id,
server/routes/smsStageNotifications.ts:98:        ${applicationId},
server/routes/smsStageNotifications.ts:121:    const { applicationId, fromStage, toStage } = req.body;
server/routes/smsStageNotifications.ts:123:    if (!applicationId || !toStage) {
server/routes/smsStageNotifications.ts:126:        error: 'applicationId and toStage are required'
server/routes/smsStageNotifications.ts:130:    const result = await sendStageTransitionSMS(applicationId, fromStage, toStage);
server/utils/documentAuditReport.ts:2:import { applications, documents } from '../../shared/schema';
server/utils/documentAuditReport.ts:6:interface ApplicationAuditResult {
server/utils/documentAuditReport.ts:7:  applicationId: string;
server/utils/documentAuditReport.ts:17: * Run comprehensive audit across all applications
server/utils/documentAuditReport.ts:18: * @returns Promise<ApplicationAuditResult[]>
server/utils/documentAuditReport.ts:20:export async function runFullDocumentAudit(): Promise<ApplicationAuditResult[]> {
server/utils/documentAuditReport.ts:23:  // Get all applications
server/utils/documentAuditReport.ts:24:  const allApplications = await db.select().from(applications);
server/utils/documentAuditReport.ts:25:  console.log(`üìã Found ${allApplications.length} applications to audit`);
server/utils/documentAuditReport.ts:27:  const auditResults: ApplicationAuditResult[] = [];
server/utils/documentAuditReport.ts:29:  for (const app of allApplications) {
server/utils/documentAuditReport.ts:30:    console.log(`üîç Auditing application: ${app.id} (${app.businessName || 'Unknown Business'})`);
server/utils/documentAuditReport.ts:32:    // Get all documents for this application
server/utils/documentAuditReport.ts:36:      .where(eq(documents.applicationId, app.id));
server/utils/documentAuditReport.ts:45:          doc.applicationId,
server/utils/documentAuditReport.ts:58:      applicationId: app.id,
server/utils/documentAuditReport.ts:93:  report += '| Application | Business Name | DB Records | Files Found | Missing | Recovery Rate |\n';
server/utils/documentAuditReport.ts:101:    report += `| ${app.applicationId.substring(0, 8)}... | ${app.businessName} | ${app.documentsInDB} | ${app.filesOnDisk} | ${app.missingFiles} | ${recoveryRate}% |\n`;
server/utils/documentAuditReport.ts:111:  report += `- **Total Applications Audited**: ${results.length}\n`;
server/utils/documentAuditReport.ts:117:  // Applications with missing files
server/utils/documentAuditReport.ts:120:    report += '## Applications with Missing Files\n\n';
server/utils/documentAuditReport.ts:122:      report += `### ${app.businessName} (${app.applicationId})\n`;
server/routes/openapi.ts:13:          requestBody: { required: true, content: { "application/json": { schema: {
server/utils/documentHealthCheck.ts:203: * Get health status for specific application
server/utils/documentHealthCheck.ts:205:export async function getApplicationHealthStatus(applicationId: string): Promise<{
server/utils/documentHealthCheck.ts:206:  applicationId: string;
server/utils/documentHealthCheck.ts:214:    // Get documents for this application
server/utils/documentHealthCheck.ts:215:    const applicationDocuments = await db
server/utils/documentHealthCheck.ts:218:      .where(eq(documents.application_id, applicationId));
server/utils/documentHealthCheck.ts:225:    for (const document of applicationDocuments) {
server/utils/documentHealthCheck.ts:257:      applicationId,
server/utils/documentHealthCheck.ts:258:      totalDocuments: applicationDocuments.length,
server/utils/documentHealthCheck.ts:266:    console.error(`‚ùå [HEALTH] Application health check failed for ${applicationId}:`, error);
server/utils/documentHealthCheck.ts:267:    throw new Error(`Application health check failed: ${error instanceof Error ? error.message : 'Unknown error'}`);
server/routes/tasks.todo.ts:25:        { id: '2', title: 'Review Application #1001', status: 'inProgress', dueDateTime: { dateTime: '2025-08-20T10:00:00Z' } },
server/routes/tasks.todo.ts:42:      method:"POST", headers:{ Authorization:`Bearer ${token}`, "Content-Type":"application/json" },
server/utils/documentRepair.ts:95:    'uploads/signed_applications',
server/routes/s3UploadRoutes.ts:4: * Implements S3-first document upload for production pipeline
server/routes/s3UploadRoutes.ts:26:      'application/pdf',
server/routes/s3UploadRoutes.ts:27:      'application/msword',
server/routes/s3UploadRoutes.ts:28:      'application/vnd.openxmlformats-officedocument.wordprocessingml.document',
server/routes/s3UploadRoutes.ts:29:      'application/vnd.ms-excel',
server/routes/s3UploadRoutes.ts:30:      'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet',
server/routes/s3UploadRoutes.ts:46:// POST /api/public/s3-upload/:applicationId - S3 Direct Upload
server/routes/s3UploadRoutes.ts:47:router.post('/s3-upload/:applicationId', upload.single('document'), async (req: Request, res: Response) => {
server/routes/s3UploadRoutes.ts:48:  console.log(`üöÄ [S3-UPLOAD] Starting S3 direct upload for application: ${req.params.applicationId}`);
server/routes/s3UploadRoutes.ts:51:    const { applicationId } = req.params;
server/routes/s3UploadRoutes.ts:78:      applicationId: applicationId
server/routes/s3UploadRoutes.ts:86:        id, application_id, document_type, file_name, file_path, file_size, 
server/routes/s3UploadRoutes.ts:95:      applicationId,
server/routes/s3UploadRoutes.ts:119:        await fetch(`http://localhost:5000/api/ocr/application/${applicationId}`, {
server/routes/s3UploadRoutes.ts:122:            'Content-Type': 'application/json',
server/utils/permanentUploadMonitoring.ts:12:import { applications, documents } from '../../shared/schema.js';
server/utils/permanentUploadMonitoring.ts:16: * PERMANENT MONITORING QUERY - Detect applications with zero documents
server/utils/permanentUploadMonitoring.ts:19:export async function findZeroDocumentApplications(hours: number = 24): Promise<any[]> {
server/utils/permanentUploadMonitoring.ts:21:    console.log(`üîç [MONITORING] Checking for applications with zero documents in last ${hours} hours`);
server/utils/permanentUploadMonitoring.ts:24:      SELECT a.id as application_id, 
server/utils/permanentUploadMonitoring.ts:29:      FROM applications a
server/utils/permanentUploadMonitoring.ts:30:      LEFT JOIN documents d ON d.application_id = a.id
server/utils/permanentUploadMonitoring.ts:40:      console.log(`‚ö†Ô∏è [MONITORING] Found ${zeroDocApps.length} applications with zero documents:`);
server/utils/permanentUploadMonitoring.ts:42:        console.log(`   - ${app.application_id}: ${app.business_name} (${app.email})`);
server/utils/permanentUploadMonitoring.ts:45:      console.log(`‚úÖ [MONITORING] All applications have documents - upload system healthy`);
server/utils/permanentUploadMonitoring.ts:50:    console.error(`‚ùå [MONITORING] Error checking zero-document applications:`, error);
server/utils/permanentUploadMonitoring.ts:59:  totalApplications: number;
server/utils/permanentUploadMonitoring.ts:67:    const appCountResult = await db.execute(sql`SELECT COUNT(*) as count FROM applications`);
server/utils/permanentUploadMonitoring.ts:70:    const totalApplications = parseInt(appCountResult.rows[0]?.count as string) || 0;
server/utils/permanentUploadMonitoring.ts:72:    const averageDocsPerApp = totalApplications > 0 ? totalDocuments / totalApplications : 0;
server/utils/permanentUploadMonitoring.ts:74:    // Check for problematic applications
server/utils/permanentUploadMonitoring.ts:75:    const zeroDocApps = await findZeroDocumentApplications(24);
server/utils/permanentUploadMonitoring.ts:87:      totalApplications,
server/utils/permanentUploadMonitoring.ts:100:      totalApplications: 0,
server/utils/permanentUploadMonitoring.ts:123:      reasons.push(`${health.zeroDocumentApps} applications have zero documents`);
server/utils/permanentUploadMonitoring.ts:127:      reasons.push(`Low document ratio: ${health.averageDocsPerApp} docs per application`);
server/utils/permanentUploadMonitoring.ts:160:export function logConnectionEvent(eventType: string, applicationId: string, details?: any): void {
server/utils/permanentUploadMonitoring.ts:163:  console.log(`üü° [CONNECTION LOG] ${timestamp} - ${eventType} for application ${applicationId}`, details || '');
server/utils/recoveryLogger.ts:13:  applicationId: string;
server/utils/recoveryLogger.ts:51:      console.log(`   ‚îî‚îÄ Application: ${entry.businessName}`);
server/utils/recoveryLogger.ts:73:  async logRecoverySuccess(documentId: string, fileName: string, applicationId: string, businessName: string, recoveryMethod: string, newPath: string): Promise<void> {
server/utils/recoveryLogger.ts:78:      applicationId,
server/utils/recoveryLogger.ts:100:          document_id, file_name, application_id, legal_business_name, 
server/utils/recoveryLogger.ts:107:        entry.applicationId,
server/utils/recoveryLogger.ts:131:  async logMissingDetected(documentId: string, fileName: string, applicationId: string, businessName: string, expectedPath: string): Promise<void> {
server/utils/recoveryLogger.ts:136:      applicationId,
server/utils/recoveryLogger.ts:149:  async logRecoveryInitiated(documentId: string, fileName: string, applicationId: string, businessName: string): Promise<void> {
server/utils/recoveryLogger.ts:154:      applicationId,
server/utils/recoveryLogger.ts:170:    applicationId: string, 
server/utils/recoveryLogger.ts:181:      applicationId,
server/utils/recoveryLogger.ts:197:  async logRecoveryFailure(documentId: string, fileName: string, applicationId: string, businessName: string, error: string): Promise<void> {
server/utils/recoveryLogger.ts:202:      applicationId,
server/utils/recoveryLogger.ts:221:      applicationId: entry.applicationId,
server/routes/s3ProductionTest.ts:54:    const applicationId = req.body.applicationId || 'test-app-123';
server/routes/s3ProductionTest.ts:67:    console.log(`[S3-TEST] Application: ${applicationId}`);
server/routes/s3ProductionTest.ts:70:      applicationId,
server/routes/s3ProductionTest.ts:89:        applicationId
server/routes/s3Diagnostics.ts:4: * Real-time S3 configuration validation for Staff Application
server/routes/s3Diagnostics.ts:17: * GET /api/internal/debug/s3-status/:applicationId
server/routes/s3Diagnostics.ts:18: * Comprehensive S3 diagnostic for specific application
server/routes/s3Diagnostics.ts:20:router.get('/s3-status/:applicationId', async (req, res) => {
server/routes/s3Diagnostics.ts:22:    const { applicationId } = req.params;
server/routes/s3Diagnostics.ts:23:    console.log(`üîç [S3-DIAGNOSTIC] Running S3 validation for application: ${applicationId}`);
server/routes/s3Diagnostics.ts:25:    // Get all documents for this application
server/routes/s3Diagnostics.ts:26:    const applicationDocuments = await db
server/routes/s3Diagnostics.ts:37:      .where(eq(documents.applicationId, applicationId));
server/routes/s3Diagnostics.ts:39:    console.log(`üìã [S3-DIAGNOSTIC] Found ${applicationDocuments.length} documents`);
server/routes/s3Diagnostics.ts:43:    for (const doc of applicationDocuments) {
server/routes/s3Diagnostics.ts:114:      application_id: applicationId,
server/routes/s3Integration.ts:35:      const testBuffer = Buffer.from('S3 storage.set() test - Staff Application', 'utf8');
server/routes/s3Integration.ts:39:      const storageKey = await s3Storage.set(testBuffer, testFileName, 'test-application');
server/routes/appDetail.ts:19:// 1) LEFT: full application info (condense in UI if needed)
server/routes/appDetail.ts:34:    res.json({ application: appRec });
server/routes/appDetail.ts:36:    res.status(500).json({ error: "Failed to fetch application overview" });
server/routes/appDetail.ts:48:        application_id: appId,
server/routes/appDetail.ts:52:        body: "<p>Welcome to our loan application process.</p>",
server/routes/appDetail.ts:59:        application_id: appId,
server/routes/appDetail.ts:92:      application_id: appId,
server/routes/appDetail.ts:123:      application_id: appId,
server/routes/appDetail.ts:147:      application_id: appId,
server/routes/appDetail.ts:171:      application_id: appId,
server/routes/appDetail.ts:187:// 3) RIGHT: deal summary (pipeline snapshot)
server/routes/appDetail.ts:194:      application_id: appId,
server/routes/risk.ts:3:import { applications, businesses, financialProfiles, riskAssessments } from "../../shared/schema";
server/routes/risk.ts:26:router.post("/analyze/:applicationId", simpleAuth, async (req, res) => {
server/routes/risk.ts:28:    const applicationId = req.params.applicationId;
server/routes/risk.ts:31:    // Get application with business and financial data
server/routes/risk.ts:32:    const [application] = await db
server/routes/risk.ts:34:        application: applications,
server/routes/risk.ts:38:      .from(applications)
server/routes/risk.ts:39:      .leftJoin(businesses, eq(applications.businessId, businesses.id))
server/routes/risk.ts:41:      .where(eq(applications.id, applicationId))
server/routes/risk.ts:44:    if (!application.application) {
server/routes/risk.ts:47:        error: "Application not found" 
server/routes/risk.ts:51:    const app = application.application;
server/routes/risk.ts:52:    const business = application.business;
server/routes/risk.ts:53:    const financial = application.financialProfile;
server/routes/risk.ts:80:      applicationId,
server/routes/risk.ts:122:      applicationId,
server/routes/risk.ts:195:          applicationId: a.applicationId,
server/routes/risk.ts:252:router.get("/assessment/:applicationId", simpleAuth, async (req, res) => {
server/routes/risk.ts:254:    const applicationId = req.params.applicationId;
server/routes/risk.ts:256:    const assessment = await riskEngine.getRiskAssessment(applicationId);
server/routes/risk.ts:261:        error: "No risk assessment found for this application"
server/routes/risk.ts:285:    const { applicationId, scenarios } = req.body;
server/routes/risk.ts:287:    if (!applicationId) {
server/routes/risk.ts:290:        error: "Application ID is required"
server/routes/risk.ts:295:    const baseAssessment = await riskEngine.getRiskAssessment(applicationId);
server/routes/risk.ts:338:        applicationId,
server/routes/risk.ts:356:router.get("/compliance-check/:applicationId", simpleAuth, async (req, res) => {
server/routes/risk.ts:358:    const applicationId = req.params.applicationId;
server/routes/risk.ts:360:    // Get application data
server/routes/risk.ts:361:    const [application] = await db
server/routes/risk.ts:363:      .from(applications)
server/routes/risk.ts:364:      .where(eq(applications.id, applicationId))
server/routes/risk.ts:367:    if (!application) {
server/routes/risk.ts:370:        error: "Application not found"
server/routes/risk.ts:376:    const formData = application.formData || {};
server/routes/risk.ts:377:    const loanAmount = Number(application.requestedAmount || 0);
server/routes/risk.ts:436:        applicationId,
server/routes/risk.ts:484:    // Compare application metrics to industry averages
server/routes/ai.insights.ts:7:r.get("/ai/insights/:applicationId", async (req,res)=>{
server/routes/ai.insights.ts:8:  const appId = req.params.applicationId;
server/routes/ai.insights.ts:10:  const { rows: docs } = await db.execute(sql`select id, category, status, name, version from documents where application_id=${appId}`);
server/routes/ai.insights.ts:11:  const { rows: tx } = await db.execute(sql`select posted_at, amount_cents, type from bank_tx where application_id=${appId} order by posted_at desc limit 500`);
server/routes/twilioTesting.disabled.ts:409:              message: 'Hello from Boreal Financial Staff Application!'
server/routes/upload.ts:12:import { documents, applicationDocuments, applications } from "../../shared/schema";
server/routes/upload.ts:41:    const applicationId = req.params.applicationId;
server/routes/upload.ts:43:    // Validate applicationId to prevent path traversal
server/routes/upload.ts:44:    if (!applicationId || typeof applicationId !== 'string') {
server/routes/upload.ts:45:      return cb(new Error('Invalid application ID'), '');
server/routes/upload.ts:51:    const safeId = applicationId.replace(/[^a-zA-Z0-9-_]/g, '');
server/routes/upload.ts:53:    if (applicationId !== safeId || (!uuidRegex.test(applicationId) && !numericRegex.test(applicationId))) {
server/routes/upload.ts:54:      return cb(new Error('Invalid application ID format'), '');
server/routes/upload.ts:57:    const uploadDir = path.join(process.cwd(), 'uploads', applicationId);
server/routes/upload.ts:88:    'application/pdf',
server/routes/upload.ts:89:    'application/x-pdf',
server/routes/upload.ts:90:    'application/octet-stream', // fallback for PDFs
server/routes/upload.ts:95:    'application/vnd.ms-excel',
server/routes/upload.ts:96:    'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet',
server/routes/upload.ts:99:    'application/json', // For testing
server/routes/upload.ts:126: * POST /api/upload/:applicationId
server/routes/upload.ts:127: * Upload files for an application (supports both 'files' array and 'document' single field)
server/routes/upload.ts:129:router.post("/:applicationId", 
server/routes/upload.ts:135:    const { applicationId } = req.params;
server/routes/upload.ts:140:    const cleanApplicationId = stripAppProdPrefix(applicationId);
server/routes/upload.ts:141:    console.log(`[ID MAPPING] Cleaned app_prod_ prefix: ${applicationId} ‚Üí ${cleanApplicationId}`);
server/routes/upload.ts:157:        if (!file.mimetype || file.mimetype === 'application/octet-stream') {
server/routes/upload.ts:163:    // Validate application exists using clean UUID
server/routes/upload.ts:164:    const [application] = await db
server/routes/upload.ts:166:      .from(applications)
server/routes/upload.ts:167:      .where(eq(applications.id, cleanApplicationId));
server/routes/upload.ts:169:    if (!application) {
server/routes/upload.ts:172:        error: "Application not found"
server/routes/upload.ts:193:          applicationId: cleanApplicationId,
server/routes/upload.ts:204:      // Skip application-document relationship for now since table may not exist
server/routes/upload.ts:205:      // await db.insert(applicationDocuments).values({
server/routes/upload.ts:206:      //   applicationId: cleanApplicationId,
server/routes/upload.ts:227:        processDocumentOCR(document.id, cleanApplicationId, document.filePath, category)
server/routes/crm.ts:99:    const { firstName, lastName, email, phone, source, applicationId } = req.body;
server/routes/crm.ts:114:      applicationId,
server/routes/crm.ts:137:    // Get companies from applications and contacts
server/routes/crm.ts:152:      FROM applications a
server/routes/crm.ts:153:      FULL OUTER JOIN contacts c ON a.id = c.application_id
server/routes/emailTemplates.ts:89:      html: "<p>This is a test email from the Boreal Financial Staff Application.</p><p>If you received this, the email system is working correctly.</p>"
server/routes/comms-voice.ts:21:      outgoingApplicationSid: process.env.TWILIO_VOICE_APP_SID,
server/routes/matchingEngine.ts:28: * GET /api/matching/:applicationId
server/routes/matchingEngine.ts:29: * Get matching lender products for an application
server/routes/matchingEngine.ts:32:router.get('/:applicationId', async (req: any, res: any) => {
server/routes/matchingEngine.ts:34:    const { applicationId } = req.params;
server/routes/matchingEngine.ts:37:    console.log(`üéØ [STEP 5 MATCHING] Starting matching engine for application ${applicationId}`);
server/routes/matchingEngine.ts:47:      WHERE application_id = $1`;
server/routes/matchingEngine.ts:49:    const docsResult = await pool.query(documentsQuery, [applicationId]);
server/routes/matchingEngine.ts:54:    // 2. Get application data with business info
server/routes/matchingEngine.ts:61:      FROM applications a
server/routes/matchingEngine.ts:65:    const appResult = await pool.query(appQuery, [applicationId]);
server/routes/matchingEngine.ts:68:      return res.status(404).json({ error: 'Application not found' });
server/routes/matchingEngine.ts:71:    const application = appResult.rows[0];
server/routes/matchingEngine.ts:90:      const matchResult = calculateMatchScore(application, product, {
server/routes/matchingEngine.ts:127:      applicationId,
server/routes/matchingEngine.ts:154:function calculateMatchScore(application: any, product: any, docStatus: any): { score: number, reason: string } {
server/routes/matchingEngine.ts:173:  const requestedAmount = application.requestedamount || application.fundingAmount || 0;
server/routes/matchingEngine.ts:186:  const appIndustry = application.industry?.toLowerCase() || '';
server/routes/matchingEngine.ts:205:  const appState = application.state?.toUpperCase() || 'US';
server/routes/matchingEngine.ts:214:  const annualRevenue = application.annual_revenue || 0;
server/routes/matchingEngine.ts:230: * POST /api/transmit/:applicationId/:productId
server/routes/matchingEngine.ts:231: * Send application to specific lender
server/routes/matchingEngine.ts:232: * STEP 5: Transmit application data to lender
server/routes/matchingEngine.ts:234:router.post('/transmit/:applicationId/:productId', async (req: any, res: any) => {
server/routes/matchingEngine.ts:236:    const { applicationId, productId } = req.params;
server/routes/matchingEngine.ts:239:    console.log(`üì§ [STEP 5 TRANSMIT] Sending application ${applicationId} to lender product ${productId}`);
server/routes/matchingEngine.ts:246:      WHERE application_id = $1`;
server/routes/matchingEngine.ts:248:    const docsResult = await pool.query(documentsQuery, [applicationId]);
server/routes/matchingEngine.ts:258:    // 2. Get complete application data
server/routes/matchingEngine.ts:273:      FROM applications a
server/routes/matchingEngine.ts:275:      LEFT JOIN documents d ON a.id = d.application_id AND d.status = 'accepted'
server/routes/matchingEngine.ts:279:    const appData = await pool.query(appDataQuery, [applicationId]);
server/routes/matchingEngine.ts:282:      return res.status(404).json({ error: 'Application not found' });
server/routes/matchingEngine.ts:298:    const application = appData.rows[0];
server/routes/matchingEngine.ts:304:        application_id, 
server/routes/matchingEngine.ts:314:      application: application,
server/routes/matchingEngine.ts:317:      documentsIncluded: application.documents?.length || 0
server/routes/matchingEngine.ts:321:      applicationId,
server/routes/matchingEngine.ts:330:    console.log(`‚úÖ [STEP 5 TRANSMIT] Successfully sent application to ${product.lender_name}, transmission ID: ${transmissionId}`);
server/routes/matchingEngine.ts:332:    // 5. Update application status to indicate it's been sent to lenders
server/routes/matchingEngine.ts:334:      `UPDATE applications SET status = 'submitted_to_lenders', updated_at = NOW() WHERE id = $1`,
server/routes/matchingEngine.ts:335:      [applicationId]
server/routes/matchingEngine.ts:341:      applicationId,
server/routes/matchingEngine.ts:345:      documentsIncluded: application.documents?.length || 0,
server/routes/matchingEngine.ts:347:      message: `Application successfully sent to ${product.lender_name}`
server/routes/matchingEngine.ts:353:      error: 'Failed to transmit application',
server/routes/applications-basic.ts:1:// server/routes/applications-basic.ts - Basic applications CRUD for deployment
server/routes/applications-basic.ts:12:// GET /api/applications - List applications
server/routes/applications-basic.ts:13:router.get("/applications", async (req, res) => {
server/routes/applications-basic.ts:18:      FROM applications 
server/routes/applications-basic.ts:24:    const applications = result.rows.map(row => ({
server/routes/applications-basic.ts:34:    res.json(applications);
server/routes/applications-basic.ts:36:    console.error("Applications list error:", e);
server/routes/applications-basic.ts:43:// GET /api/applications/:id - Get single application
server/routes/applications-basic.ts:44:router.get("/applications/:id", async (req, res) => {
server/routes/applications-basic.ts:49:      SELECT * FROM applications 
server/routes/applications-basic.ts:55:      return res.status(404).json({ error: "Application not found" });
server/routes/applications-basic.ts:71:    console.error("Application fetch error:", e);
server/routes/applications-basic.ts:78:// PATCH /api/applications/:id - Update application
server/routes/applications-basic.ts:79:router.patch("/applications/:id", async (req, res) => {
server/routes/applications-basic.ts:86:      UPDATE applications 
server/routes/applications-basic.ts:101:      return res.status(404).json({ error: "Application not found" });
server/routes/applications-basic.ts:104:    res.json({ success: true, application: result.rows[0] });
server/routes/applications-basic.ts:106:    console.error("Application update error:", e);
server/routes/documents-versioning.ts:63:      application_id: (old as any).application_id,
server/routes/documents-versioning.ts:67:      content_type: 'application/pdf',
server/routes/documents-versioning.ts:76:      INSERT INTO documents (application_id, category, name, s3_key, content_type, size_bytes, version, status, uploaded_by, group_id)
server/routes/documents-versioning.ts:77:      VALUES (${newDoc.application_id}, ${newDoc.category}, ${newDoc.name}, ${newDoc.s3_key}, ${newDoc.content_type}, ${newDoc.size_bytes}, ${newDoc.version}, ${newDoc.status}, ${newDoc.uploaded_by}, ${newDoc.group_id})
server/routes/o365.ts:38:      headers: { "Content-Type": "application/x-www-form-urlencoded" },
server/routes/deployment-health.ts:43:    // Check applications table exists
server/routes/deployment-health.ts:47:      WHERE table_name = 'applications'
server/routes/deployment-health.ts:57:        applications_table: tableCheck.rows.length > 0 ? "exists" : "missing",
server/routes/deployment-health.ts:79:    // Check if applications table exists and create demo data
server/routes/deployment-health.ts:81:      const countResult = await client.query("SELECT COUNT(*) FROM applications");
server/routes/deployment-health.ts:85:        // Insert demo applications
server/routes/deployment-health.ts:87:          INSERT INTO applications (id, user_id, requested_amount, status, use_of_funds, created_at)
server/routes/deployment-health.ts:96:        res.json({ status: "bootstrapped", applications_created: 3 });
server/routes/deployment-health.ts:99:        res.json({ status: "already_exists", applications_count: count });
server/routes/automationDemo.ts:3:import { PipelineAutomationService } from '../services/pipelineAutomation';
server/routes/automationDemo.ts:8:router.post('/demo/trigger-automation/:applicationId', async (req: any, res: any) => {
server/routes/automationDemo.ts:10:    const { applicationId } = req.params;
server/routes/automationDemo.ts:12:    console.log(`üß™ Manual automation demo triggered for application ${applicationId}`);
server/routes/automationDemo.ts:15:    const result = await PipelineAutomationService.checkDocumentCompletionStatus(applicationId);
server/routes/automationDemo.ts:19:      applicationId,
server/routes/automationDemo.ts:35:router.post('/demo/test-sms/:applicationId', async (req: any, res: any) => {
server/routes/automationDemo.ts:37:    const { applicationId } = req.params;
server/routes/automationDemo.ts:39:    console.log(`üì± Manual SMS demo triggered for application ${applicationId}`);
server/routes/automationDemo.ts:42:    const result = await PipelineAutomationService.notifyClientOfRejection(applicationId);
server/routes/automationDemo.ts:46:      applicationId,
server/routes/pipeline-move.ts:1:// server/routes/pipeline-move.ts
server/routes/pipeline-move.ts:24:      {sql:"UPDATE applications SET stage=$1, updated_at=NOW() WHERE id=$2", params:[to,id]},
server/routes/pipeline-move.ts:25:      {sql:"UPDATE applications SET status=$1, updated_at=NOW() WHERE id=$2", params:[to,id]},
server/routes/pipeline-move.ts:26:      {sql:"UPDATE applications SET stage=$1, modified_at=NOW() WHERE id=$2", params:[to,id]}
server/routes/pipeline-move.ts:46:      res.status(404).json({error:"application not found or update failed"});
server/routes/pipeline-move.ts:49:    console.error("Pipeline move error:", e);
server/routes/lenderOutcomes.ts:3:import { smsOnStage, smsOnFundsDisbursed } from '../services/pipelineSms';
server/routes/lenderOutcomes.ts:4:// REMOVED: logStageTransition (not exported from pipelineSms)
server/routes/lenderOutcomes.ts:40:    // Mock application lookup - replace with actual database query
server/routes/lenderOutcomes.ts:61:      console.log(`[LENDER-OUTCOME] Application ${appId} declined: ${reason}`);
server/routes/lenderOutcomes.ts:74:        console.log(`[LENDER-OUTCOME] Application ${appId} accepted with disbursement: $${amount || 'unknown'}`);
server/routes/lenderOutcomes.ts:78:        console.log(`[LENDER-OUTCOME] Application ${appId} offer accepted, awaiting disbursement`);
server/routes/lenderOutcomes.ts:106:    const appId = payload.referenceId || payload.appId || payload.applicationId;
server/routes/lenderOutcomes.ts:161:        console.log(`[WEBHOOK-OUTCOME] Application ${appId} declined via webhook`);
server/routes/lenderOutcomes.ts:164:        console.log(`[WEBHOOK-OUTCOME] Application ${appId} accepted via webhook, funds disbursed: ${fundsDisbursed}`);
server/routes/pipeline-normalized.ts:3:import pipelineBoard from "./pipeline-board";
server/routes/pipeline-normalized.ts:4:import pipelineMove from "./pipeline-move";
server/routes/pipeline-normalized.ts:8:r.use("/pipeline", pipelineBoard);
server/routes/pipeline-normalized.ts:9:r.use("/pipeline", pipelineMove);
server/routes/pipeline-normalized.ts:23:// GET /api/pipeline/board
server/routes/pipeline-normalized.ts:27:    // Try common applications schemas
server/routes/pipeline-normalized.ts:35:       FROM applications
server/routes/pipeline-normalized.ts:42:    if(!rows.length && err) return res.status(500).json({error:"applications query failed", detail:String(err)});
server/routes/pipeline-normalized.ts:55:// PATCH /api/pipeline/cards/:id/stage  { stage }
server/routes/pipeline-normalized.ts:56:r.patch("/cards/:id/stage", async (req,res)=>{
server/routes/pipeline-normalized.ts:66:      {sql:"UPDATE applications SET stage=$1, updated_at=NOW() WHERE id=$2", params:[stage,id]},
server/routes/pipeline-normalized.ts:67:      {sql:"UPDATE applications SET status=$1, updated_at=NOW() WHERE id=$2", params:[stage,id]},
server/routes/ai-train.ts:30:      'application/pdf',
server/routes/ai-train.ts:32:      'application/msword',
server/routes/ai-train.ts:33:      'application/vnd.openxmlformats-officedocument.wordprocessingml.document',
server/routes/ai-train.ts:35:      'application/json'
server/routes/ai-train.ts:62:    } else if (mimeType === 'application/json') {
server/routes/pipeline.stage.ts:4:import { applications, audits } from "../db/schema";
server/routes/pipeline.stage.ts:16:  submitted: "Your application has been submitted and is under review. We'll update you on progress.",
server/routes/pipeline.stage.ts:17:  in_review: "Your application is currently in review. Our team is analyzing your documents.",
server/routes/pipeline.stage.ts:19:  docs_accepted: "All documents have been accepted! Your application is moving forward.",
server/routes/pipeline.stage.ts:20:  sent_to_lender: "Great news! Your application has been sent to our lending partners for consideration."
server/routes/pipeline.stage.ts:25:    const apps = await db.select().from(applications);
server/routes/pipeline.stage.ts:41:    // Update application stage
server/routes/pipeline.stage.ts:42:    await db.update(applications).set({ stage }).where(eq(applications.id, appId));
server/routes/pipeline.stage.ts:47:      entity: 'application',
server/routes/pipeline.stage.ts:55:    const [app] = await db.select().from(applications).where(eq(applications.id, appId));
server/routes/pipeline.stage.ts:68:// GET /api/pipeline - List all applications
server/routes/pipeline.stage.ts:71:    const rows = await db.select().from(applications);
server/routes/pipeline.stage.ts:72:    console.info("[pipeline] listed", rows.length, "applications");
server/routes/pipeline.stage.ts:75:    console.error("[PIPELINE] List error:", error);
server/routes/settingsMem.ts:23:  pipelineDnd: true,
server/routes/settingsMem.ts:30:  "dashboard.cards.v2": { enabled: false, note: "New compact app card design" },
server/routes/settingsMem.ts:31:  "pipeline.lane.kpis": { enabled: true,  note: "Show counts + velocity per lane" },
server/routes/pipelineMem.ts:4:type Card = { id:string; applicant:string; amount?:number; docs_ok?:boolean; stage:StageKey; createdAt?:string };
server/routes/pipelineMem.ts:7:  lanes: new Map<StageKey, Card[]>([
server/routes/pipelineMem.ts:23:function findCard(id:string){
server/routes/pipelineMem.ts:26:    if (idx >= 0) return { stage, idx, card: arr[idx] };
server/routes/pipelineMem.ts:31:export default function pipelineMemRoutes(){
server/routes/pipelineMem.ts:39:  // GET single card details
server/routes/pipelineMem.ts:40:  r.get("/cards/:id", (req, res) => {
server/routes/pipelineMem.ts:41:    const found = findCard(req.params.id);
server/routes/pipelineMem.ts:43:    res.json(found.card);
server/routes/pipelineMem.ts:46:  // PATCH card stage (primary DnD endpoint)
server/routes/pipelineMem.ts:47:  r.patch("/cards/:id/stage", (req, res) => {
server/routes/pipelineMem.ts:51:    const found = findCard(req.params.id);
server/routes/pipelineMem.ts:52:    if (!found) return res.status(404).json({ error: "card not found" });
server/routes/pipelineMem.ts:55:    if (to === "in_review" && !found.card.docs_ok) {
server/routes/pipelineMem.ts:61:    found.card.stage = to;
server/routes/pipelineMem.ts:62:    mem.lanes.get(to)!.unshift(found.card);
server/routes/pipelineMem.ts:64:    res.json({ ok: true, id: found.card.id, stage: to });
server/routes/pipelineMem.ts:74:    const found = findCard(id);
server/routes/pipelineMem.ts:75:    if (!found) return res.status(404).json({ error: "card not found" });
server/routes/pipelineMem.ts:79:    if (to === "in_review" && !found.card.docs_ok) {
server/routes/pipelineMem.ts:85:    found.card.stage = to;
server/routes/pipelineMem.ts:86:    mem.lanes.get(to)!.unshift(found.card);
server/routes/pipelineMem.ts:88:    res.json({ ok: true, id: found.card.id, stage: to });
server/routes/documents-real.ts:5:// POST /api/documents/presign-upload { applicationId, filename, contentType }
server/routes/documents-real.ts:7:  const appId = String(req.body?.applicationId||"").trim();
server/routes/documents-real.ts:9:  const ct = String(req.body?.contentType||"application/octet-stream");
server/routes/documents-real.ts:10:  if(!appId || !filename) return res.status(400).json({error:"applicationId and filename required"});
server/routes/documents-real.ts:11:  const key = `applications/${appId}/uploads/${Date.now()}-${filename}`;
server/routes/settings.ts:7:type Flags = { pipelineDnd:boolean; comms:boolean; lendersAdmin:boolean; strictAuth:boolean };
server/routes/settings.ts:22:      flags: { pipelineDnd:true, comms:true, lendersAdmin:true, strictAuth:false }
server/routes/settings.ts:66:  const allowed = ["pipelineDnd","comms","lendersAdmin","strictAuth"] as (keyof Flags)[];
server/routes/pipeline-lite.ts:5:type Card = { id:string; applicant?:string; name?:string; amount?:number; docs_ok?:boolean; stage?:Stage; createdAt?:string; [k:string]:any };
server/routes/pipeline-lite.ts:6:type Board = Record<Stage, Card[]>;
server/routes/pipeline-lite.ts:8:const FILE = path.join(DATA_DIR,"pipeline.json");
server/routes/pipeline-lite.ts:25:r.get("/cards/:id", (req,res)=>{ const b=load(); for(const k of Object.keys(b) as Stage[]){ const hit=b[k].find(c=>c.id===req.params.id); if(hit) return res.json(hit); } return res.status(404).json({error:"not found"}); });
server/routes/pipeline-lite.ts:26:r.patch("/cards/:id/move", (req,res)=>{ const to = (req.body?.stage||"").toString() as Stage;
server/routes/pipeline-lite.ts:28:  const b=load(); let moved:Card|undefined; let from:Stage|undefined;
server/routes/pipeline-lite.ts:29:  for(const k of Object.keys(b) as Stage[]){ const i=b[k].findIndex(c=>c.id===req.params.id); if(i>=0){ from=k; const [card]=b[k].splice(i,1); card.stage=to; moved=card; break; } }
server/routes/settings-lite.ts:16:      flags: { pipelineDnd:true, commsCenter:false, lendersAdmin:true, strictAuth:false },
server/routes/settings-lite.ts:17:      experiments: { "dashboard.cards.v2":{enabled:false,note:"New layout"}, "pipeline.lane.kpis":{enabled:false,note:"Lane metrics"} }
server/routes/recs.ts:2:import { allItems } from "../pipeline/store";
server/routes/recs.ts:33:    .setHeader("Content-Type", "application/pdf")
server/routes/apps.ts:2:import { allItems } from "../pipeline/store";
